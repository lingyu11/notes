# 绪论

## 资料
* [Yanyan's wiki](https://jyywiki.cn/)
* [课程网站](https://jyywiki.cn/OS/2024/)
* [课程视频](https://www.bilibili.com/video/BV1Xm411f7CM/?spm_id_from=333.788&vd_source=2a33d03ec3e67e46971208a7faa0dcda)
* [教材 OSTEP](https://pages.cs.wisc.edu/~remzi/OSTEP/)

## 操作系统是什么
1. **在应用程序眼中，操作系统 = 对象 + API。**从应用程序的视角看，操作系统定义了一系列的对象 (进程/线程、地址空间、文件、设备……) 和操纵它们的 API (系统调用)。
2. **在硬件眼中，操作系统 = C 程序。**从硬件的视角看，操作系统是一个拥有访问全部硬件功能的程序。硬件会帮助操作系统完成最初的初始化和加载，之后，操作系统加载完第一个程序后，从此作为 “中断处理程序” 在后台管理整个计算机系统。
3. **在上帝眼中，操作系统 = 一个数学对象。**我们可以把计算机系统 (电路) 建模成有限状态机模型，当然也可以把运行在硬件上的任何软件 (包括操作系统) 建模成状态机。

!!! info "Operating System concept"

    Operating System: A body of software, in fact, that is responsible for *making it easy to run programs* (even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that. (OSTEP)

## Lecture 1 操作系统概述
1. 时钟、导线、逻辑门(NAND，即与非门)、寄存器是数字系统的基本组成部分：数字系统在时钟驱动下离散地更新下一周期的寄存器状态。
2. 数字电路模拟器，编译：`gcc -o logisim -I. logisim.c`, 其中`-I.`指定当前目录（`.`）为头文件搜索路径，这意味着编译器会在当前目录下查找头文件。运行：`./logisim`，可视化运行: `make run`或`./logisim | python seg-display.py`。单独运行`python seg-display.py`时，程序会等着输入，此时输入`A=1`即可点亮数码管。
3. RISC-V 处理器模拟器，编译：`gcc -g -o mini-rv32ima main.c`或`make`，运行：`./mini-rv32ima bin/fib.rv32i-bin 10`，结果存在a0寄存器。CSR（Control and Status Register，控制和状态寄存器）是一组特殊的寄存器，用于控制和监控处理器的运行状态。这些寄存器通常包含了处理器的各种配置信息、状态信息和控制信息，例如中断控制、时钟控制、性能监控、电源管理等。

## Lecture 2 应用视角的操作系统
!!! abstract "Take-away Messages"

    Everything (高级语言代码、机器代码) 都是状态机；而编译器实现了两种状态机之间的翻译。无论何种状态机，在没有操作系统时，它们只能做纯粹的计算，甚至都不能把结果传递到程序之外——而程序与操作系统沟通的唯一桥梁是<span style="color:blue;">系统调用</span> (例如 x86-64 的 `syscall` 指令)。如此重要的桥梁，操作系统中自然也有工具：`strace` 可以查看程序运行过程中的系统调用序列。

1. hello.c: 查看文件类型`file a.out`
```C
int main() {
    printf("Hello, World\n");
}
```
```bash
linux$ gcc hello.c 
linux$ ./a.out 
Hello, World
linux$ file a.out 
a.out: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=8fb1a66864c9ab4a1a8f9b6b2160b2226f1c03d3, for GNU/Linux 3.2.0, not stripped
linux$ objdump -d a.out | less
linux$ readelf -a a.out | less
linux$ gcc hello.c -static # 静态链接意味着生成的可执行文件将包含所有需要的库代码，因此它不依赖于系统中已安装的共享库。这样做的好处是可执行文件可以在任何支持该架构的系统上运行，而不需要担心库的兼容性问题。但是，这也意味着可执行文件会比较大，因为它包含了所有的库代码。
linux$ file a.out 
a.out: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=80ecb022dad2875af2eaf8f2b38d7a62d40ae20e, for GNU/Linux 3.2.0, not stripped
linux$ objdump -d a.out | less  # 显然不是最小的可执行文件
linux$ readelf -a a.out | less
```
2. 试试空函数：
```C
int main() {
}
```
```bash
linux$ gcc -c hello.c   # 只编译不链接，生成hello.o
linux$ ld hello.o       # 链接，生成a.out，虽然有warning
ld: warning: cannot find entry symbol _start; defaulting to 0000000000401000
linux$ ./a.out 
Segmentation fault
linux$ gdb a.out        # 开始调试
```

    !!! failure "Segmentation fault"
        表示程序访问了不允许访问的内存区域。这通常是由于程序中的错误导致的，例如指针错误、数组越界、栈溢出等。

3. 利用gdb调试，在执行return之前，M[rsp]里是1(rsp: Stack Pointer，即栈指针)，而执行return是将M[rsp]赋值给PC，rsp+8（将返回地址从栈顶弹出，并缩栈），PC指向了1（显然是不可访问的地址），所以会出现segmentation fault。
```bash
(gdb) si       # 依次单步执行，发现到ret指令时再下一步就会出现segmentation fault
0x0000000000000001 in ?? ()  # 这里的1有问题
(gdb) p $rsp   # 打印栈指针的值, 输出 $1 = (void *) 0x7fffffffdcb0
(gdb) x/x $rsp # 查看M[rsp]，输出 0x7fffffffdcb0: 0x00000001
```
4. 最小的hello world程序：minimal.S
```asm
#include <sys/syscall.h>

// The x86-64 system call Application Binary Interface (ABI):
//     System call number: RAX
//     Arguments: RDI, RSI, RDX, RCX, R8, R9
//     Return value: RAX
// See also: syscall(2) syscalls(2)

#define syscall3(id, a1, a2, a3) \
    movq $SYS_##id, %rax; \
    movq $a1, %rdi; \
    movq $a2, %rsi; \
    movq $a3, %rdx; \
    syscall

#define syscall2(id, a1, a2)  syscall3(id, a1, a2, 0)
#define syscall1(id, a1)  syscall2(id, a1, 0)

.globl _start
_start:
    syscall3(write, 1, addr1, addr2 - addr1) # 执行write这个系统调用，往编号为1的文件描述符（即标准输出）写入字符串，字符串长度为addr2-addr1
    syscall1(exit, 1)

addr1:
    .ascii "\033[01;31mHello, OS World\033[0m\n"
addr2:
```
5. 跟踪系统调用：`strace -f gcc -o hello hello.c &| vim -` (fish可用，bash不可用)。`&` 符号表示将命令放在后台运行，而 `|` 符号表示将 strace 命令的输出作为 vim 编辑器的输入。`-` 表示 vim 应该从标准输入读取数据，而不是从一个文件。vim打开后用`:%!grep -v -e '-1'`过滤掉-1的行，用`:%!grep -v -e open`过滤掉带open的行。

6. Debug hanoi-nr.c要配置好的.vscode/launch.json
    ```json
    {
        "version": "0.2.0",
        "configurations": [
            {
                "name": "C Debugger: Current File",
                "type": "cppdbg",
                "request": "launch",
                "program": "${workspaceFolder}/hanoi-nr",
                "args": [],
                "cwd": "${workspaceFolder}",
            }
        ]
    }
    ```

    递归的汉诺塔 hanoi-r.c：
    ```C
    #include <stdio.h>

    int hanoi(int n, char from, char to, char via) {
        if (n == 1) {
            printf("%c -> %c\n", from, to);
            return 1;
        } else {
            int c1 = hanoi(n - 1, from, via, to);
            hanoi(1, from, to, via);
            int c2 = hanoi(n - 1, via, to, from);
            return c1 + c2 + 1;
        }
    }
    ```

    非递归的汉诺塔 hanoi-nr.c：
    ```C
    #include <stdio.h>
    #include <assert.h>

    struct Frame {
        // Each frame has a program counter to keep track its next
        // to-be-executed statement.
        int pc;

        // The internal state of the frame. This state includes
        // both arguments and local variables (if any).
        //
        // Arguments:
        int n;
        char from, to, via;

        // Local variables:
        int c1, c2;
    };

    typedef struct Frame Frame;

    int hanoi(int n, char from, char to, char via) {
        Frame stk[64];
        Frame *top = stk - 1;

        // Function call: push a new frame (PC=0) onto the stack
        #define call(...) ({ *(++top) = (Frame){.pc = 0, __VA_ARGS__}; })
        
        // Function return: pop the top-most frame
        #define ret(val) ({ top--; retval = (val); })


        // The last function-return's value. It is not obvious
        // that we only need one retval.
        int retval = 0;

        // The initial call to the recursive function
        call(n, from, to, via);

        while (1) {
            // Fetch the top-most frame.
            Frame *f = top;
            if (top < stk) {
                // No top-most frame any more; we're done.
                break;
            }

            // Jumps may change this default next pc.
            int next_pc = f->pc + 1;

            // Single step execution.

            // Extract the parameters from the current frame. (It's
            // generally a bad idea to reuse variable names in
            // practice; but we did it here for readability.)
            int n = f->n, from = f->from, to = f->to, via = f->via;

            switch (f->pc) {
                case 0:
                    if (n == 1) {
                        printf("%c -> %c\n", from, to);
                        ret(1);
                    }
                    break;
                case 1: call(n - 1, from, via, to); break;
                case 2: f->c1 = retval; break;
                case 3: call(1, from, to, via); break;
                case 4: call(n - 1, via, to, from); break;
                case 5: f->c2 = retval; break;
                case 6: ret(f->c1 + f->c2 + 1); break;
                default: assert(0);
            }

            f->pc = next_pc;
        }

        return retval;
    }
    ```

    !!! note "Call and Return"

        函数调用：在程序中调用一个函数时，程序会将当前执行的指令地址（即程序计数器）保存到栈中，并跳转到被调用函数的起始地址。被调用函数执行完毕后，程序会从栈中取出保存的指令地址，并跳转到该地址继续执行。

        函数返回：在函数中使用return语句时，程序会将返回值保存到栈中，并跳转到调用函数的下一条指令。调用函数执行完毕后，程序会从栈中取出保存的返回值，并将其返回给调用者。

        也就是说，call是长出新的frame(注意<span style="color:blue;">**每个frame都有自己的pc**</span>，新长出的frame.pc = 0，新frame开始执行时，都是从自己fram的pc=0开始一步步执行自己pc=1/2/3/...)，return是弹出当前的frame并记下返回值。

7. 编译器与编译优化

    !!! note "编译优化"

        C 语言编译器在进行代码优化时，遵循的基本准则是在不改变程序的语义 (即程序的行为和输出结果) 的前提下，提高程序的执行效率和/或减少程序的资源消耗
        
    编译优化中最重要的 “三板斧”：

    * **函数内联**：将函数调用替换为函数体本身的内容
    * **常量传播**：在编译时计算常量表达式的值并替换
    * **死代码消除**：删除永远不会被执行到的代码

    编译正确性: 系统调用是使程序计算结果<span style="color:blue;">可见</span>的唯一方法

    * 不改变语义 = 不改变可见结果
    * 状态机的视角：满足<span style="color:blue;">C/汇编状态机生成的所有 syscall 序列完全一致</span>，任何优化都是允许的
    
    C 代码中的不可优化部分

    * External function calls (链接时才能确定到底是什么代码)
        - 未知的代码可能包含<span style="color:blue;">系统调用</span>
        - 因此不可删除、移出循环等，且要保证参数传递完全一致
    * 编译器提供的 “不可优化” 标注
        - volatile [load | store | inline assembly]

    example：inline.c
    ```C
    int equals(int x, int y) {
        if (x == y) {
            return 1;
        } else {
            return 0;
        }
    }

    int foo(int n) {
        return equals(n, n) + equals(n, n - 1);
    }
    ```
    `gcc -O2 -c inline.c && objdump -d inline.o`: 可以看到编译器直接将1赋值给eax寄存器了，而不是调用equals函数。

    ```bash
    0000000000000010 <foo>:
    10:   f3 0f 1e fa             endbr64 
    14:   b8 01 00 00 00          mov    $0x1,%eax
    19:   c3                      ret
    ```

## Lecture 3 硬件视角的操作系统
!!! abstract "Take-away Messages"

    计算机系统是严格的数学对象：没有魔法；计算机系统的一切行为都是可观测、可理解的。

    * 处理器是无情的执行指令的机器。
    * 处理器会规定好 Reset 后的行为。
    * Reset 后 Firmware 开始运行，再加载操作系统。
    * 厂商逐渐形成了达成共识的 Firmware Specification (IBM PC “兼容机”、UEFI、……)。

1. IBM PC/PC-DOS 2.0 (1983)时代：Firmware (BIOS) 会加载磁盘的前 512 字节到 0x7c00，如果这 512 字节最后是 `0x55, 0xAA`，就认为这是一个合法的操作系统，然后从 0x7c00 开始执行操作系统代码。
```Makefile
minimal.img: Makefile
	( echo "eb fe 11 22 33 44" | xxd -r -p; \
	  cat /dev/zero | head -c 504; \
	  echo "55 aa" | xxd -r -p \
	) > minimal.img
```

    这个makefile会生成一个512字节的img文件，前6个字节是`eb fe 11 22 33 44`，中间504个字节都是0，最后两个字节是`55 aa`。使用`qemu-system-x86_64 -monitor stdio minimal.img`启动后可以通过以下命令看到eip确实是0x7c00，当前指令为死循环。(eb fe即为死循环`jmp .`)

    ```bash
    (qemu) p $eip
    0x7c00
    (qemu) x/i $eip
    0x0000000000007c00:  jmp    0x7c00
    ```

    通过`qemu-system-x86_64 -s -S minimal.img &`和`gdb -x init.gdb`可以看到是2个字节2个字节的将磁盘内容搬到0x7c00处的，使用的指令是`rep insl (%dx),%es:(%edi)​`
    ```bash
    # init.gdb
    # Kill process (QEMU) on gdb exits
    define hook-quit
        kill
    end

    define hook-stop
        printf "Program Counter:\n"
        x/i $rip + ($cs * 16)
        printf "------- Memory around 0x7c00 -------\n"
        x/16b 0x7c00
    end

    # Connect to remote
    target remote localhost:1234
    watch *0x7c00
    break *0x7c00
    layout asm
    continue
    ```

## Lecture 4 数学视角的操作系统
!!! abstract "Take-away Messages"

    程序就是状态机；状态机可以用程序表示。因此：

    * 我们可以用更 “简单” 的方式 (例如 Python) 描述状态机、建模操作系统上的应用，并且实现操作系统的可执行模型。
    * 一旦把操作系统、应用程序当做 “数学对象” 处理，那么我们图论、数理逻辑中的工具就能被应用于处理程序——例如，可以用图遍历 “暴力枚举” 的方法证明程序的正确性。

1. Debug os-model.py要配置好的.vscode/launch.json
```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Python Debugger: Current File",
            "type": "debugpy",
            "request": "launch",
            "program": "${file}",
            "args": ["hello.py"],
            "console": "integratedTerminal"
        }
    ]
}
```
2. os-model.py: 30行建模操作系统
```python
#!/usr/bin/env python3

import sys
import random
from pathlib import Path

class OS:
    '''
    A minimal executable operating system model. Processes
    are state machines (Python generators) that can be paused
    or continued with local states being saved.
    '''

    '''
    We implement three system calls:

    - read: read a random bit value.
    - write: write a string to the buffer.
    - spawn: create a new state machine (process).
    '''
    SYSCALLS = ['read', 'write', 'spawn']

    class Process:
        '''
        A "freezed" state machine. The state (local variables,
        program counters, etc.) are stored in the generator
        object.
        '''

        def __init__(self, func, *args):
            # func should be a generator function. Calling
            # func(*args) returns a generator object.
            self._func = func(*args)

            # This return value is set by the OS's main loop.
            self.retval = None

        def step(self):
            '''
            Resume the process with OS-written return value,
            until the next system call is issued.
            '''
            syscall, args, *_ = self._func.send(self.retval)
            self.retval = None
            return syscall, args

    def __init__(self, src):
        # This is a hack: we directly execute the source
        # in the current Python runtime--and main is thus
        # available for calling.
        exec(src, globals())
        self.procs = [OS.Process(main)]
        self.buffer = ''

    def run(self):
        # Real operating systems waste all CPU cycles
        # (efficiently, by putting the CPU into sleep) when
        # there is no running process at the moment. Our model
        # terminates if there is nothing to run.
        while self.procs:

            # There is also a pointer to the "current" process
            # in today's operating systems.
            current = random.choice(self.procs)

            try:
                # Operating systems handle interrupt and system
                # calls, and "assign" CPU to a process.
                match current.step():
                    case 'read', _:
                        current.retval = random.choice([0, 1])
                    case 'write', s:
                        self.buffer += s
                    case 'spawn', (fn, *args):
                        self.procs += [OS.Process(fn, *args)]
                    case _:
                        assert 0

            except StopIteration:
                # The generator object terminates.
                self.procs.remove(current)

        return self.buffer

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print(f'Usage: {sys.argv[0]} file')
        exit(1)

    src = Path(sys.argv[1]).read_text()

    # Hack: patch sys_read(...) -> yield "sys_read", (...)
    for syscall in OS.SYSCALLS:
        src = src.replace(f'sys_{syscall}',
                          f'yield "{syscall}", ')

    stdout = OS(src).run()
    print(stdout)
```

3. Mosaic Model and Checker: 
    ```python
    def main():
        pid = sys_fork()
        sys_sched()  # non-deterministic context switch
        if pid == 0:
            sys_write('World\n')
        else:
            sys_write('Hello\n')
    ```
    `python mosaic.py -c examples/intro/hello.py | grep stdout | sort | uniq`输出：(-c checking模式下，会输出所有可能的结果)
    ```bash
    "stdout": "",
    "stdout": "Hello\n",
    "stdout": "Hello\nWorld\n",
    "stdout": "World\n",
    "stdout": "World\nHello\n",
    ```

