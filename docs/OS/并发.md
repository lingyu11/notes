# å¹¶å‘

## Lecture 5 å¤šå¤„ç†å™¨ç¼–ç¨‹
!!! abstract "Take-away Messages"

    åœ¨ç®€åŒ–å¤šçº¿ç¨‹çš„æ¨¡å‹ä¸­ï¼Œå¹¶å‘ç¨‹åºå°±æ˜¯ â€œçŠ¶æ€æœºçš„é›†åˆâ€ï¼Œæ¯ä¸€æ­¥é€‰ä¸€ä¸ªçŠ¶æ€æœºæ‰§è¡Œä¸€æ­¥ã€‚ç„¶è€Œï¼ŒçœŸå®çš„ç³»ç»Ÿå´å› ä¸º â€œç¼–è¯‘å™¨â€ çš„æ— å¤„ä¸åœ¨ï¼Œä½¿å…±äº«å†…å­˜å¹¶å‘çš„è¡Œä¸ºååˆ†å¤æ‚ã€‚

    ä¸å¹¸çš„æ˜¯ï¼Œäººç±»æœ¬è´¨ä¸Šæ˜¯ç‰©ç†ä¸–ç•Œ (å®è§‚æ—¶é—´) ä¸­çš„ â€œsequential creatureâ€ï¼Œå› æ­¤æˆ‘ä»¬åœ¨ç¼–ç¨‹æ—¶ï¼Œæˆ‘ä»¬çš„ç›´è§‰ä¹Ÿåªä¹ æƒ¯äºå•çº¿ç¨‹çš„é¡ºåº/é€‰æ‹©/å¾ªç¯ç»“æ„ï¼ŒçœŸå®å¤šå¤„ç†å™¨ä¸Šçš„å¹¶å‘ç¼–ç¨‹æ˜¯éå¸¸å…·æœ‰æŒ‘æˆ˜æ€§çš„ â€œåº•å±‚æŠ€æœ¯â€ã€‚åœ¨åç»­çš„è¯¾ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šæå‡ºè‹¥å¹²å¹¶å‘æ§åˆ¶æŠ€æœ¯ï¼Œä½¿å¾—æˆ‘ä»¬å¯ä»¥åœ¨éœ€è¦çš„æ—¶å€™é¿å…å¹¶å‘çš„å‘ç”Ÿï¼Œä½¿å¹¶å‘ç¨‹åºé€€å›åˆ°é¡ºåºç¨‹åºï¼Œä»è€Œä½¿æˆ‘ä»¬èƒ½å¤Ÿç†è§£å’Œæ§åˆ¶å¹¶å‘ã€‚

1. ç®€åŒ–çš„çº¿ç¨‹ API (thread.h)
    * `create(fn)`
        - åˆ›å»ºä¸€ä¸ªå…¥å£å‡½æ•°æ˜¯ `fn` çš„çº¿ç¨‹ï¼Œå¹¶ç«‹å³å¼€å§‹æ‰§è¡Œ
            + `void fn(int tid) { ... }`
            + å‚æ•° `tid` ä» 1 å¼€å§‹ç¼–å·
        - è¡Œä¸ºï¼š`sys_spawn(fn, tid)`
    * `join()`
        - ç­‰å¾…æ‰€æœ‰è¿è¡Œçº¿ç¨‹çš„è¿”å› (ä¹Ÿå¯ä»¥ä¸è°ƒç”¨)
        - è¡Œä¸ºï¼š`while (done != T) sys_sched()`
2. hello.cäº¤æ›¿æ‰“å° a å’Œ b

    ```C
    #include "thread.h"

    void T_a() { while (1) { printf("a"); } }
    void T_b() { while (1) { printf("b"); } }

    int main() {
        create(T_a);
        create(T_b);
    }
    ```

    `top -d 0.5`: æŸ¥çœ‹è¿›ç¨‹çš„ CPU å ç”¨ç‡ï¼Œå¯ä»¥çœ‹åˆ° CPU ä½¿ç”¨ç‡è¿‘ä¹ 200%ï¼Œè¯´æ˜ä¸¤ä¸ªçº¿ç¨‹å‡ ä¹åŒæ—¶è¿è¡Œã€‚æ“ä½œç³»ç»Ÿä¼šè‡ªåŠ¨æŠŠçº¿ç¨‹æ”¾ç½®åœ¨ä¸åŒçš„å¤„ç†å™¨ä¸Šï¼Œä»¥æé«˜æ•ˆç‡ã€‚

    ```bash
    PID   USER      PR   NI  VIRT   RES  SHR S %CPU   %MEM  TIME+   COMMAND
    26408 username  20   0   84796  956  868 S 196.0  0.0   0:43.42 hello
    ```

3. T_a å’Œ T_b çœŸçš„å…±äº«å†…å­˜å—ï¼Ÿâ†’ memory.c

    ```C
    #include "thread.h"

    // We claim that n is shared among threads.
    int n;

    void T_hello(int id) {
        // To validate this claim, each thread reads and increments
        // n, and we expect to see different numbers being printed.
        int i = n++;
        printf("%d\n", i);
    }

    int main() {
        for (int i = 0; i < 10; i++) {
            create(T_hello);
        }
    }
    ```

4. å¦‚ä½•è¯æ˜çº¿ç¨‹å…·æœ‰ç‹¬ç«‹å †æ ˆ (ä»¥åŠç¡®å®šå †æ ˆçš„èŒƒå›´)ï¼Ÿâ†’ stack.c

    ```C
    #include "thread.h"

    #define N 4

    char * volatile low[N];
    char * volatile high[N];

    void update_range(int T, char *ptr) {
        // We have a witness of thread T accessing stack pointer
        // ptr. So we keep this record.
        if (ptr < low[T]) {
            low[T] = ptr;
        }
        if (ptr > high[T]) {
            high[T] = ptr;
        }
    }

    void probe(int T, int n) {
        // Local variables are stack-allocated.
        char scratch[64];
        update_range(T, scratch);

        printf("Stack(T%d) >= %ld KB\n",
            T, (high[T] - low[T]) / 1024);

        probe(T, n + 1); // Infinite recursion.
    }

    void T_probe(int T) {
        T -= 1; // åˆ›å»ºçš„çº¿ç¨‹pidä»1å¼€å§‹ï¼Œæ‰€ä»¥T-1ä»¥æ‹¿åˆ°æ­£ç¡®çš„low[T]
        low[T] = (char *)-1;  // 0xffffffffffffffff
        high[T] = (char *)0;  // 0x0000000000000000
        probe(T, 0);
    }

    int main() {
        // Disable printf buffering. Try to make more lines being
        // printed, because the program will eventually crash (and
        // all buffered contents are lost).
        setbuf(stdout, NULL);

        for (int i = 0; i < N; i++) {
            create(T_probe);
        }
    }
    ```

    ç¨‹åºè¾“å‡ºï¼š
    ```bash
    ----- Shared Memory Test -----
    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
    ----- Stack Probe Test -----
    Segmentation fault (core dumped)
    Stack(T2) >= 8177 KB
    ```
    8177KBæœ€æ¥è¿‘8192KBï¼Œä¹Ÿå°±æ˜¯è¯´çº¿ç¨‹åº“é»˜è®¤æä¾›çš„stackå¤§å°æ˜¯8MBï¼Œè¿™ä¸ªå¤§å°è¶³ä»¥å¤Ÿä¸€èˆ¬çš„ç¨‹åºä½¿ç”¨äº†ã€‚

5. å¯¹äºå¹¶å‘ç¼–ç¨‹ï¼Œè¦èˆå¼ƒä¸€äº›æˆ‘ä»¬ä¹‹å‰å¯¹å•çº¿ç¨‹é¡ºåºç¨‹åºçš„ç†è§£:
    * çŠ¶æ€è¿ç§»åŸå­æ€§çš„å‡è®¾: <span style="color:blue;">å…±äº«å†…å­˜</span>æ¨ç¿»äº† â€œåŸå­æ€§â€ å‡è®¾
        - ä»»ä½•æ—¶å€™ï¼Œload è¯»åˆ°çš„å€¼éƒ½å¯èƒ½æ˜¯åˆ«çš„çº¿ç¨‹å†™å…¥çš„
        - æˆ‘ä»¬ä¹ ä»¥ä¸ºå¸¸çš„ç®€åŒ–ä¼šæ¼æ‰å¹¶å‘ç¨‹åºå¯èƒ½çš„è¡Œä¸º
    * ç¨‹åºé¡ºåºæ‰§è¡Œçš„å‡è®¾: ç¼–è¯‘å™¨ä¼šè¯•å›¾ä¼˜åŒ–çŠ¶æ€è¿ç§»ï¼Œæ”¹å˜æ‰§è¡Œæµ
    * å­˜åœ¨å…¨å±€æŒ‡ä»¤æ‰§è¡Œé¡ºåºçš„å‡è®¾: ä¸åŒå¤„ç†å™¨å¯èƒ½çœ‹åˆ°ä¸åŒçš„å…±äº«å†…å­˜, â€œä¸€ä¸ªå…±äº«å†…å­˜â€ åªæ˜¯ä¸ªç®€åŒ–çš„å¹»è§‰ã€‚ç”±äºåŠ¨æ€æŒ‡ä»¤è°ƒåº¦å’Œç¼“å­˜çš„å…±åŒä½œç”¨ï¼Œå®é™…ç¨‹åºçš„è¿è¡Œç»“æœæ›´å¯èƒ½è¶…å‡ºæˆ‘ä»¬çš„é¢„æœŸã€‚

6. çŠ¶æ€è¿ç§»åŸå­æ€§çš„å‡è®¾: alipay.c
    ```C
    #include "thread.h"

    unsigned long balance = 100;

    void Alipay_withdraw(int amt) {
        if (balance >= amt) {
            // Bugs may only manifest on specific timings. Sometimes
            // we reproduce bugs by inserting sleep()s.
            usleep(1); // å¼•å‘sys_sched()

            balance -= amt;
        }
    }

    void T_alipay() {
        Alipay_withdraw(100);
    }

    int main() {
        create(T_alipay);
        create(T_alipay);
        join();
        printf("balance = %lu\n", balance);
    }
    ```

    åœ¨usleep(1)çš„æƒ…å†µä¸‹è¾“å‡ºæ˜¯`balance = 18446744073709551516`ï¼Œä¸¤ä¸ªçº¿ç¨‹åŒæ—¶æ»¡è¶³`balance >= amt`ï¼Œç›¸å½“äºå‡äº†ä¸¤æ¬¡100ã€‚

7. ä»¥ä¸‹ä»£ç  sum çš„æœ€å°å€¼æ˜¯2çš„æƒ…å†µï¼šè¯¥çº¿ç¨‹æ‰§è¡Œåˆ°æœ€åä¸€ä¸ªforå¾ªç¯æ—¶ï¼Œloadåˆ°çš„sumä¸º1ï¼ˆæ³¨æ„ä¸å¯èƒ½loadåˆ°sumä¸º0ï¼Œå› ä¸ºå¯¹äºæœ¬çº¿ç¨‹è€Œè¨€å·²ç»æ‰§è¡Œè¿‡ä¸¤ä¸ªforå¾ªç¯äº†ï¼Œå¦‚æœæ˜¯loadæœ¬çº¿ç¨‹çš„sumåº”å½“æ˜¯2ï¼Œä¸€å®šæ˜¯loadåˆ«çš„çº¿ç¨‹æ”¹å†™åçš„sumã€‚åˆ«çš„çº¿ç¨‹ä¸€å®šè¦è‡³å°‘æ‰§è¡Œè¿‡ä¸€æ¬¡load-storeæŠŠsumå†™è¿›å»ï¼Œæ‰€ä»¥æ­¤æ—¶åˆ«çš„çº¿ç¨‹é‡Œsumæœ€å°ä¸º1ï¼‰ï¼Œç„¶åæ¥ç€å…¶ä»–çº¿ç¨‹éƒ½æ‰§è¡Œå®Œæ‰€æœ‰å¾ªç¯ç»“æŸäº†ã€‚è¯¥çº¿ç¨‹ç»§ç»­æ‰§è¡Œå®Œå‰©ä¸‹çš„`t += 1; store(sum, t);`å¯¼è‡´æœ€åsumä¸º2ã€‚
    ```C
    // åˆå§‹æ—¶ sum = 0; å‡è®¾å•è¡Œè¯­å¥çš„æ‰§è¡Œæ˜¯åŸå­çš„
    // å¹¶å‘æ‰§è¡Œä¸‰ä¸ª T_sumï¼Œsum çš„æœ€å°å€¼æ˜¯å¤šå°‘ï¼Ÿâ†’ æ˜¯2
    void T_sum() {
        for (int i = 0; i < 3; i++) {
            int t = load(sum);
            t += 1;
            store(sum, t);
        }
    }
    ```

8. sum.cï¼š
    ```C
    #include "thread.h"

    #define N 100000000

    long sum = 0;

    void T_sum() {
        for (int i = 0; i < N; i++) {
            sum++;

            // Won't work even if we force a single-instruction
            // increment.

            // asm volatile(
            //     "incq %0" : "+m"(sum)
            // );
        }
    }

    int main() {
        create(T_sum);
        create(T_sum);

        join();

        printf("sum = %ld\n", sum);
        printf("2*n = %ld\n", 2L * N);
    }
    ```

    ä¸åŒçš„ç¼–è¯‘ä¼˜åŒ–è¾“å‡ºä¸ä¸€æ ·ï¼š

    * -O0è¾“å‡º`sum = 119137703 2*n = 200000000`

        ```bash
        00000000000013d9 <T_sum>:
            13d9:       f3 0f 1e fa             endbr64 
            13dd:       55                      push   %rbp
            13de:       48 89 e5                mov    %rsp,%rbp
            13e1:       c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)
            13e8:       eb 16                   jmp    1400 <T_sum+0x27>
            13ea:       48 8b 05 4f 2c 00 00    mov    0x2c4f(%rip),%rax        # 4040 <sum>
            13f1:       48 83 c0 01             add    $0x1,%rax
            13f5:       48 89 05 44 2c 00 00    mov    %rax,0x2c44(%rip)        # 4040 <sum>
            13fc:       83 45 fc 01             addl   $0x1,-0x4(%rbp)
            1400:       81 7d fc ff e0 f5 05    cmpl   $0x5f5e0ff,-0x4(%rbp)
            1407:       7e e1                   jle    13ea <T_sum+0x11>
            1409:       90                      nop
            140a:       90                      nop
            140b:       5d                      pop    %rbp
            140c:       c3                      ret
        ```

    * -O1è¾“å‡º`sum = 100000000 2*n = 200000000`

        ```bash
        00000000000011e3 <T_sum>:
            11e3:       f3 0f 1e fa             endbr64 
            11e7:       48 8b 15 52 2e 00 00    mov    0x2e52(%rip),%rdx        # 4040 <sum>
            11ee:       48 8d 42 01             lea    0x1(%rdx),%rax
            11f2:       48 81 c2 01 e1 f5 05    add    $0x5f5e101,%rdx
            11f9:       48 89 c1                mov    %rax,%rcx
            11fc:       48 83 c0 01             add    $0x1,%rax
            1200:       48 39 d0                cmp    %rdx,%rax
            1203:       75 f4                   jne    11f9 <T_sum+0x16>
            1205:       48 89 0d 34 2e 00 00    mov    %rcx,0x2e34(%rip)        # 4040 <sum>
            120c:       c3                      ret
        ```

    * -O2è¾“å‡º`sum = 200000000 2*n = 200000000`ï¼Œå³ä¾¿å¦‚æ­¤ï¼Œç›´æ¥å˜æˆä¸€æ¡addqæŒ‡ä»¤ï¼Œsumçš„è¾“å‡ºä»æ—§ä¸ä¸€å®šæ­£ç¡®ï¼å¦‚åŒalipayçš„ä¾‹å­ä¸€æ ·å¦‚æœåŠ å…¥usleep(1)è¿˜æ˜¯å¯ä»¥çœ‹åˆ°æ¯æ¬¡ç»“æœéƒ½ä¸ä¸€æ ·ã€‚

        ```bash
        0000000000001260 <T_sum>:
            1260:       f3 0f 1e fa             endbr64 
            1264:       48 81 05 d1 2d 00 00    addq   $0x5f5e100,0x2dd1(%rip)        # 4040 <sum>
            126b:       00 e1 f5 05 
            126f:       c3                      ret
        ```

9. memory model:
    * ä½ ä»¥ä¸ºçš„å…±äº«å†…å­˜:
    ![alt text](../img/image-0.png)
    * å®é™…çš„å…±äº«å†…å­˜: æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±çš„å†…å­˜å‰¯æœ¬ï¼Œä»–ä»¬ä¹‹é—´é€šè¿‡æŸç§æ–¹å¼åŒæ­¥
    ![alt text](../img/image-1.png)
    * x86ï¼šå¸‚é¢ â€œæœ€å¼ºâ€ å†…å­˜æ¨¡å‹ (ç±»æ¯” ARM/RISC-V)
    ![alt text](../img/image-2.png)

    mem_model.c:
    ```c
    #include <thread.h>
    #include <stdatomic.h>

    int x = 0, y = 0;
    atomic_int flag;

    #define F1  1
    #define F2  2

    #define FLAG \
        atomic_load(&flag)
    #define FLAG_XOR(val) \
        atomic_fetch_xor(&flag, val)
    #define WAIT_FOR(cond) \
        while (!(cond))    \
            ;

    __attribute__((noinline))
    void write_x_read_y() {
        int y_val;

        asm volatile(
            "movl $1, %0;" // x = 1
            "movl %2, %1;" // y_val = y
            : "=m"(x), "=r"(y_val)
            : "m"(y)
        );

        printf("%d ", y_val);
    }

    __attribute__((noinline))
    void write_y_read_x() {
        int x_val;

        asm volatile(
            "movl $1, %0;" // y = 1
            "movl %2, %1;" // x_val = x
            : "=m"(y), "=r"(x_val)
            : "m"(x)
        );

        printf("%d ", x_val);
    }

    void T_1(int id) {
        while (1) {
            // Wait until F1 is raised.
            WAIT_FOR((FLAG & F1));

            write_x_read_y();

            // Put F1 down.
            FLAG_XOR(F1);
        }
    }

    void T_2() {
        while (1) {
            // Wait until F2 is raised.
            WAIT_FOR((FLAG & F2));

            write_y_read_x();

            // Put F2 down.
            FLAG_XOR(F2);
        }
    }

    void T_flag() {
        while (1) {
            x = 0;
            y = 0;
            __sync_synchronize(); // full barrier
            usleep(1);            // + delay

            // Now, x = 0, y = 0, and flag = 0.
            // T_1 and T_2 should be waiting for their flags.
            assert(FLAG == 0);

            // flag = F1 | F2; Both flags are raised.
            FLAG_XOR(F1 | F2);

            // T1 and T2 are ready to go...
            // They will eventually put F1 and F2 down.
            WAIT_FOR(FLAG == 0);

            printf("\n");
            fflush(stdout);
        }
    }

    int main() {
        // All infinite loops
        create(T_1);
        create(T_2);
        create(T_flag);
    }
    ```

    `./mem-model  | head -n 10000 | sort | uniq -c`è¾“å‡ºï¼š
    ```bash
    7978 0 0 
    1783 0 1 
     237 1 0 
       2 1 1
    ```

    | T_1 | T_2 |
    | ---- | ---- |
    | â‘  x = 1 <br> â‘¡ load y | â‘¢ y = 1 <br> â‘£ load x|

    å‡ºç°0 0çš„åŸå› æ˜¯çœŸæ­£çš„memory modelå’Œæˆ‘ä»¬æƒ³è±¡çš„å¹¶ä¸ä¸€æ ·ã€‚å¤„ç†å™¨ä¹Ÿæ˜¯ç¼–è¯‘å™¨:

    * é¢„å–çŠ¶æ€æœºæ‰§è¡Œçš„<span style="color:blue;">è‹¥å¹²æ­¥</span>ï¼Œç„¶ååƒç¼–è¯‘å™¨ä¸€æ ·ä¼˜åŒ–
    * Load(x); Store(y)
    * x â‰  y â†’ ä¸¤æ¡æŒ‡ä»¤æ‰§è¡Œçš„å…ˆåé¡ºåºå°±æ— æ‰€è°“
    * Load cache miss â†’ store å¯ä»¥ç›´æ¥æ‰§è¡Œ


## Lecture 6 å¹¶å‘æ§åˆ¶ï¼šäº’æ–¥ (1)
!!! abstract "Take-away Messages"

    å¹¶å‘ç¼–ç¨‹ â€œå¾ˆéš¾â€ï¼šæƒ³è¦å®Œå…¨ç†è§£å¹¶å‘ç¨‹åºçš„è¡Œä¸ºï¼Œæ˜¯éå¸¸å›°éš¾çš„â€”â€”æˆ‘ä»¬ç”šè‡³å¯ä»¥åˆ©ç”¨ä¸€ä¸ª â€œä¸‡èƒ½â€ çš„è°ƒåº¦å™¨å»å¸®åŠ©æˆ‘ä»¬æ±‚è§£ NP-å®Œå…¨é—®é¢˜ã€‚å› æ­¤ï¼Œäººç±»åº”å¯¹è¿™ç§å¤æ‚æ€§çš„æ–¹æ³•å°±æ˜¯é€€å›åˆ°ä¸å¹¶å‘ã€‚é€šè¿‡äº’æ–¥å®ç° stop/resume the worldï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿å¹¶å‘ç¨‹åºçš„æ‰§è¡Œå˜å¾—æ›´å®¹æ˜“ç†è§£â€”â€”è€Œåªè¦ç¨‹åºä¸­ â€œèƒ½å¹¶è¡Œâ€ çš„éƒ¨åˆ†è¶³å¤Ÿå¤šï¼Œä¸²è¡ŒåŒ–ä¸€å°éƒ¨åˆ†ä¹Ÿå¹¶ä¸ä¼šå¯¹æ€§èƒ½å¸¦æ¥è‡´å‘½çš„å½±å“ã€‚

1. å®ç°äº’æ–¥ï¼šStop the Worldã€‚èƒ½å¦ä½¿å½“å‰ç¨‹åºçŠ¶æ€æœºç‹¬å è®¡ç®—æœºç³»ç»Ÿï¼Ÿ
    * å•å¤„ç†å™¨ç³»ç»Ÿä¸­ â€œå…¶ä»–ä»»ä½•äº‹â€ï¼šä»…æœ‰ä¸­æ–­ï¼Œå› æ­¤å…³ä¸­æ–­å³å¯ã€‚ä¾‹å¦‚x86ä¸­`cli` æ¸…é™¤ `eflags` ä¸­çš„ `IF` bitå³å¯å…³ä¸­æ–­ã€‚æ³¨æ„ï¼šåªæœ‰æ“ä½œç³»ç»Ÿå†…æ ¸å¯ä»¥å…³ä¸­æ–­ï¼Œç”¨æˆ·ç¨‹åºå…³ä¸­æ–­ä¼šSegmentation faultã€‚
    * ä½†æ˜¯æ³¨æ„å¤„ç†å™¨æœ‰ä¸å¯å±è”½ä¸­æ–­ NMI (Non-Maskable Interrupts)ï¼Œå¯ä»¥åˆ©ç”¨ NMI å®ç°é”™è¯¯ç›‘æ§
        - è®¾ç½®ç¡¬ä»¶å®šæ—¶è§¦å‘
        - æ“ä½œç³»ç»Ÿå®šæ—¶å¤ä½å®šæ—¶å™¨
        - è§¦å‘ timeoutï¼Œæ‰§è¡Œ NMI å¤„ç†ç¨‹åºï¼Œä¾‹å¦‚é‡å¯è®¡ç®—æœº
    * è€Œä¸”å•å¤„ç†å™¨ç³»ç»Ÿå…³ä¸­æ–­å¯ä»¥ï¼Œå¤šå¤„ç†å™¨ç³»ç»Ÿä¸è¡Œ
        - æ¯ä¸ªå¤„ç†å™¨æœ‰ç‹¬ç«‹çš„å¯„å­˜å™¨ç»„
        - ä¸­æ–­æ˜¯æ¯ä¸ªå¤„ç†å™¨å†…éƒ¨çŠ¶æ€
2. Peterson ç®—æ³•ï¼šå•æ‰€æ˜¯ä¸´ç•Œèµ„æºï¼Œéœ€è¦<span style="color:blue;">äº’æ–¥ä½¿ç”¨</span>ã€‚ï¼ˆ**æ³¨æ„Peterson ç®—æ³•ä»…ä»…èƒ½è§£å†³ä¸¤ä¸ªçº¿ç¨‹äº’æ–¥çš„æƒ…å†µ**ï¼‰
    * è‹¥å¸Œæœ›è¿›å…¥å•æ‰€ï¼ŒæŒ‰é¡ºåºæ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š
        1. ä¸¾èµ·è‡ªå·±çš„æ——å­ (store)
        2. æŠŠå†™æœ‰å¯¹æ–¹åå­—çš„å­—æ¡è´´åœ¨å•æ‰€é—¨ä¸Š (store; è¦†ç›–)ï¼ˆçœ‹èµ·æ¥æ˜¯è°¦è®©ï¼Œå®é™…ä¸Šæ˜¯åˆ©å·±ï¼‰
    * ç„¶åè¿›å…¥æŒç»­çš„è§‚å¯Ÿæ¨¡å¼ï¼š
        1. è§‚å¯Ÿå¯¹æ–¹æ˜¯å¦ä¸¾æ—— (load)
        2. è§‚å¯Ÿå•æ‰€é—¨ä¸Šçš„åå­— (load)
            - <span style="color:blue;">å¯¹æ–¹ä¸ä¸¾æ——æˆ–å•æ‰€é—¨ä¸Šçš„åå­—æ˜¯è‡ªå·±ï¼Œè¿›å…¥å•æ‰€ï¼Œå¦åˆ™ç»§ç»­è§‚å¯Ÿ</span>
    * å‡ºå•æ‰€åï¼Œæ”¾ä¸‹è‡ªå·±çš„æ——å­
        - <span style="color:blue;">ä¸ç”¨ç®¡é—¨ä¸Šçš„å­—æ¡</span>
3. Peterson ç®—æ³•è¿›å…¥ä¸´ç•ŒåŒºçš„æƒ…å†µ
    * å¦‚æœåªæœ‰ä¸€ä¸ªäººä¸¾æ——ï¼Œä»–å°±å¯ä»¥ç›´æ¥è¿›å…¥
    * å¦‚æœä¸¤ä¸ªäººåŒæ—¶ä¸¾æ——ï¼Œç”±å•æ‰€é—¨ä¸Šçš„æ ‡ç­¾å†³å®šè°è¿›
        - æ‰‹å¿«æœ‰(è¢«å¦ä¸€ä¸ªäººçš„æ ‡ç­¾è¦†ç›–)ã€æ‰‹æ…¢æ— 
    
    ä»£ç å®ç°ï¼šï¼ˆä»…ä¸ºæ¨¡å‹ç®—æ³•ï¼Œå¹¶éæ­£ç¡®çš„å®ç°ï¼Œå› ä¸ºæ¨¡å‹çš„å‡è®¾ï¼šAtomic load & storeï¼Œä½†è¿™ä¸ªå‡è®¾åœ¨ç°ä»£å¤šå¤„ç†å™¨ä¸Šå¹¶ä¸æˆç«‹ï¼Œé™¤éä½¿ç”¨å†…å­˜å±éšœ Memory Barrier `__sync_synchronize()`(= Compiler Barrier + x86: `mfence`)ï¼‰
    ```C
    a = 1;    // ä¸¾èµ·è‡ªå·±çš„æ——å­
    turn = B; // è´´ä¸Šå¯¹æ–¹çš„åå­—
    do {      // è¿›å…¥æŒç»­è§‚å¯Ÿæ¨¡å¼
    } while (b && turn == B); // å¯¹æ–¹ä¸¾æ——ä¸”é—¨ä¸Šæ˜¯å¯¹æ–¹çš„çš„åå­—

    // ä¸´ç•ŒåŒº

    a = 0;    // æ”¾ä¸‹è‡ªå·±çš„æ——å­

    /* b åŒç† =================== */
    b = 1;
    turn = A;
    do {
    } while (a && turn == A);

    // ä¸´ç•ŒåŒº

    b = 0;
    ```

4. Peterson ç®—æ³•æ¢ç©¶ï¼Œå¦‚æœæœ‰ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶è¿›å…¥ä¸´ç•ŒåŒºï¼Œä¼šæœ‰csåŒæ—¶ä¸º1/2çš„æƒ…å†µã€‚é€šè¿‡mosaic model checker `mosaic -c peterson.py | grep \"cs\" | sort | uniq`çš„è¾“å‡ºå¯ä»¥çœ‹åˆ°æ²¡æœ‰åŒæ—¶ä¸º1/2çš„æƒ…å†µã€‚

    ```bash
    "cs": ""
    "cs": "â¶"
    "cs": "â·"
    ```

    ```python
    def T1():
        while True:
            heap.x = 'ğŸ´'    # T1çš„æ——å­
            sys_sched()
            heap.turn = 'â·'   # å•æ‰€é—¨ä¸Šçš„æ ‡ç­¾
            sys_sched()
            while True:
                t = heap.turn
                sys_sched()
                y = heap.y != ''
                sys_sched()
                if not y or t == 'â¶':
                    break
            sys_sched()
            heap.cs += 'â¶'   # è¿›å•æ‰€åå†™csä¸º1
            sys_sched()
            heap.cs = heap.cs.replace('â¶', '') # å‡ºå•æ‰€ååˆ é™¤cs
            sys_sched()
            heap.x = ''
            sys_sched()
    
    def T2():
        while True:
            heap.y = 'ğŸ'
            sys_sched()
            heap.turn = 'â¶'
            sys_sched()
            while True:
                t = heap.turn
                sys_sched()
                x = heap.x
                sys_sched()
                if not x or t == 'â·':
                    break
                sys_sched()
            sys_sched()
            heap.cs += 'â·'
            sys_sched()
            heap.cs = heap.cs.replace('â·', '')
            sys_sched()
            heap.y = ''
            sys_sched()

    def main():
        heap.x = ''
        heap.y = ''
        heap.turn = ''
        heap.cs = ''
        sys_spawn(T1)
        sys_spawn(T2)
    ```

5. çœŸæ­£æ­£ç¡®çš„pertersonç®—æ³•å®ç°ï¼š

    ```C
    #include <thread.h>
    #include <stdatomic.h>

    #define A 1
    #define B 2

    // The caveat is: no matter how many times we run this test
    // without seeing it fail, we cannot be certain that we have
    // inserted sufficient barriers. Understanding the correctness
    // of this code is far beyond the scope of this course.
    // 
    #define BARRIER __sync_synchronize()
    //
    // Peterson's algorithm is wrong without proper barriers:
    //
    // #define BARRIER

    atomic_int inside;
    long count;

    void critical_section() {
        // We expect this thread executing code exclusively,
        // if the critical section is correctly implemented.
    
        assert(
            // assert(inside == 0);
            // inside++
            atomic_fetch_add(&inside, +1) == 0
        );

        // On some machines, printing a character will hide
        // the bug!
        // putchar('.');

        assert(
            // assert(inside == 1);
            // inside--
            atomic_fetch_add(&inside, -1) == 1
        );
    }

    int volatile a = 0, b = 0, turn;

    void T_A() {
        while (1) {
            a = 1;                    BARRIER;
            turn = B;                 BARRIER; // <- this is critcal for x86
            while (1) {
                if (!b) break;        BARRIER;
                if (turn != B) break; BARRIER;
            }

            // T_B can't execute critical_section now.
            critical_section();

            a = 0;                    BARRIER;
        }
    }

    void T_B() {
        while (1) {
            b = 1;                    BARRIER;
            turn = A;                 BARRIER;
            while (1) {
                if (!a) break;        BARRIER;
                if (turn != A) break; BARRIER;
            }

            // T_A can't execute critical_section now.
            critical_section();

            b = 0;                    BARRIER;
        }
    }

    int main() {
        create(T_A);
        create(T_B);
    }
    ```

6. åœ¨å¤šå¤„ç†å™¨ä¸Šå®ç°äº’æ–¥: <span style="color:blue;">**è½¯ä»¶ä¸å¤Ÿï¼Œç¡¬ä»¶æ¥å‡‘**</span>, ç¡¬ä»¶æä¾›åŸå­æŒ‡ä»¤ - å‰ç¼€`lock`
    * åŸå­æŒ‡ä»¤ï¼šä¸€å°æ®µæ—¶é—´çš„ â€œStop the Worldâ€ æ‰§è¡Œ
    * ä¸å¯æ‰“æ–­çš„ load + è®¡ç®— + store
        - x86: Bus Lock; RISC-V: LR/SC (æ¥è‡ª MIPS) + atomic
    * åœ¨å¤šå¤„ç†å™¨ä¸Šå®ç°æ­£ç¡®çš„ 1 + 1ï¼š`asm volatile("lock addq $1, %0" : "+m"(sum));` or `asm volatile("lock incq %0" : "+m"(sum));`

7. é€šè¿‡ç¡¬ä»¶åŸå­æŒ‡ä»¤`atomic_xchg` or `lock cmpxchgl`å®ç°è‡ªæ—‹é”ï¼š

    ```C
    int status = âœ…; // æ­¤æ—¶å•æ‰€é—¨æ˜¯âœ…ï¼Œæˆ‘ä»¬æƒ³ç”¨âŒå»æ¢å®ƒï¼Œgotå¾—åˆ°âœ…æ˜¯æƒ³è¦çš„çŠ¶æ€ï¼Œå¦åˆ™å°±é‡æ–°å°è¯•

    void lock() {
    retry:
        int got = atomic_xchg(&status, âŒ);
        if (got != âœ…) {
            goto retry;
        }
    }

    void unlock() {
        atomic_xchg(&status, âœ…);
    }
    ```

    sum-locked.cå¾—åˆ°æ­£ç¡®çš„æ±‚å’Œsum:
    ```C
    #include <thread.h>

    // We create 3 threads in this example.
    #define T        3
    #define N  1000000

    #define LOCKED   1
    #define UNLOCKED 0

    int status = UNLOCKED;

    void lock() {
        int expected;
        do {
            // Try compare status with expected.
            // If the comparison succeeded, perform
            // an exchange.
            expected = UNLOCKED;
            asm volatile (
                "lock cmpxchgl %2, %1"
                : "+a" (expected) // Value for comparison.
                                // x86 uses eax/rax.
                : "m" (status),   // Memory location.
                "r" (LOCKED)    // Value to be written if
                                // status == expected
                : "memory", "cc"
            );
        } while (expected != UNLOCKED);
    }

    void unlock() {
        // To be safer:
        //
        // asm volatile (
        //     "movl %1, %0"
        //     : "=m" (status)
        //     : "r" (UNLOCKED)
        //     : "memory"
        // );

        // But actually we can do this:
        asm volatile("" ::: "memory");
        status = UNLOCKED;
    }


    long volatile sum = 0;

    void T_sum(int tid) {
        for (int i = 0; i < N; i++) {
            lock();

            // This critical section is even longer; but
            // it should be safe--the world is stopped.
            // We also marked sum as volatile to make
            // sure it is loaded and stored in each
            // loop iteration.
            for (int _ = 0; _ < 10; _++) {
                sum++;
            }

            unlock();
        }

        printf("Thread %d: sum = %ld\n", tid, sum);
    }

    int main() {
        for (int i = 0; i < T; i++) {
            create(T_sum);
        }

        join();

        printf("sum  = %ld\n", sum);
        printf("%d*n = %ld\n", T * 10, T * 10L * N);
    }
    ```

    ç„¶è€Œï¼Œåœ¨ç”¨æˆ·æ€å®ç°è‡ªæ—‹é”æœ‰ä¸ªé—®é¢˜ï¼šä¸€ä¸ªæ ¸å ç”¨äº†è¿™ä¸ªlockåï¼Œå‡è®¾ä¸­æ–­æ¥äº†åˆ‡æ¢åˆ°äº†å…¶ä»–æ ¸å¿ƒä¸Šçš„çº¿ç¨‹ï¼Œä¹Ÿæƒ³æ‹¥æœ‰è¿™æŠŠlockï¼Œç”±äºä¹‹å‰çš„lockæ²¡æœ‰è¢«é‡Šæ”¾ï¼Œå…¶ä»–æ ¸å¿ƒä¸Šçš„çº¿ç¨‹å°±ä¼šä¸€ç›´è‡ªæ—‹ç­‰å¾…ï¼Œæµªè´¹èµ„æºã€‚å¦ä¸€ç§æƒ…å†µæ˜¯ï¼Œå‡è®¾ä¸­æ–­åˆ°æ¥ï¼Œä¸­æ–­å¤„ç†ç¨‹åºæœ¬èº«ä¹Ÿæƒ³è®¿é—®è¿™ä¸ªlockä¿æŠ¤çš„å†…å®¹ï¼Œç„¶è€Œå› ä¸ºlockæ²¡æœ‰è¢«é‡Šæ”¾ï¼Œä¸­æ–­å¤„ç†ç¨‹åºä¼šä¸€ç›´ç­‰å¾…ï¼Œé™·å…¥æ­»é”ã€‚å®é™…ä¸Šæ“ä½œç³»ç»Ÿå†…æ ¸æ€çš„è‡ªæ—‹é”å®ç°æ—¶ä¼šå…³ä¸­æ–­ã€‚

8. ä¸Šè¿°ä»£ç é‡Œ`unlock()`é‡Œéœ€è¦compiler barrier`asm volatile("" ::: "memory");`çš„åŸå› ï¼š
    * ä»å¾ªç¯ 10 æ¬¡æ”¹æˆå¾ªç¯ 1 æ¬¡ï¼Œsum é”™äº†ï¼
    * é˜²æ­¢ç¼–è¯‘å™¨åšä¼˜åŒ–ï¼Œå¦åˆ™ç¼–è¯‘å™¨åœ¨ç¼–è¯‘çš„æ—¶å€™ï¼Œç›´æ¥æŠŠ`unlock()`ä»£ç å¤åˆ¶åˆ°åˆ°sum++ä¹‹åï¼Œå¯èƒ½çš„ä¼˜åŒ–æ˜¯ï¼Œå…ˆåšé‡Šæ”¾é”ï¼Œå†åšsum++ï¼Œå°±ä¼šæœ‰é—®é¢˜ã€‚

    é”™è¯¯ä»£ç ï¼š
    ```C
    void unlock() {
        status = UNLOCKED;
    }
    ``` 
    ç¼–è¯‘åï¼š
    ```asm
    movq    sum(%rip), %rax
    andl    $0, status(%rip)
    addq    $1, %rax
    movq    %rax, sum(%rip)
    ```

    æ­£ç¡®ä»£ç ï¼š
    ```C
    void unlock() {
        asm volatile("" ::: "memory");
        status = UNLOCKED;
    }
    ``` 
    ç¼–è¯‘åï¼š
    ```asm
    movq    sum(%rip), %rax
    addq    $1, %rax
    movq    %rax, sum(%rip)
    andl    $0, status(%rip)
    ```

    [Compiler Explorer](https://godbolt.org/z/r1h1bMe7h)

## Lecture 7 å¹¶å‘æ§åˆ¶ï¼šäº’æ–¥ (2)
!!! abstract "Take-away Messages"

    â€œäº’æ–¥â€ çœ‹èµ·æ¥ç®€å•ï¼Œç”¨è‡ªæ—‹é”å°±èƒ½å®ç°ï¼Œä½†å¦‚æœåœ¨å®é™…çš„åœºæ™¯ (ä¾‹å¦‚å¯è¢«ä¸­æ–­çš„æ“ä½œç³»ç»Ÿå†…æ ¸ã€ä¸å¸Œæœ›æµªè´¹ CPU èµ„æºçš„åº”ç”¨ç¨‹åºç­‰)ï¼Œå®é™…çš„äº’æ–¥å®ç°å°±ä¸å†ç®€å•ã€‚æˆ‘ä»¬åœ¨ xv6 çš„è‡ªæ—‹é”å®ç°ä¸­ï¼Œå‘ç°äº†è®¸å¤š â€œé˜²å¾¡æ€§ç¼–ç¨‹â€ çš„ä¾‹å­ï¼Œå…ˆå‡è®¾ç¨‹åºå‘˜å¯èƒ½ä¼šçŠ¯ä¸€åˆ‡å¯èƒ½çš„é”™è¯¯â€”â€”ç„¶åä¸æ–­åŠ ä»¥æ£€æŸ¥ã€‚è€Œ â€œæ­£ç¡®æ€§å®Œå…¨ç”±å¼€å‘è€…è´Ÿè´£â€ çš„æ—¶ä»£å°†è¦è¿‡å»ï¼Œæˆ‘ä»¬å°†ä¼šåœ¨æœªæ¥è¶Šæ¥è¶Šå¤šåœ°çœ‹åˆ°ç¼–ç¨‹è¯­è¨€ä¸­çš„æœºåˆ¶ï¼Œå¸®åŠ©æˆ‘ä»¬å†™å‡ºæ­£ç¡®çš„ä»£ç ã€‚

1. æ“ä½œç³»ç»Ÿå†…æ ¸ä¸­çš„è‡ªæ—‹é”å®ç°ï¼šåˆ©ç”¨è®¡ç®—æœºç³»ç»ŸçŠ¶æ€æœºçš„è§†è§’ï¼Œæ“ä½œç³»ç»Ÿå†…æ ¸ä¸­çš„è‡ªæ—‹é”ä¸ä»…è¦å®ç°å¤„ç†å™¨é—´çš„äº’æ–¥ï¼Œè¿˜è¦æ­£ç¡®å¤„ç†ä¸­æ–­ï¼Œä»¥åŠé”çš„åµŒå¥—ã€‚å½“å¤šä¸ªéœ€æ±‚å åŠ æ—¶ï¼Œä½œå‡ºä¸€ä¸ªæ­£ç¡®çš„å®ç°å°±ä¸å†æ˜¾ç„¶ã€‚

    ```C
    #include <am.h>
    #include <spinlock.h>

    // This is a ported version of spin-lock
    // from xv6-riscv to AbstractMachine:
    // https://github.com/mit-pdos/xv6-riscv

    void push_off();
    void pop_off();
    bool holding(spinlock_t *lk);

    void spin_lock(spinlock_t *lk) {
        // Disable interrupts to avoid deadlock.
        push_off();

        // This is a deadlock.
        if (holding(lk)) {
            panic("acquire %s", lk->name);
        }

        // This our main body of spin lock.
        int got;
        do {
            got = atomic_xchg(&lk->status, LOCKED);
        } while (got != UNLOCKED);

        lk->cpu = mycpu;
    }

    void spin_unlock(spinlock_t *lk) {
        if (!holding(lk)) {
            panic("release %s", lk->name);
        }

        lk->cpu = NULL;
        atomic_xchg(&lk->status, UNLOCKED);

        pop_off();
    }

    // Check whether this cpu is holding the lock.
    // Interrupts must be off.
    bool holding(spinlock_t *lk) {
        return (
            lk->status == LOCKED &&
            lk->cpu == &cpus[cpu_current()]
        );
    }

    // push_off/pop_off are like intr_off()/intr_on()
    // except that they are matched:
    // it takes two pop_off()s to undo two push_off()s.
    // Also, if interrupts are initially off, then
    // push_off, pop_off leaves them off.
    void push_off(void) {
        int old = ienabled();
        struct cpu *c = mycpu;

        iset(false);
        if (c->noff == 0) {
            c->intena = old;
        }
        c->noff += 1;
    }

    void pop_off(void) {
        struct cpu *c = mycpu;

        // Never enable interrupt when holding a lock.
        if (ienabled()) {
            panic("pop_off - interruptible");
        }
        
        if (c->noff < 1) {
            panic("pop_off");
        }

        c->noff -= 1;
        if (c->noff == 0 && c->intena) {
            iset(true);
        }
    }
    ```

    ```bash
    ç›´è§‚æƒ³æ³•:
    å…³æœ¬CPUçš„ä¸­æ–­
        |
      lock
        |
      sum++
        |
      unlock
        |
    å¼€æœ¬CPUçš„ä¸­æ–­ (âŒ, å¦‚æœåœ¨æƒ³è¿›ä¸´ç•ŒåŒºåšsum++ä¹‹å‰æœ¬èº«ä¸­æ–­å°±æ˜¯å…³çš„å‘¢ï¼Ÿè¿™æ ·ç»“æŸå²‚ä¸æ˜¯è¯¯å¼€äº†ä¸­æ–­ï¼Œå¹¶æ²¡æœ‰æ¢å¤åˆ°ä¹‹å‰çš„çŠ¶æ€)

    æ­£ç¡®åšæ³•:
    å…³æœ¬CPUçš„ä¸­æ–­
        |
      lock
        |
      sum++
        |
      unlock
        |
    æ¢å¤æœ¬CPUçš„ä¸­æ–­æƒ…å†µ (å·§å¦™åˆ©ç”¨c->noffæ¥è®°å½•æ¬¡æ•°, å¹¶ä¸”åªæœ‰ä¸€å¼€å§‹å°±æ˜¯å¼€ä¸­æ–­çš„æ—¶å€™: c->intena, æ‰å¼€ä¸­æ–­)
    ```

2. è‡ªæ—‹çš„åæœ: åŒä¸€ä»½è®¡ç®—ä»»åŠ¡ï¼Œæ—¶é—´ (CPU cycles) å’Œç©ºé—´ (å†…å­˜å ç”¨) ä¼šéšå¤„ç†å™¨æ•°é‡çš„å¢é•¿è€Œå˜åŒ–ã€‚ç”¨è‡ªæ—‹é”å®ç° sum++: æ›´å¤šçš„å¤„ç†å™¨, æ›´å·®çš„æ€§èƒ½ï¼ˆå› ä¸ºå…¶ä»–cpuéƒ½åœ¨ç©ºè½¬ï¼Œcpuåˆ©ç”¨ç‡ä¸‹é™äº†ï¼‰ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè‡ªæ—‹é”çš„scalabilityå¾ˆå·®ï¼Œå¹¶ä¸æ˜¯çº¿æ€§å˜åŒ–çš„ã€‚

    ![alt text](../img/image-3.png){ width=50%, height=50% }

    ä¸€ä¸ªéå¸¸èªæ˜çš„æƒ³æ³•ï¼šRead-copy-update
    ```C
    Counter *c_current;

    int get() {
        // Read
        Counter *c = c_current;
        return c->sum;
    }

    void increment() {
        SPIN_LOCKED {
            // Copy
            Counter *c = alloc_counter();
            c->sum = c_current->sum + 1;
            smp_wmb(); // Memory barrier

            // Update
            c_current = c;
        }
    }
    ```

    åˆ©ç”¨æ“ä½œç³»ç»Ÿå†…æ ¸å¯¹è±¡å…·æœ‰ â€œread-mostlyâ€ çš„ç‰¹ç‚¹ï¼ˆä¹Ÿå°±æ˜¯è¯»å†™ä¸å¯¹ç§°ï¼Œä¿®æ”¹ä¸é¢‘ç¹ï¼Œä½†è¯»å´å¾ˆé¢‘ç¹ï¼‰ï¼Œå¯ä»¥åœ¨è¯»çš„æ—¶å€™ä¸ä¸Šé”ï¼Œåªæœ‰å†™çš„æ—¶å€™ä¸Šé”ï¼Œè€Œä¸”å†™çš„æ—¶å€™æ˜¯åœ¨è‡ªå·±çš„å‰¯æœ¬ä¸Šå†™ï¼Œç„¶åå†æŠŠæŒ‡é’ˆæŒ‡å‘è‡ªå·±çš„å‰¯æœ¬ã€‚è¿™æ ·åšç‰ºç‰²äº†è¯»å†™ä¸€è‡´æ€§ï¼Œæœ‰çš„çº¿ç¨‹ä¹Ÿè®¸ä¼šè¯»åˆ°æ—§çš„ç‰ˆæœ¬ï¼Œä½†æˆ‘ä»¬è®¤ä¸ºè¿™æ˜¯å¯ä»¥æ¥å—çš„ã€‚æ—§ç‰ˆæœ¬å¯¹è±¡ä¼šå­˜åœ¨ä¸€ä¸ª â€œgraceful periodâ€ï¼Œç›´åˆ°æŸä¸ªæ—¶åˆ»ï¼Œæ‰€æœ‰ CPU read éƒ½ä¼šè®¿é—®åˆ°æ–°ç‰ˆæœ¬ã€‚è¿™æ ·å¤§å¤šæ•°è¯»çš„æƒ…å†µæ²¡å¿…è¦ä½¿ç”¨è‡ªæ—‹é”ï¼Œå‡å°‘å…¶ä»– CPU ç©ºè½¬çš„æ—¶é—´ä»è€Œæé«˜ CPU åˆ©ç”¨ç‡ã€‚

    è¯»å†™ä¸å¯¹ç§°çš„ä¾‹å­ï¼šLinuxç”¨æˆ·å’Œç»„ä¿¡æ¯

    * æ— æ—¶ä¸åˆ»åœ¨æ£€æŸ¥ (Permission Denied)
    * ä½†å‡ ä¹ä»ä¸ä¿®æ”¹ç”¨æˆ·

3. åº”ç”¨ç¨‹åºä¸­çš„äº’æ–¥: åº”ç”¨ç¨‹åºå¦‚ä½•è¾ƒå¥½åœ°ä½¿ç”¨è‡ªæ—‹é”ï¼Ÿ
    * æ€§èƒ½é—®é¢˜ (1)ï¼šé™¤äº†è¿›å…¥ä¸´ç•ŒåŒºçš„çº¿ç¨‹ï¼Œå…¶ä»–å¤„ç†å™¨ä¸Šçš„çº¿ç¨‹éƒ½åœ¨ç©ºè½¬
        - äº‰æŠ¢é”çš„å¤„ç†å™¨è¶Šå¤šï¼Œåˆ©ç”¨ç‡è¶Šä½
        - å¦‚æœä¸´ç•ŒåŒºè¾ƒé•¿ï¼Œä¸å¦‚æŠŠå¤„ç†å™¨è®©ç»™å…¶ä»–çº¿ç¨‹
    * æ€§èƒ½é—®é¢˜ (2)ï¼šåº”ç”¨ç¨‹åºä¸èƒ½å…³ä¸­æ–­
        - æŒæœ‰è‡ªæ—‹é”çš„çº¿ç¨‹è¢«åˆ‡æ¢
        - å¯¼è‡´ 100% çš„èµ„æºæµªè´¹
        - (å¦‚æœåº”ç”¨ç¨‹åºèƒ½ â€œå‘Šè¯‰â€ æ“ä½œç³»ç»Ÿå°±å¥½äº†)
    
    è§£å†³ï¼šé€šè¿‡`syscall`æŠŠé”çš„å®ç°æ”¾åˆ°æ“ä½œç³»ç»Ÿé‡Œå°±å¥½å•¦

    * `syscall(SYSCALL_lock, &lk);`
        - è¯•å›¾è·å¾— `lk`ï¼Œä½†å¦‚æœå¤±è´¥ï¼Œå°±åˆ‡æ¢åˆ°å…¶ä»–çº¿ç¨‹
    * `syscall(SYSCALL_unlock, &lk);`
        - é‡Šæ”¾ `lk`ï¼Œå¦‚æœæœ‰ç­‰å¾…é”çš„çº¿ç¨‹å°±å”¤é†’

    ```C
    pthread_mutex_t lock;
    pthread_mutex_init(&lock, NULL);

    pthread_mutex_lock(&lock);
    pthread_mutex_unlock(&lock);
    ```

    ```bash
                       T1
                        |
                    syscall(acquire, lock)
                        |
    --------------- Enter OS kernel --------------- 
    |                                             |
    | OS spin lock locked                         |
    |                                             |
    |    try aquire lock:                         |
    |        if fail: mark as wait for the lock,  |
    |                 switch to other tasks       |
    |                                             |
    | OS spin lock released                       |
    --------------- Exit OS kernel ----------------

                       T2
                        |
                    syscall(release, lock)
                        |
    --------------- Enter OS kernel --------------- 
    |                                             |
    | OS spin lock locked                         |
    |                                             |
    |    release lock:                            |
    |        T1 is waiting for the lock:          |
    |           awake T1                          |
    |                                             |
    | OS spin lock released                       |
    --------------- Exit OS kernel ----------------
    ```

4. è¿›é˜¶çš„Futex: Fast Userspace muTexes
    * Fast Path: è‡ªæ—‹ä¸€æ¬¡ã€‚æ— äººäº‰æŠ¢æ—¶ï¼Œæ— éœ€åŠ¨ç”¨`syscall`ï¼Œç›´æ¥è¿›ä¸´ç•ŒåŒº
        - ä¸€æ¡åŸå­æŒ‡ä»¤ï¼ŒæˆåŠŸç›´æ¥è¿›å…¥ä¸´ç•ŒåŒº
    * Slow Path: è‡ªæ—‹å¤±è´¥ã€‚æœ‰äººäº‰æŠ¢æ—¶ï¼Œæ‰éœ€è¦ç”¨åˆ°`syscall`
        - è¯·æ±‚ç³»ç»Ÿè°ƒç”¨ `futex_wait`


## Lecture 8 è°ƒè¯•ç†è®ºä¸å®è·µ
1. éœ€æ±‚ â†’ è®¾è®¡ â†’ ä»£ç  (<span style="color:blue;">Fault/bug</span>) â†’ æ‰§è¡Œ (<span style="color:blue;">Error</span>) â†’ å¤±è´¥ (<span style="color:blue;">Failure</span>)

## Lecture 9 å¹¶å‘æ§åˆ¶ï¼šåŒæ­¥ (1)
!!! abstract "Take-away Messages"

    åŒæ­¥çš„æœ¬è´¨æ˜¯çº¿ç¨‹éœ€è¦ç­‰å¾…æŸä»¶å®ƒæ‰€é¢„æœŸçš„äº‹ä»¶å‘ç”Ÿï¼Œè€Œäº‹ä»¶çš„å‘ç”Ÿæ€»æ˜¯å¯ä»¥ç”¨æ¡ä»¶ (ä¾‹å¦‚ depth æ»¡è¶³æŸä¸ªæ¡ä»¶ï¼Œæˆ–æ˜¯ç¨‹åºå¤„äºæŸä¸ªç‰¹å®šçš„çŠ¶æ€) æ¥è¡¨è¾¾ã€‚å› æ­¤è®¡ç®—æœºç³»ç»Ÿçš„è®¾è®¡è€…å®ç°äº†<span style="color:blue;">æ¡ä»¶å˜é‡</span>ï¼Œå°†æ¡ä»¶æ£€æŸ¥å’Œä¸´ç•ŒåŒº â€œæ”¾åœ¨ä¸€èµ·â€ï¼Œä»¥å®ç°çº¿ç¨‹é—´çš„åŒæ­¥ã€‚è¿™æ˜¯ä¸‡èƒ½çš„åŒæ­¥æ–¹æ³•ã€‚

1. Synchronization åŒæ­¥ï¼šæ§åˆ¶å¹¶å‘ï¼Œä½¿å¾— â€œä¸¤ä¸ªæˆ–ä¸¤ä¸ªä»¥ä¸Šéšæ—¶é—´å˜åŒ–çš„é‡åœ¨å˜åŒ–è¿‡ç¨‹ä¸­ä¿æŒä¸€å®šçš„ç›¸å¯¹å…³ç³»â€ã€‚ä¾‹å­ï¼š
    * æ¼”å¥éŸ³ä¹ä¸­çš„åŒæ­¥
        - æ¯ä¸ªä¹æ‰‹éƒ½æ˜¯ä¸€ä¸ª â€œçº¿ç¨‹â€
        - èŠ‚æ‹ i åˆ°è¾¾ â†’ æ¼”å¥ ni
    * ä½ ä¸å®¤å‹çº¦å®šåœ¨23:59:59åœ¨å­¦æ´»é—¨å£ç›¸è§
    * ç›¸å½“äºä¸–ç•Œçº¿çš„æ”¶æŸï¼Œæ­¤å‰çº¿ç¨‹éƒ½å„è‡ªæ‰§è¡Œï¼Œä½†æ˜¯åœ¨æŸä¸ªæ—¶é—´èŠ‚ç‚¹æ—¶éœ€è¦åŒæ­¥ï¼Œç„¶åå†å„è‡ªæ‰§è¡Œã€‚åœ¨æŸä¸ªç¬é—´è¾¾åˆ° â€œäº’ç›¸å·²çŸ¥â€ çš„çŠ¶æ€ï¼Œâ€œå…ˆåˆ°å…ˆç­‰â€ï¼Œåœ¨æ¡ä»¶è¾¾æˆçš„ç¬é—´å†æ¬¡æ¢å¤å¹¶è¡Œ

    ```C
    void T_player() {
        while (!end) {
            wait_next_beat();
            play_next_note();
        }
    }

    void T_conductor() {
        while (!end) {
            wait_next_beat();
            release(); // release() ä¹‹åï¼Œplayer éƒ½ä¼šæ¼”å¥ä¸‹ä¸€æ‹
        }
    }

    // è‡ªæ—‹å®ç°
    void wait_next_beat(int expect) {
        // This is a spin-wait loop.
    retry:
        mutex_lock(&lk);
        // This read is protected by a mutex.
        int got = n;
        mutex_unlock(&lk);

        if (got != expect) goto retry;
    }
    ```

2. ç»å…¸åŒæ­¥é—®é¢˜ï¼šç”Ÿäº§è€…-æ¶ˆè´¹è€…é—®é¢˜
    * Producer å’Œ Consumer å…±äº«ä¸€ä¸ªç¼“å†²åŒº
        - Producer (ç”Ÿäº§æ•°æ®)ï¼š å¦‚æœç¼“å†²åŒºæœ‰ç©ºä½ï¼Œæ”¾å…¥ï¼›å¦åˆ™ç­‰å¾…
        - Consumer (æ¶ˆè´¹æ•°æ®)ï¼šå¦‚æœç¼“å†²åŒºæœ‰æ•°æ®ï¼Œå–èµ°ï¼›å¦åˆ™ç­‰å¾…

    ä¾‹å­ï¼š
    ```C
    void produce() { printf("("); }
    void consume() { printf(")"); }
    ```

    * ç”Ÿäº§ = æ‰“å°å·¦æ‹¬å· (push into buffer)
    * æ¶ˆè´¹ = æ‰“å°å³æ‹¬å· (pop from buffer)
    * åœ¨ `printf` å‰åå¢åŠ ä»£ç ï¼Œä½¿å¾—æ‰“å°çš„æ‹¬å·åºåˆ—æ»¡è¶³
        - ä¸€å®šæ˜¯æŸä¸ªåˆæ³•æ‹¬å·åºåˆ—çš„å‰ç¼€
        - æ‹¬å·åµŒå¥—çš„æ·±åº¦ä¸è¶…è¿‡ n
            + n = 3, `((())())(((` åˆæ³•
            + n=3, `(((()))), (()))` ä¸åˆæ³•
    
    pc-1.c: é”™è¯¯çš„è‡ªæ—‹å®ç°
    ```C
    #include <thread.h>
    #include <thread-sync.h>

    mutex_t lk = MUTEX_INIT();

    int n, depth = 0;

    void T_produce() {
        while (1) {
    retry:
            mutex_lock(&lk);
            int ready = (depth < n);
            mutex_unlock(&lk);
            if (!ready) goto retry;

            assert(depth < n); // âŒ, æ­¤æ—¶lkå·²ç»è¢«é‡Šæ”¾ï¼Œå¦‚æœè¢«åˆ‡æ¢åˆ°åˆ«çš„çº¿ç¨‹ï¼Œåˆ«
            // çš„çº¿ç¨‹å¯èƒ½ä¼šæ›´æ”¹depthï¼Œå› æ­¤depth < n ä¸ä¸€å®šæˆç«‹ï¼Œè¿™ä¸ªassertä¼šè§¦å‘

            mutex_lock(&lk);
            printf("(");
            depth++;
            mutex_unlock(&lk);
        }
    }

    void T_consume() {
        while (1) {
    retry:
            mutex_lock(&lk);
            int ready = (depth > 0);
            mutex_unlock(&lk);
            if (!ready) goto retry;

            assert(depth > 0);

            mutex_lock(&lk);
            printf(")");
            depth--;
            mutex_unlock(&lk);
        }
    }
    ```

    pc-2.c: æ­£ç¡®çš„è‡ªæ—‹å®ç°ï¼ˆç„¶è€Œè‡ªæ—‹æµªè´¹äº†CPUï¼‰
    ```C
    #include <thread.h>
    #include <thread-sync.h>

    mutex_t lk = MUTEX_INIT();

    int n, depth = 0;

    void T_produce() {
        while (1) {
    retry:
            mutex_lock(&lk);
            if (!(depth < n)) {
                mutex_unlock(&lk); // å¦‚æœä¸æ»¡è¶³æ¡ä»¶ï¼Œå°±ç«‹é©¬é‡Šæ”¾é”
                goto retry; // æµªè´¹CPUâ—
            }

            // âœ…èƒ½èµ°åˆ°è¿™é‡Œè¯´æ˜ä¸€å®šæ»¡è¶³æ¡ä»¶ depth < nï¼Œ
            // å› æ­¤å¯ä»¥å®‰å…¨åœ°ä¿®æ”¹å…±äº«çŠ¶æ€ï¼Œæ­¤æ—¶é”ä¹Ÿæ²¡è¢«é‡Šæ”¾æ‰

            // The check of sync condition (depth < n) is within
            // the same critical section. As long as we safely
            // protected the shared state, this condition should
            // always hold at this point.
            assert(depth < n);

            printf("(");
            depth++;

            // And at this point, the condition (depth > 0) is
            // satisfied. However, a consumer could proceed with
            // checking depth only if the lock is released.
            mutex_unlock(&lk);
        }
    }

    void T_consume() {
        while (1) {
    retry:
            mutex_lock(&lk);
            if (!(depth > 0)) {
                mutex_unlock(&lk);
                goto retry;
            }

            assert(depth > 0);

            printf(")");
            depth--;

            mutex_unlock(&lk);
        }
    }
    ```

    pc-cv.c: é”™è¯¯çš„æ¡ä»¶å˜é‡å®ç°
    ```C
    #include <thread.h>
    #include <thread-sync.h>

    int n, depth = 0;
    mutex_t lk = MUTEX_INIT();
    cond_t cv = COND_INIT();
    
    #define CAN_PRODUCE (depth < n)
    #define CAN_CONSUME (depth > 0)

    void T_produce() {
        while (1) {
            mutex_lock(&lk);

            if (!CAN_PRODUCE) { // âŒ, åº”è¯¥æ˜¯whileï¼Œè€Œä¸æ˜¯ifï¼Œå› ä¸ºè¢«å”¤é†’
                                // åæœ‰å¯èƒ½åˆè¢«åˆ«çš„çº¿ç¨‹æŠ¢æ‰äº†ï¼Œæ¡ä»¶åˆä¸æ»¡è¶³ï¼Œ
                                // éœ€è¦é‡æ–°æ£€æŸ¥æ¡ä»¶

                // æœ¬è´¨åŸå› ï¼šproducerå’Œconsumerç­‰å¾…çš„ä¸æ˜¯åŒä¸€ä¸ªæ¡ä»¶ï¼Œæ‰€ä»¥ä¸èƒ½ç”¨åŒ
                // ä¸€ä¸ªæ¡ä»¶å˜é‡cvã€‚ç”¨åŒä¸€ä¸ªæ¡ä»¶å˜é‡ï¼Œå°±ç›¸å½“äºå”¤é†’çš„æ—¶å€™å¤šå”¤é†’äº†ï¼Œå¤š
                // å”¤é†’çš„è¦è‡ªå·±æ£€æŸ¥è‡ªå·±æ¡ä»¶æ˜¯å¦æ»¡è¶³

                cond_wait(&cv, &lk);
                // This is subtle. Seemingly "more efficient"
                // implementation is dangerous for newbies.
            }

            printf("(");
            depth++;

            cond_signal(&cv);
            mutex_unlock(&lk);
        }
    }

    void T_consume() {
        while (1) {
            mutex_lock(&lk);

            if (!CAN_CONSUME) {
                cond_wait(&cv, &lk);
            }

            printf(")");
            depth--;

            cond_signal(&cv);
            mutex_unlock(&lk);
        }
    }
    ```

    pc-cv-broadcast.c: æ­£ç¡®çš„æ¡ä»¶å˜é‡å®ç°
    ```C
    #include <thread.h>
    #include <thread-sync.h>

    int n, depth = 0;
    mutex_t lk = MUTEX_INIT();
    cond_t cv = COND_INIT();
    
    #define CAN_PRODUCE (depth < n)
    #define CAN_CONSUME (depth > 0)

    void T_produce() {
        while (1) {
            mutex_lock(&lk);

            while (!CAN_PRODUCE) {
                cond_wait(&cv, &lk); // waitæ—¶: é‡Šæ”¾é”ï¼Œåˆ‡æ¢åˆ°åˆ«çš„çº¿ç¨‹
                // We are here if the thread is being waked up, with
                // the mutex being acquired. Then we check once again,
                // and move out of the loop if CAN_PRODUCE holds.

                // å›æ¥è¿™é‡Œæ—¶: è·å¾—é”ï¼Œç„¶åä¸‹ä¸€è½®whileæ£€æŸ¥æ¡ä»¶
            }

            // We still hold the mutex--and we check again.
            assert(CAN_PRODUCE);

            printf("(");
            depth++;

            cond_broadcast(&cv);
            mutex_unlock(&lk);
        }
    }

    void T_consume() {
        while (1) {
            mutex_lock(&lk);

            while (!CAN_CONSUME) {
                cond_wait(&cv, &lk);
            }

            printf(")");
            depth--;

            cond_broadcast(&cv);
            mutex_unlock(&lk);
        }
    }
    ```

3. â€œä¸‡èƒ½â€ çš„åŒæ­¥æ–¹æ³•ï¼šæ¡ä»¶å˜é‡ï¼ˆæ¡ä»¶ä¸æ»¡è¶³æ—¶ç­‰å¾…ï¼Œæ¡ä»¶æ»¡è¶³æ—¶å”¤é†’ï¼‰

    ```C
    mutex_t lk = MUTEX_INIT();
    cond_t cv = COND_INIT();

    //------------------------------------------------
    mutex_lock(&lk);
    while (!condition) {
        cond_wait(&cv, &lk);
    }
    // Wait for someone for wake-up.
    assert(condition);

    mutex_unlock(&lk);

    //------------------------------------------------
    cond_signal(&cv);     // Wake up a (random) thread
    cond_broadcast(&cv);  // Wake up all threads
    ```

    æ¡ä»¶å˜é‡çš„æ­£ç¡®æ‰“å¼€æ–¹å¼ï¼š

    * ä½¿ç”¨ while å¾ªç¯å’Œ broadcast
        - æ€»æ˜¯åœ¨å”¤é†’åå†æ¬¡æ£€æŸ¥åŒæ­¥æ¡ä»¶
        - æ€»æ˜¯å”¤é†’æ‰€æœ‰æ½œåœ¨å¯èƒ½è¢«å”¤é†’çš„äºº
    * åœ¨è§£å†³åŒæ­¥é—®é¢˜æ—¶ï¼Œå…³é”®åœ¨äºç†è§£ â€œåŒæ­¥æˆåŠŸâ€ çš„æ¡ä»¶æ˜¯ä»€ä¹ˆã€‚

4. åŒæ­¥æœºåˆ¶çš„åº”ç”¨
    * æœ‰ä¸‰ç§çº¿ç¨‹
        - `Ta`è‹¥å¹²ï¼šæ­»å¾ªç¯æ‰“å° `<`
        - `Tb`è‹¥å¹²ï¼šæ­»å¾ªç¯æ‰“å° `>`
        - `Tc`è‹¥å¹²ï¼šæ­»å¾ªç¯æ‰“å° `_`
    * ä»»åŠ¡ï¼š
        - å¯¹çº¿ç¨‹åŒæ­¥ï¼Œä½¿å¾—å±å¹•æ‰“å°å‡º `<><_` å’Œ `><>_` çš„ç»„åˆ

    !!! question "åŒæ­¥æˆåŠŸçš„æ¡ä»¶æ˜¯ä»€ä¹ˆ"

        ä½¿ç”¨æ¡ä»¶å˜é‡ï¼Œåªè¦å›ç­”ä¸‰ä¸ªé—®é¢˜ï¼šæ‰“å° `<` çš„æ¡ä»¶ï¼Ÿæ‰“å° `>` çš„æ¡ä»¶ï¼Ÿæ‰“å° `_` çš„æ¡ä»¶ï¼Ÿ

    åˆ©ç”¨çŠ¶æ€æœºè§†è§’æ¥è§£å†³ï¼š
    ![alt text](../img/image-4.png)

    ```C
    #include "thread.h"
    #include "thread-sync.h"

    #define LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))

    enum { A = 1, B, C, D, E, F, };

    struct rule {
    int from, ch, to;
    } rules[] = {
        {A, '<', B},
        {B, '>', C},
        {C, '<', D},
        {A, '>', E},
        {E, '<', F},
        {F, '>', D},
        {D, '_', A},
    };

    int current = A, quota = 1;

    mutex_t lk = MUTEX_INIT();
    cond_t cv = COND_INIT();

    int next(char ch) {
        for (int i = 0; i < LENGTH(rules); i++) {
            struct rule *rule = &rules[i];
            if (rule->from == current && rule->ch == ch) {
            return rule->to;
            }
        }
        return 0;
    }

    static int can_print(char ch) {
        return next(ch) != 0 && quota > 0;
    }

    void fish_before(char ch) {
        mutex_lock(&lk);
        while (!can_print(ch)) {
            cond_wait(&cv, &lk);
        }
        quota--;
        mutex_unlock(&lk);
    }

    void fish_after(char ch) {
        mutex_lock(&lk);
        quota++;
        current = next(ch);
        assert(current);
        cond_broadcast(&cv);
        mutex_unlock(&lk);
    }

    const char roles[] = ".<<<<<>>>>___";

    void fish_thread(int id) {
        char role = roles[id];
        while (1) {
            fish_before(role);
            putchar(role); // Not lock-protected
            fish_after(role);
        }
    }

    int main() {
        setbuf(stdout, NULL);
        for (int i = 0; i < strlen(roles); i++)
            create(fish_thread);
    }
    ```

## Lecture 10 å¹¶å‘æ§åˆ¶ï¼šåŒæ­¥ (2)
!!! abstract "Take-away Messages"

    ä¿¡å·é‡å¯ä»¥çœ‹åšæ˜¯äº’æ–¥é”çš„ä¸€ä¸ª â€œæ¨å¹¿â€ï¼Œå¯ä»¥ç†è§£æˆæ¸¸æ³³é¦†çš„æ‰‹ç¯ã€è¢‹å­é‡Œçš„çƒï¼Œé€šè¿‡è®¡æ•°çš„æ–¹å¼å®ç°åŒæ­¥â€”â€”åœ¨ç¬¦åˆè¿™ä¸ªæŠ½è±¡æ—¶ï¼Œä½¿ç”¨ä¿¡å·é‡èƒ½å¤Ÿå¸¦æ¥ä¼˜é›…çš„ä»£ç ã€‚ä½†ä¿¡å·é‡ä¸æ˜¯ä¸‡èƒ½çš„â€”â€”ç†è§£çº¿ç¨‹åŒæ­¥çš„æ¡ä»¶æ‰æ˜¯çœŸæ­£è‡³å…³é‡è¦çš„ã€‚

1. E. W. Dijkstra å‘æ˜çš„å¦ä¸€ç§å…±äº«å†…å­˜ç³»ç»Ÿä¸­å¸¸ç”¨çš„åŒæ­¥æ–¹æ³•ï¼šä¿¡å·é‡ã€‚ 
    
    ç”¨äº’æ–¥é”å®ç°åŒæ­¥, ä¸€ä¸ªå¥‡å¦™çš„æƒ³æ³•:

    * åˆ›å»ºé”æ—¶ï¼Œç«‹å³ â€œè·å¾—â€ å®ƒ (æ€»æ˜¯æˆåŠŸ)
    * å…¶ä»–äººæƒ³è¦è·å¾—æ—¶å°±ä¼šç­‰å¾…
        - æ­¤æ—¶ release å°±å®ç°äº†åŒæ­¥
    * ä¸€ä¸ªçº¿ç¨‹ä¸Šé”ï¼Œåœ¨å¦ä¸€ä¸ªçº¿ç¨‹è§£é” ğŸ˜‚ (å®é™…ä»£ç è¿™ä¹ˆå†™æ˜¯Undefined behavior)

    ç”¨äº’æ–¥é”å®ç°è®¡ç®—å›¾, Acquire-Release å®ç°è®¡ç®—å›¾:

    * ä¸ºæ¯ä¸€æ¡è¾¹ `e = (u,v)` åˆ†é…ä¸€ä¸ªäº’æ–¥é” ğŸ”’
    * åˆå§‹æ—¶ï¼Œå…¨éƒ¨å¤„äºé”å®šçŠ¶æ€
    * å¯¹äºä¸€ä¸ªèŠ‚ç‚¹ï¼Œå®ƒéœ€è¦è·å¾—æ‰€æœ‰å…¥è¾¹çš„é”æ‰èƒ½ç»§ç»­
        - å¯ä»¥ç›´æ¥è®¡ç®—çš„èŠ‚ç‚¹ç«‹å³å¼€å§‹è®¡ç®—
    * è®¡ç®—å®Œæˆåï¼Œé‡Šæ”¾æ‰€æœ‰å‡ºè¾¹å¯¹åº”çš„é”

        exampleï¼š

        ![alt text](../img/image-5.png)

    ```C
    #include <thread.h>
    #include <thread-sync.h>
    #include <unistd.h>

    #define LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))

    const int N = 7;

    struct Edge {
        int from, to;
        mutex_t mutex;
    } edges[] = {
        {1, 2, MUTEX_INIT()},
        {2, 3, MUTEX_INIT()},
        {2, 4, MUTEX_INIT()},
        {2, 5, MUTEX_INIT()},
        {4, 6, MUTEX_INIT()},
        {5, 6, MUTEX_INIT()},
        {4, 7, MUTEX_INIT()},
    };

    void T_worker(int id) {
        for (int i = 0; i < LENGTH(edges); i++) {
            struct Edge *e = &edges[i];
            if (e->to == id) {
                mutex_lock(&e->mutex);
            }
        }

        printf("Start %d\n", id);
        sleep(1);
        printf("End %d\n", id);
        sleep(1);

        for (int i = 0; i < LENGTH(edges); i++) {
            struct Edge *e = &edges[i];
            if (e->from == id) {
                // Well... This is undefined behavior
                // for POSIX threads. This is just a
                // hack for demonstration.
                mutex_unlock(&e->mutex);
            }
        }
    }

    int main() {
        for (int i = 0; i < LENGTH(edges); i++) {
            struct Edge *e = &edges[i];
            mutex_lock(&e->mutex);
        }

        for (int i = 0; i < N; i++) {
            create(T_worker);
        }
    }
    ```

2. æœ¬è´¨ï¼šâ€œRelease as Synchronizationâ€

    Release-Acquire å®ç°äº† <span style="color:blue;">happens-before</span>
    
    * Acquire = ç­‰å¾… tokenï¼Œå¾€è¢‹å­é‡Œå–çƒ (å¦‚æœæ­¤æ—¶è¢‹é‡Œæ²¡æœ‰çƒï¼Œåˆ™éœ€è¦ç­‰å¾…)ï¼ŒP
    * Release = å‘å‡º tokenï¼Œå¾€è¢‹å­é‡Œæ”¾çƒ (å¦‚æœæœ‰äººåœ¨ç­‰å¾…ï¼Œç›´æ¥æŠŠçƒäº¤ç»™ä»–)ï¼ŒV
    * æ³¨æ„æˆ‘ä»¬å¯ä»¥æœ‰å¤šä¸ªå£è¢‹

    ä¿¡å·é‡çš„ API: (ä¿¡å·é‡å®é™…ä¸Šæ˜¯ç‰¹æ®Šçš„æ¡ä»¶å˜é‡ï¼Œéšå«äº†ä¸€ä¸ªç‰¹åˆ«çš„æ¡ä»¶: çƒçš„æ•°é‡å¤§äº 0)
    ```C
    void P(sem_t *sem) {
        // P - prolaag
        //     try + decrease/down/wait/acquire
        atomic {
            wait_until(sem->count > 0) {
                sem->count--;
            }
        }
    }

    void V(sem_t *sem) {
        // V - verhoog
        //     increase/up/post/signal/release
        atomic {
            sem->count++;
        }
    }
    ```

3. ä¿¡å·é‡çš„ä¸¤ç§å…¸å‹åº”ç”¨
    1. å®ç°ä¸€æ¬¡ä¸´æ—¶çš„ happens-before: 
        * A â†’ V(s) â†’ P(s)  â†’ B
            - è¿™å°±æ˜¯åˆšæ‰çš„ â€œäº’æ–¥é”å®ç°åŒæ­¥â€
    2. ç®¡ç†è®¡æ•°å‹èµ„æº
        * æ¸¸æ³³æ± é‡Œçš„äººä¸èƒ½è¶…è¿‡ n ä¸ª
        * åœè½¦åœºé‡Œçš„è½¦ä¸èƒ½è¶…è¿‡ n ä¸ª
        * ä½†å¯ä»¥æœ‰å¤šä¸ª â€œåœè½¦åœºâ€ã€â€œæ¸¸æ³³æ± â€
        * æˆ‘ä»¬ä¹Ÿå¯ä»¥åˆ›é€ å‡ºè½¦ä½

4. ä¾‹å­1ï¼šä½¿ç”¨ä¿¡å·é‡å®ç°çº¿ç¨‹ join()ï¼šæˆ‘ä»¬æ—¢å¯ä»¥ç”¨ä¸€ä¸ªä¿¡å·é‡å®ç°ä¸€æ¬¡ä¸´æ—¶çš„ happens-beforeï¼Œä¹Ÿå¯ä»¥ç”¨ä¸€ä¸ªè®¡æ•°å‹ä¿¡å·é‡ç­‰å¾…æ•°é‡æ­£ç¡®çš„çº¿ç¨‹ç»“æŸã€‚
    ```C
    #include <thread-sync.h>

    sem_t done[16];
    int count = 0;

    void worker_init(int T) {
        count = T;
        for (int i = 1; i <= T; i++) {
            SEM_INIT(&done[i], 0);
        }
    }

    void worker_done(int id) {
        V(&done[id]);
    }

    void worker_join() {
        for (int i = 1; i <= count; i++) {
            P(&done[i]);
        }
    }
    ```

    ä¾‹å­2ï¼šä¼˜é›…åœ°å®ç°ç”Ÿäº§è€…-æ¶ˆè´¹è€…ã€‚ç”Ÿäº§è€…æŠŠçƒä» empty å£è¢‹å–èµ°ï¼Œæ‰“å°ä¹‹åæŠŠçƒæ”¾å…¥ fill å£è¢‹ï¼›æ¶ˆè´¹è€…åˆ™æ°å¥½ç›¸åã€‚æ•´ä¸ªç³»ç»Ÿæ»¡è¶³ empty + fill + æ­£åœ¨æ‰“å°çš„çº¿ç¨‹ = ç¼“å†²åŒºå¤§å°çš„å…¨å±€çº¦æŸã€‚
    ```C
    void produce() {
        P(&empty);
        printf("(");
        V(&fill);
    }

    void consume() {
        P(&fill);
        printf(")");
        V(&empty);
    }
    ```
    ![alt text](../img/image-6.png)

5. ä¿¡å·é‡ v.s. æ¡ä»¶å˜é‡
    * ä¿¡å·é‡
        - äº’æ–¥é”çš„è‡ªç„¶æ¨å¹¿
        - å¹²å‡€ã€ä¼˜é›…ï¼šæ²¡æœ‰æ¡ä»¶å˜é‡çš„ â€œè‡ªæ—‹â€
    * æ¡ä»¶å˜é‡
        - ä¸‡èƒ½ï¼šé€‚ç”¨äºä»»ä½•åŒæ­¥æ¡ä»¶
        - ä¸å¤ªå¥½ç”¨ï¼šä»£ç æ€»æ„Ÿè§‰ä¸å¤ªå¹²å‡€

    ä¾‹å­ï¼šå“²å­¦å®¶åƒé¥­é—®é¢˜ (E. W. Dijkstra, 1960)

    * å“²å­¦å®¶ (çº¿ç¨‹) æœ‰æ—¶æ€è€ƒï¼Œæœ‰æ—¶åƒé¥­
    * åƒé¥­éœ€è¦åŒæ—¶å¾—åˆ°å·¦æ‰‹å’Œå³æ‰‹çš„å‰å­
    
    ![alt text](../img/image-7.png)

    æ¡ä»¶å˜é‡

    * åŒæ­¥æ¡ä»¶ï¼š`avail[lhs] && avail[rhs]`
    * èƒŒæ¨¡æ¿å³å¯ï¼Œä¸€å®šæ­£ç¡®âœ…

    ä¿¡å·é‡

    * `P(&sem[lhs]) && P(&sem[rhs])`
    * çœ‹èµ·æ¥æ²¡ä»€ä¹ˆé—®é¢˜ï¼Ÿé¢å¯¹å¤æ‚çš„åŒæ­¥æ¡ä»¶ï¼Œå®¹æ˜“å‡ºé”™...

    ```C
    #include <thread.h>
    #include <thread-sync.h>

    #define N 5

    sem_t avail[N];

    void Tphilosopher(int id) {
        int lhs = (id + N - 1) % N; // id - 1å¯èƒ½ä¸ºè´Ÿæ•°ï¼Œæ•… + N
        int rhs = id % N;

        while (1) {
            P(&avail[lhs]);
            printf("+ %d by T%d\n", lhs, id); // âŒ, å¦‚æœ 5 ä¸ªå“²å­¦å®¶åŒæ—¶ä¸¾èµ·
                                              // å·¦æ‰‹çš„å‰å­ -> æ­»é”äº†
            P(&avail[rhs]);
            printf("+ %d by T%d\n", rhs, id);

            // Eat.
            // Philosophers are allowed to eat in parallel.

            printf("- %d by T%d\n", lhs, id);
            printf("- %d by T%d\n", rhs, id);
            V(&avail[lhs]);
            V(&avail[rhs]);
        }
    }

    int main() {
        for (int i = 0; i < N; i++) {
            SEM_INIT(&avail[i], 1);
        }

        for (int i = 0; i < N; i++) {
            create(Tphilosopher);
        }
    }
    ```

    * å¦‚æœ 5 ä¸ªå“²å­¦å®¶åŒæ—¶ä¸¾èµ·å·¦æ‰‹çš„å‰å­â€¦â€¦æ­»é”äº†
        - æˆ‘ä»¬éœ€è¦ç¦æ­¢è¿™ä»¶äº‹å‘ç”Ÿ
    
    ä¿¡å·é‡Workaround 1: ä»æ¡Œå­ä¸Šèµ¶èµ°ä¸€ä¸ªäºº

    * ç›´è§‚ç†è§£ï¼šå¤§å®¶å…ˆä»æ¡Œä¸Šé€€å‡º
        - è¢‹å­é‡Œæœ‰ 4 å¼ å¡
        - æ‹¿åˆ°å¡çš„å¯ä»¥ä¸Šæ¡Œåƒé¥­ (æ‹¿å‰å­)
        - åƒå®Œä»¥åæŠŠå¡å½’è¿˜åˆ°è¢‹å­
    
    ```C
    #include <thread.h>
    #include <thread-sync.h>

    #define N 5

    sem_t table;
    sem_t avail[N];

    void Tphilosopher(int id) {
        int lhs = (id + N - 1) % N;
        int rhs = id % N;

        while (1) {
            // Come to table
            P(&table);

            P(&avail[lhs]);
            printf("+ %d by T%d\n", lhs, id);
            P(&avail[rhs]);
            printf("+ %d by T%d\n", rhs, id);

            // Eat.
            // Philosophers are allowed to eat in parallel.

            printf("- %d by T%d\n", lhs, id);
            printf("- %d by T%d\n", rhs, id);
            V(&avail[lhs]);
            V(&avail[rhs]);

            // Leave table
            V(&table);
        }
    }

    int main() {
        SEM_INIT(&table, N - 1); // âœ… ä¿è¯æ¡Œå­ä¸Šè‡³å¤šæœ‰ N - 1 ä¸ªäºº


        for (int i = 0; i < N; i++) {
            SEM_INIT(&avail[i], 1); // Nä¸ªè¢‹å­ï¼Œæ¯ä¸ªè¢‹å­é‡Œè‡³å¤š1ä¸ªå‰å­
        }

        for (int i = 0; i < N; i++) {
            create(Tphilosopher);
        }
    }
    ```
    
    ä¿¡å·é‡Workaround 2: Lock Ordering

    * ç»™å‰å­ç¼–å·ï¼Œæ€»æ˜¯å…ˆæ‹¿ç¼–å·å°çš„

    ```C
    #include <thread.h>
    #include <thread-sync.h>

    #define N 5

    sem_t avail[N];

    void Tphilosopher(int id) {
        int lhs = (id + N - 1) % N;
        int rhs = id % N;

        while (1) {
            if (lhs < rhs) // âœ…ä¿è¯ç¼–å·å°çš„å…ˆæ‹¿
            {
                P(&avail[lhs]);
                P(&avail[rhs]);
            }
            else
            {
                P(&avail[rhs]);
                P(&avail[lhs]);
            }
            printf("+ %d by T%d\n", lhs, id);
            printf("+ %d by T%d\n", rhs, id);

            // Eat.
            // Philosophers are allowed to eat in parallel.

            printf("- %d by T%d\n", lhs, id);
            printf("- %d by T%d\n", rhs, id);
            V(&avail[lhs]);
            V(&avail[rhs]);
        }
    }

    int main() {
        for (int i = 0; i < N; i++) {
            SEM_INIT(&avail[i], 1);
        }

        for (int i = 0; i < N; i++) {
            create(Tphilosopher);
        }
    }
    ```

6. ç”¨æ¡ä»¶å˜é‡å®ç°ä¿¡å·é‡: easy
    ```C
    void P(sem_t *sem) {
        hold(&sem->mutex) {
            while (!COND)
                cond_wait(&sem->cv, &sem->mutex);
            sem->count--;
        }
    }

    void V(sem_t *sem) {
        hold(&sem->mutex) {
            sem->count++;
            cond_broadcast(&sem->cv);
        }
    }
    ```

    ç”¨ä¿¡å·é‡å®ç°æ¡ä»¶å˜é‡: hard, ä¸‹é¢è¿™ä¸ªæ˜¯é”™è¯¯å®ç°
    ```C
    void wait(struct condvar *cv, mutex_t *mutex) {
        mutex_lock(&cv->lock);
        cv->nwait++;
        mutex_unlock(&cv->lock);

        mutex_unlock(mutex); // å¿…é¡»å…ˆé‡Šæ”¾é”ï¼Œå†sleepã€‚å¦åˆ™å¸¦ç€é”å»sleepäº†è¯ï¼Œ
                             // æ²¡äººå†èƒ½è·å¾—mutexè¿™æŠŠé”ï¼Œå†ä¹Ÿæ”¹å†™ä¸äº†çŠ¶æ€äº†ã€‚

                             // ç„¶è€Œï¼Œè‹¥æ˜¯å…ˆé‡Šæ”¾äº†é”ï¼Œæ­¤æ—¶æœ‰å¯èƒ½åˆ«çš„çº¿ç¨‹æ‰§è¡Œäº†Vï¼Œ
                             // æ­¤æ—¶åˆ«çš„çº¿ç¨‹æ­£å¥½åœ¨ç­‰Pï¼Œç»“æœç›´æ¥æˆåŠŸäº†ï¼Œå‹æ ¹ä¸ç”¨
                             // sleepï¼Œæ¥ç€å°±èƒ½å¾€ä¸‹æ‰§è¡Œäº†ã€‚æŠ¢èµ°äº†æœ¬çº¿ç¨‹sleepå
                             // æƒ³è¦è·å¾—çš„çƒã€‚ä¹Ÿå°±æ˜¯é”™è¯¯çš„å”¤é†’äº†åˆ«çš„çº¿ç¨‹ã€‚
                             // å¸Œæœ›çš„æ˜¯ç”Ÿäº§è€…å”¤é†’æ¶ˆè´¹è€…ï¼Œæ¶ˆè´¹è€…å”¤é†’ç”Ÿäº§è€…ã€‚ç„¶è€Œ
                             // ç°åœ¨è¿™æ ·æ˜¯æœ‰å¯èƒ½ç”Ÿäº§è€…T1å”¤é†’äº†ç”Ÿäº§è€…T2ï¼Œæ¶ˆè´¹è€…æ— 
                             // æ³•è¢«å”¤é†’ï¼Œç”Ÿäº§è€…åˆç­‰ç€æ¶ˆè´¹è€…æ‹¿èµ°bufferçš„ä¸œè¥¿ï¼Œå¯¼
                             // è‡´ç³»ç»Ÿå†ä¹Ÿæ— ä»»ä½•è¿›åº¦ã€‚
        P(&cv->sleep);
        // â€œé‡Šæ”¾é”å¹¶ç¡çœ â€ éœ€è¦è¢«å®ç°æˆä¸€ä¸ªåŸå­æ“ä½œ (ä¾‹å¦‚ï¼Œç”¨è‡ªæ—‹å®ç°)ï¼Œä½†è¿™ä¸€ç‚¹å¹¶
        // ä¸å®¹æ˜“ç”¨ä¿¡å·é‡å®ç°

        mutex_lock(mutex); // ç¡é†’åé‡æ–°è·å¾—mutexè¿™æŠŠé”
    }

    void broadcast(struct condvar *cv) {
        mutex_lock(&cv->lock);

        for (int i = 0; i < cv->nwait; i++) {
            V(&cv->sleep);
        }
        cv->nwait = 0;

        mutex_unlock(&cv->lock);
    }
    ```

    å®ç°å›°éš¾çš„æœ¬è´¨åŸå› ï¼š
    
    * å…ˆé‡Šæ”¾é”ï¼Œå†æ‰§è¡Œ P
        - é‡Šæ”¾é”çš„ä¸€ç¬é—´å¯èƒ½ä¸ broadcast å¹¶å‘
    * å…ˆæ‰§è¡Œ Pï¼Œå†é‡Šæ”¾é”
        - P(&cv->sleep) ä¼š â€œæ°¸ä¹…ç¡çœ â€

    é”™è¯¯å®ç°ï¼š
    ```C
    #include <thread.h>
    #include <thread-sync.h>

    sem_t fill, empty;

    struct condvar {
        int nwait;
        sem_t sleep;
        mutex_t lock;
    } cv;

    void init(struct condvar *cv) {
        cv->nwait = 0;
        mutex_init(&cv->lock);
        SEM_INIT(&cv->sleep, 0);
    }

    void wait(struct condvar *cv, mutex_t *mutex) {
        // At this point, we hold "mutex".
        mutex_lock(&cv->lock);
        cv->nwait++;
        mutex_unlock(&cv->lock);

        // We have marked this thread as "waiting".
        // Now we release the lock and go to sleep.
        //
        // <-- broadcast() may happen here.
        //     Suppose T1 calls broadcast() and proceeds
        //     with execution. T1 may call wait() and
        //     erroneously being signaled.
        mutex_unlock(mutex);

        // <-- also, here.
        P(&cv->sleep);

        // Re-acquire the mutex.
        mutex_lock(mutex);
    }

    void broadcast(struct condvar *cv) {
        mutex_lock(&cv->lock);

        // Wake up all waiting threads.
        for (int i = 0; i < cv->nwait; i++) {
            V(&cv->sleep);
        }
        cv->nwait = 0;
        mutex_unlock(&cv->lock);
    }

    int n = 1, depth = 0;
    mutex_t lk = MUTEX_INIT();
    struct condvar cv;
    
    #define CAN_PRODUCE (depth < n)
    #define CAN_CONSUME (depth > 0)

    void T_produce() {
        while (1) {
            mutex_lock(&lk);

            while (!CAN_PRODUCE) {
                wait(&cv, &lk);
            }

            printf("(");
            fflush(stdout);
            depth++;

            mutex_unlock(&lk);

            // Yes. We can broadcast without
            // holding the mutex.
            broadcast(&cv);
            usleep(10);
        }
    }

    void T_consume() {
        init(&cv);

        while (1) {
            mutex_lock(&lk);

            while (!CAN_CONSUME) {
                wait(&cv, &lk);
            }

            printf(")");
            fflush(stdout);
            depth--;

            mutex_unlock(&lk);

            broadcast(&cv);
            usleep(10);
        }
    }

    int main() {
        for (int i = 0; i < 1; i++) {
            create(T_consume);
            create(T_produce);
        }
    }
    ```

## Lecture 11 çœŸå®ä¸–ç•Œçš„å¹¶å‘ç¼–ç¨‹
!!! abstract "Take-away Messages"

    å¯¹å¹¶å‘ç¼–ç¨‹çš„äº‰è®®ä¸€ç›´å­˜åœ¨ï¼Œä¾‹å¦‚ â€œ[Threads cannot be implemented as a library](https://dl.acm.org/doi/10.1145/1065010.1065042)â€ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬åœ¨å¾ˆå¤šåº”ç”¨é¢†åŸŸçœ‹åˆ°äº† â€œé¢†åŸŸç‰¹å®šâ€ çš„è§£å†³æ–¹æ¡ˆï¼šWeb ä¸­çš„å¼‚æ­¥ç¼–ç¨‹ã€é«˜æ€§èƒ½è®¡ç®—ä¸­çš„ MPI å’Œ OpenMIã€æ•°æ®ä¸­å¿ƒä¸­çš„ goroutinesã€äººå·¥æ™ºèƒ½æ—¶ä»£çš„ CUDAã€‚æ›´æœ‰è¶£çš„æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼šæ”¹å˜ä¸–ç•Œçš„æŠ€æœ¯ï¼Œå¾€å¾€åªæ˜¯ä¸€ä¸ªå°å°çš„å¥‡æ€å¦™æƒ³,æœ€ç»ˆåšæŒåˆ°åº•å¾—åˆ°çš„â€”â€”å®ƒä»¬å¾ˆéš¾è¢« â€œè§„åˆ’â€ å‡ºæ¥ï¼Œè€Œæ˜¯éœ€è¦ä¸€äº› â€œèƒŒé“è€Œé©°â€ çš„äººåšæŒåˆ°åº•ã€‚åœ¨å½“ä»Šçš„ç¤¾ä¼šç¯å¢ƒä¸‹ï¼Œæˆ‘ä»¬æœ€ç¼ºå°‘çš„æ˜¯æœ‰èƒ½åŠ›èƒŒé“è€Œé©°çš„äººâ€”â€”æœ‰äº†ä¸‹ä¸€ä»£äººçš„è¿›æ­¥ï¼Œæ‰ä¼šæœ‰åŒ…å®¹ä»–ä»¬çš„åœŸå£¤ã€‚

1. é«˜æ€§èƒ½è®¡ç®—ä¸­çš„å¹¶è¡Œç¼–ç¨‹
    * é€šå¸¸è®¡ç®—å›¾å®¹æ˜“é™æ€åˆ‡åˆ† (æœºå™¨-çº¿ç¨‹ä¸¤çº§ä»»åŠ¡åˆ†è§£)
        - ç”Ÿäº§è€…-æ¶ˆè´¹è€…è§£å†³ä¸€åˆ‡
            + [MPI](https://hpc-tutorials.llnl.gov/mpi/) - â€œmessage passing librariesâ€, [OpenMP](https://www.openmp.org/) - â€œmulti-platform shared-memory parallel programming (C/C++ and Fortran)â€
    
    ```C
    // åŠ ä¸Šè¿™ä¸ªï¼Œä¸‹é¢çš„forå¾ªç¯å°±èƒ½åœ¨ä¸åŒçš„çº¿ç¨‹é‡Œå¹¶è¡Œè®¡ç®—
    #pragma omp parallel num_threads(128) 
    for (int i = 0; i < 1024; i++) {
    }
    ```

## Lecture 12 å¹¶å‘ Bugs
!!! abstract "Take-away Messages"

    äººç±»æœ¬è´¨ä¸Šæ˜¯ sequential creatureï¼Œå› æ­¤æ€»æ˜¯é€šè¿‡ â€œå—çš„é¡ºåºæ‰§è¡Œâ€ è¿™ä¸€ç®€åŒ–æ¨¡å‹å»ç†è§£å¹¶å‘ç¨‹åºï¼Œä¹Ÿç›¸åº”æœ‰äº†ä¸¤ç§ç±»å‹çš„å¹¶å‘ bugsï¼š

    * Atomicity violationï¼Œæœ¬åº”åŸå­å®Œæˆä¸è¢«æ‰“æ–­çš„ä»£ç è¢«æ‰“æ–­
    * Order violationï¼Œæœ¬åº”æŒ‰æŸä¸ªé¡ºåºå®Œæˆçš„æœªèƒ½è¢«æ­£ç¡®åŒæ­¥
    
    ä¸è¿™ä¸¤ç±» bugs å…³è”çš„ä¸€ä¸ªé‡è¦é—®é¢˜æ˜¯æ•°æ®ç«äº‰ï¼Œå³ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®åŒä¸€å†…å­˜ï¼Œä¸”è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯å†™ã€‚æ•°æ®ç«äº‰éå¸¸å±é™©ï¼Œå› æ­¤æˆ‘ä»¬åœ¨ç¼–ç¨‹æ—¶è¦å°½åŠ›é¿å…ã€‚

1. å¸¸è§çš„å¹¶å‘ bugsï¼šæ­»é”ã€æ•°æ®ç«äº‰ã€åŸå­æ€§å’Œé¡ºåºè¿åã€‚
    * æ­»é” (Deadlock): A deadlock is a state in which each member of a group is waiting for another member, including itself, to take action. æ­»é”äº§ç”Ÿçš„å¿…è¦æ¡ä»¶ï¼š
        - Mutual-exclusion - ä¸€ä¸ªå£è¢‹ä¸€ä¸ªçƒï¼Œå¾—åˆ°çƒæ‰èƒ½ç»§ç»­
        - Wait-for - å¾—åˆ°çƒçš„äººæƒ³è¦æ›´å¤šçš„çƒ
        - No-preemption - ä¸èƒ½æŠ¢åˆ«äººçš„æŒæœ‰çš„çƒ
        - Circular-chain - å½¢æˆå¾ªç¯ç­‰å¾…çƒçš„å…³ç³»
    * æ•°æ®ç«äº‰ (Data race)ï¼šä¸åŒçš„çº¿ç¨‹åŒæ—¶è®¿é—®åŒä¸€å†…å­˜ï¼Œä¸”è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯å†™ã€‚

        Case 1: ä¸Šé”™äº†é”
        ```C
        void T_1() { spin_lock(&A); sum++; spin_unlock(&A); }
        void T_2() { spin_lock(&B); sum++; spin_unlock(&B); }
        ```

        Case 2: å¿˜è®°ä¸Šé”
        ```C
        void T_1() { spin_lock(&A); sum++; spin_unlock(&A); }
        void T_2() { sum++; }
        ```

    * åŸå­æ€§å’Œé¡ºåºè¿å
        - åŸå­æ€§è¿å (Atomicity Violation)
            + â€œABAâ€: ä»£ç è¢«åˆ«äºº â€œå¼ºåŠ¿æ’å…¥â€ã€‚å³ä¾¿åˆ†åˆ«ä¸Šé” (æ¶ˆé™¤æ•°æ®ç«äº‰)ï¼Œä¾ç„¶æ˜¯ AV
            ![alt text](../img/image-8.png)
        - é¡ºåºè¿å (Order Violation)
            + â€œBAâ€: äº‹ä»¶æœªæŒ‰é¢„å®šçš„é¡ºåºå‘ç”Ÿã€‚ä¾‹å­ï¼šconcurrent use-after-free
            ![alt text](../img/image-9.png)

## Lecture 13 åº”å¯¹ (å¹¶å‘) Bugs
!!! abstract "Take-away Messages"

    Bugs (åŒ…æ‹¬å¹¶å‘ bugs) ä¸€ç›´ä»¥æ¥å›°æ‰°ç€æ‰€æœ‰è½¯ä»¶å·¥ç¨‹çš„å®è·µè€…ã€‚æˆ‘ä»¬ä¸ä»…è¦åº”å¯¹ specification crisis (å®šä¹‰åˆ°åº•ä»€ä¹ˆæ˜¯å¯¹çš„)ï¼Œç”šè‡³å³ä¾¿çŸ¥é“ specificationï¼Œä¹Ÿéš¾ä»¥åº”å¯¹ç°ä»£è½¯ä»¶çš„å¤æ‚æ€§ã€‚ä¸ºäº†éƒ¨åˆ†åº”å¯¹è¿™ä¸€ç‚¹ä»è€Œå®ç° â€œæ›´æ­£ç¡®â€ çš„è½¯ä»¶ï¼Œæˆ‘ä»¬æŠŠå¯¹ç¨‹åºçš„é¢„æœŸè¡¨è¾¾åœ¨ç¨‹åºä¸­ (race-free, lock ordering, ...)ï¼Œè€Œä¸æ˜¯è®©ç¨‹åºåœ¨è‡ªç„¶çŠ¶æ€ä¸‹æ‚„æ‚„è¿›å…¥æœ‰é—®é¢˜çš„çŠ¶æ€ï¼Œå°±æ˜¯æˆ‘ä»¬ç›®å‰è§£å†³ç¨‹åºè°ƒè¯•é—®é¢˜çš„æŠ˜ä¸­åŠæ³•ã€‚â€œå±±å¯¨â€ sanitizer ç»™æˆ‘ä»¬å¸¦æ¥çš„å¯å‘åˆ™æ˜¯ï¼šå¦‚æœæˆ‘ä»¬èƒ½æ¸…æ¥šåœ°è¿½æº¯åˆ°é—®é¢˜äº§ç”Ÿçš„æœ¬æºï¼Œæˆ‘ä»¬å°±æ€»æ˜¯èƒ½æ‰¾åˆ°å¥½çš„åº”å¯¹æ–¹æ³•â€”â€”å±±å¯¨çš„ sanitizers åœ¨æš—ä¸­å¸®åŠ©ä½ å®ç° fail-fast çš„ç¨‹åºï¼Œä»è€Œå‡è½»ä½ è°ƒè¯•é—®é¢˜çš„è´Ÿæ‹…ã€‚

1. æ­»é”çš„é¿å…: 
    * Lock ordering: é¿å…å¾ªç¯ç­‰å¾…
        - ä¸¥æ ¼æŒ‰ç…§ç¼–å·é¡ºåºè·å¾—æ‰€æœ‰é”
    
    lockdep: ä¸ºæ¯ä¸€ä¸ªé”éƒ½è¿½è¸ªä¸Šé”çš„é¡ºåºä¼šå¸¦æ¥ç›¸å½“çš„å¼€é”€ã€‚æ›´ç»æµçš„æ–¹å¼æ˜¯æŠŠæ‰€æœ‰åœ¨åŒä¸€è¡Œä»£ç ä¸­åˆå§‹åŒ–çš„é”éƒ½çœ‹æˆæ˜¯ â€œåŒä¸€ä¸ªé”â€ï¼Œè¿™æ ·é”çš„æ•°é‡å°±å¤§å¹…å‡å°‘äº†ã€‚å½“ç„¶è¿™ä¹Ÿä¼šæŸå¤±ä¸€äº›æ£€æµ‹ç²¾åº¦ï¼Œä¾‹å¦‚å“²å­¦å®¶åƒé¥­é—®é¢˜ä¸­ï¼Œå¦‚æœæ‰€æœ‰çš„é”éƒ½åœ¨åŒä¸€è¡Œä»£ç ä¸­åˆå§‹åŒ–ï¼Œæˆ‘ä»¬å°±ä¸èƒ½åŒºåˆ†å®ƒä»¬çš„ä¸Šé”é¡ºåºäº†ã€‚

    lockdep.cc
    ```CPP
    #include "lockdep.h"
    #include <vector>
    #include <set>
    #include <iostream>
    #include <cassert>
    #include <string>

    using std::string, std::cout, std::endl, std::set;
    using edge = std::pair<string, string>;

    // Subtle: this *memory-leak* is intentional.
    // There lacks a mechanism to force destructor join()
    // to be called *before* global objects' destructions.
    static auto* vertices = new set<string>();
    static auto* edges = new set<edge>();

    // It's safe to auto-destruct thread-local objects.
    static thread_local set<string> held_locks;

    static void check_cycles();
    static mutex_t GL = MUTEX_INIT();

    class HoldLock {
        mutex_t *lk;

    public:
        HoldLock(mutex_t *lock): lk(lock) {
            mutex_lock(lk);
        }

        ~HoldLock() {
            mutex_unlock(lk);
        }
    };

    // This function is to be C-linked; name mangling is disabled.
    extern "C"
    void lock(lock_t *lk) {
        // Vertices and edges (set<>s) are shared across threads.
        // Keep them safe with an RAII-guarded lock.
        { [[maybe_unused]] HoldLock h(&GL);
            bool updated = false;

            vertices->insert(lk->name);
            for (auto name : held_locks) {
                edge e(name, lk->name);
                if (!edges->contains(e)) {
                    edges->insert(e);
                    updated = true;
                }
            }

            if (updated) {
                check_cycles();
            }
        }

        // The held_locks is declared as thread_local.
        // No need for locks.
        held_locks.insert(lk->name);

        mutex_lock(&lk->mutex);
    }

    extern "C"
    void unlock(lock_t *lk) {
        mutex_unlock(&lk->mutex);

        held_locks.erase(lk->name);
    }

    static void check_cycles() {
        // At this point, we must have held GL.
        // Unfortunately, there is no graceful way to check if
        // this lock is held by the current thread.
        assert(pthread_mutex_trylock(&GL) == EBUSY);

        // Transitive closure by Floyd-Warshall's algorithm.
        for (auto v: *vertices)
            for (auto u: *vertices)
                for (auto w: *vertices)
                    if (edges->contains({u, v}) && edges->contains({v, w})) {
                        edges->insert({u, w});
                    }

        // Check for cycles
        cout << endl << "Lockdep check:" << endl;
        for (auto [u, v] : *edges) {
            cout << "    " << u << " -> " << v << endl;
            if (u == v) {
                cout << "    \033[31m!!! Cycle detected for "
                    << u << "\033[0m" << endl;
            }
        }
    }
    ```

    lockdep.h
    ```C
    #include <thread-sync.h>

    typedef struct {
        mutex_t mutex;
        const char *name;
    } lock_t;

    #define STRINGIFY(s) #s
    #define TOSTRING(s) STRINGIFY(s)
    #define LOCK_INIT() \
        ((lock_t) { \
            .mutex = MUTEX_INIT(), \
            .name = __FILE__ ":" TOSTRING(__LINE__), \
        })

    #ifndef __cplusplus
    void lock(lock_t *lk);
    void unlock(lock_t *lk);
    #else
    extern "C" void lock(lock_t *lk);
    extern "C" void unlock(lock_t *lk);
    #endif
    ```

    main.c
    ```C
    #include <thread.h>
    #include "lockdep.h"

    lock_t lk1 = LOCK_INIT();
    lock_t lk2 = LOCK_INIT();
    lock_t lk3 = LOCK_INIT();

    struct some_object {
        lock_t lock;
        int data;
    };

    void object_init(struct some_object *obj) {
        obj->lock = LOCK_INIT();
        obj->data = 100;
    }

    void create_object() {
        struct some_object *obj = malloc(sizeof(struct some_object));
        assert(obj);
        object_init(obj);

        lock(&obj->lock);
        unlock(&obj->lock);

        free(obj);
    }

    void T_1() {
        lock(&lk1);
        lock(&lk2);
        create_object();
        unlock(&lk1);
        unlock(&lk2);
    }

    void T_2() {
        sleep(3);

        lock(&lk2);
        lock(&lk3);
        create_object();
        unlock(&lk2);
        unlock(&lk3);
    }

    void T_3() {
        sleep(6);

        lock(&lk3);
        lock(&lk1);
        create_object();
        unlock(&lk1);
        unlock(&lk3);
    }

    int main() {
        create(T_1);
        create(T_2);
        create(T_3);
    }
    ```

2. é˜²å¾¡æ€§ç¼–ç¨‹
    * Buffer Overrun æ£€æŸ¥ï¼šCanary (é‡‘ä¸é›€) â€œç‰ºç‰²â€ å†…å­˜å•å…ƒï¼Œé¢„è­¦ memory error

        ```C
        #define MAGIC 0x55555555
        #define BOTTOM (STK_SZ / sizeof(u32) - 1)
        struct stack { char data[STK_SZ]; };

        void canary_init(struct stack *s) {
            u32 *ptr = (u32 *)s;
            for (int i = 0; i < CANARY_SZ; i++)
                ptr[BOTTOM - i] = ptr[i] = MAGIC;
        }

        void canary_check(struct stack *s) {
            u32 *ptr = (u32 *)s;
            for (int i = 0; i < CANARY_SZ; i++) {
                panic_on(ptr[BOTTOM - i] != MAGIC, "underflow");
                panic_on(ptr[i] != MAGIC, "overflow");
            }
        }
        ```
    ![alt text](../img/image-10.png)

    * å¦ä¸€ç§ Canary:

        ```C
        int foo() {
            // ä¸€æ®µè¿ç»­å†…å­˜ï¼›ä½äºå±€éƒ¨å˜é‡å’Œè¿”å›åœ°å€ä¹‹å‰
            u32 canary = SOME_VALUE;

            ... // å®é™…å‡½æ•°

            canary ^= SOME_VALUE; // å¦‚æœç¨‹åºè¢«æ”»å‡»æˆ–å‡ºé”™
                                // canary å°±ä¸ä¼šå½’é›¶äº†
            assert(canary == 0);
            return ret;
        }
        ```

    * â€œçƒ«çƒ«çƒ«ã€å±¯å±¯å±¯å’Œè‘ºè‘ºè‘ºâ€çš„æ¥æºï¼š
        - æœªåˆå§‹åŒ–æ ˆ: `0xcccccccc`
        - æœªåˆå§‹åŒ–å †: `0xcdcdcdcd`
        - å¯¹è±¡å¤´å°¾: `0xfdfdfdfd`
        - å·²å›æ”¶å†…å­˜: `0xdddddddd`

        ```python
        for i in [0xcc, 0xcd, 0xdd, 0xfd]:
            print((bytes([i]) * 80).decode('gbk'))
        ```

    * ä½é…ç‰ˆ Lockdep

        ```C
        int spin_cnt = 0;
        while (xchg(&lk, âŒ) == âŒ) {
            // è‡ªæ—‹æ¬¡æ•°è¿‡å¤šï¼Œè¯´æ˜å¯èƒ½æœ‰æ­»é”
            if (spin_cnt++ > SPIN_LIMIT) {
                panic("Spin limit exceeded @ %s:%d\n",
                    __FILE__, __LINE__);
            }
        }
        ```
    
    * ä½é…ç‰ˆ AddressSanitizer

        ```C
        // allocation
        for (int i = 0; (i + 1) * sizeof(u32) <= size; i++) {
            panic_on(((u32 *)ptr)[i] == MAGIC, "double-allocation");
            arr[i] = MAGIC;
        }

        // free
        for (int i = 0; (i + 1) * sizeof(u32) <= alloc_size(ptr); i++) {
            panic_on(((u32 *)ptr)[i] == 0, "double-free");
            arr[i] = 0;
        }
        ```

    * ä½é…ç‰ˆ ThreadSanitizer

        ```C
        // Suppose x is lock-protected

        ...
        int observe1 = x;
        delay();
        int observe2 = x;
        // å¦‚æœå­˜åœ¨data raceï¼Œé‚£ä¹ˆxä¼šè¢«æ”¹å†™ï¼Œåˆ™è§¦å‘assert
        assert(observe1 == observe2);
        ...
        ```
    
    * SemanticSanitizer
        - æ£€æŸ¥æ•´æ•°æ˜¯å¦åœ¨æŸä¸ªèŒƒå›´

            ```C
            #define CHECK_INT(x, cond) \
                ({ panic_on(!((x) cond), \
                "int check fail: " \
                #x " " #cond); \
                })

            // Example:
            CHECK_INT(waitlist->count, >= 0);
            ```
        
        - æ£€æŸ¥æŒ‡é’ˆæ˜¯å¦ä½äºå †åŒº

            ```C
            #define CHECK_HEAP(ptr) \
                ({ panic_on(!IN_RANGE((ptr), heap)); })
            ```
    
    