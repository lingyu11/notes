# 虚拟化

## Lecture 14 操作系统上的进程
!!! abstract "Take-away Messages"

    因为 “程序 = 状态机”，操作系统上进程 (运行的程序) 管理的 API 很自然地就是状态机的管理。在 UNIX/Linux 世界中，以下三个系统调用创建了整个 “进程世界”，不论是我们常用的 IDE 和浏览器，还是编译时在后台调用的 gcc。其中：
    
    * fork: 对当前状态机状态进行完整复制
    * execve: 将当前状态机状态重置为某个可执行文件描述的状态机
    * exit: 销毁当前状态机
        
    在对这个概念有了绝对正确且绝对严谨的理解后，操作系统也就显得不那么神秘了。

1. fork: 创建状态机。做一份状态机完整的复制 (内存、寄存器现场)。
    ```C
    pid_t fork(void);
    ```

    fork() 的行为

    * 立即复制状态机
        - 包括所有信息的完整拷贝
            + 每一个字节的内存
            + 打开的文件 (共享)
            + ……
            + 复制失败返回 -1
                + errno 会返回错误原因 (man fork)

    * 如何区分两个状态机？
        * 新创建进程：得到的返回值是 0
        * 执行 fork 的父进程：得到的返回值是子进程的进程号

2. 阅读以下程序，写出运行结果
    ```C
    pid_t x = fork();
    pid_t y = fork();
    printf("%d %d\n", x, y);
    ```

    输出：
    ```bash
    19489 19490
    19489 0
    0 19491
    0 0
    ```
    ![alt text](../img/image-11.png)

    ```C
    for (int i = 0; i < 2; i++) {
        fork();
        printf("Hello\n");
    }
    ```
    输出：6个Hello
    ```C
    Hello
    Hello
    Hello
    Hello
    Hello
    Hello
    ```

    程序等价于：
    ```C
    fork();
    printf("Hello\n");
    fork();
    printf("Hello\n");
    ```
    ![alt text](../img/image-12.png)

    然而，`./demo-2 | wc -l`输出的是`8`。原因：在终端里换行打印时使用的是line buffer，此时打印6个；重定向到文件或使用管道时使用的是full buffer，此时会打印8个，没有刷新buffer，导致所有带有值的buffer也被fork了。`man setbuf`可以看到有三种模式`_IONBF unbuffered`/`_IOLBF line buffered`/`_IOFBF fully buffered`。
    此时程序等价于：
    ```C
    fork();
    buf += "Hello";
    fork();
    buf += "Hello";
    flush(buf);
    ```
    ![alt text](../img/image-13.png)

3. execve：重置状态机。将当前进程重置成一个可执行文件描述状态机的初始状态。

    ```C
    int execve(const char *filename,
               char * const argv[], char * const envp[]);
    // 三个参数：可执行文件的路径、传递给 main 函数的参数和环境变量。
    ```
    execve 行为

    * 执行名为 `filename` 的程序
    * 允许对新状态机设置参数 `argv` (v) 和环境变量 `envp` (e)
        - 刚好对应了 `main()` 的参数！
    * execve 是唯一能够 “执行程序” 的系统调用
        - 因此也是一切进程 strace 的第一个系统调用

4. UNIX 中实现 “创建新状态机” 的方式：fork + execve （相当于spawn）
    ```C
    int pid = fork();
    if (pid == -1) {
        // fork失败
        perror("fork"); goto fail;
    } else if (pid == 0) {
        // Child
        execve(...);
        // 如果 execve 成功执行，它将替换当前进程的内存空间并开始执行新的程序，
        // 因此 perror("execve") 不会被执行。perror("execve") 只会在 execve
        // 调用失败时执行
        perror("execve"); goto fail;
    } else {
        // Parent
        ...
    }
    ```

    demo:
    ```C
    #include <unistd.h>
    #include <stdio.h>

    int main() {
        char *const argv[] = {
            "/bin/bash",
            "-c",
            "env",
            NULL,
        };

        char *const envp[] = {
            "HELLO=WORLD",
            NULL,
        };

        // Reset the state machine to "/bin/bash"
        execve(argv[0], argv, envp);

        // We are here only on error.
        printf("Hello, World!\n");
    }
    ```
    输出：
    ```bash
    PWD=/home/user/jyy_os_2024/lecture/lect14/execve-demo
    HELLO=WORLD
    SHLVL=0
    _=/usr/bin/env
    ```
    这比直接在bash里执行`/bin/bash -c env`得到的一大堆输出更加简单，是因为我们在代码里的环境变量evnp只保留了`HELLO=WORLD`（当然实际上执行execve还是有PWD/SHLVL等被加上的环境变量）。

5. _exit()：销毁状态机。立即摧毁状态机，允许有一个返回值。子进程终止会通知父进程。
    ```C
    void _exit(int status);
    ```

    结束程序执行的三种方法

    * exit(0)
        - provided by libc
        - 会调用 atexit
    * _exit(0)
        - 执行 “exit_group” 系统调用终止整个进程 (所有线程)
        - 不会调用 atexit 
    * syscall(SYS_exit, 0)
        - 执行 “exit” 系统调用终止当前线程
        - 不会调用 atexit（libc当然不了解系统调用，也就无法在退出时调用libc的atexit函数）

## Lecture 15 进程的地址空间
!!! abstract "Take-away Messages"

    状态机的视角自然地将我们引入 “内存到底是什么” 的问题——它的答案同样也很自然：带有访问权限控制的连续内存段。我们可以通过 <span style="color:blue;">mmap、munmap、mprotect</span> 三个系统调用调整状态机的地址空间，包括分配匿名的内存、映射文件内容到内存、修改访问权限等（增/删/改）。更有趣的是操作系统有 “能够实现一切应用程序” 的需求，调试器也不在话下——这也给了我们入侵其他进程地址空间的机制。

1. 以下程序的 (可能) 输出是什么？
    ```C
    int main()
    {
        int x = *(int *)main;
        printf("%x\n", x);    // fa1e0ff3（小端）
        printf("%p\n", main); //0x556b3315c149，每次不一样
    }
    ```

    ```bash
    objdump -d a.out
    0000000000001149 <main>:
    1149:       f3 0f 1e fa             endbr64 
    114d:       55                      push   %rbp
    114e:       48 89 e5                mov    %rsp,%rbp
    1151:       48 83 ec 10             sub    $0x10,%rsp
    ...
    ```
2. 查看进程的地址空间：

    * /proc/[pid]/maps

        ```bash
        linux$ ps
        PID TTY          TIME CMD
        18222 pts/3    00:00:00 dbus-launch
        22713 pts/3    00:00:01 bash
        29368 pts/3    00:00:00 ps
        linux$ vi /proc/22713/maps
        55e7a0632000-55e7a0711000 r-xp 0002f000 08:20 1241                       /usr/bin/bash
        55e7a0711000-55e7a074b000 r--p 0010e000 08:20 1241                       /usr/bin/bash
        55e7a074c000-55e7a0750000 r--p 00148000 08:20 1241                       /usr/bin/bash
        55e7a0750000-55e7a0759000 rw-p 0014c000 08:20 1241                       /usr/bin/bash
        ...
        7ffdf9eb0000-7ffdf9ed2000 rw-p 00000000 00:00 0                          [stack]
        7ffdf9f79000-7ffdf9f7d000 r--p 00000000 00:00 0                          [vvar]
        7ffdf9f7d000-7ffdf9f7f000 r-xp 00000000 00:00 0                          [vdso]
        ```

        无需陷入内核的系统调用: vvar (data)/vdso (code)。例如时间这样的数据，只有操作系统有，而应用程序只是读时间戳，不会改它，对于这样只读的数据，无需进入操作系统内核。因此，**操作系统里只读的数据可以通过内存的方式共享给进程**。

    * pmap [pid]

        ```bash
        linux$ pmap 22713
        22713:   /bin/bash
        000055e7a0603000    188K r---- bash
        000055e7a0632000    892K r-x-- bash
        000055e7a0711000    232K r---- bash
        000055e7a074c000     16K r---- bash
        000055e7a0750000     36K rw--- bash
        000055e7a0759000     44K rw---   [ anon ]
        000055e7a1dbc000   1832K rw---   [ anon ]
        ...
        ```

    * gdb cmd: `info proc mappings`

3. 管理进程地址空间：在状态机状态上增加/删除/修改一段可访问的内存

    ```C
    // 映射
    void *mmap(void *addr, size_t length, int prot, int flags,
               int fd, off_t offset);
    int munmap(void *addr, size_t length);

    // 修改映射权限
    int mprotect(void *addr, size_t length, int prot);
    ```

    例子：

    ```C
    #include <unistd.h>
    #include <stdint.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <sys/mman.h>

    #define GiB * (1024LL * 1024 * 1024)

    int main() {
        volatile uint8_t *p = mmap(
            NULL,
            8 GiB,
            PROT_READ | PROT_WRITE,
            MAP_ANONYMOUS | MAP_PRIVATE,
            -1, 0
        );

        printf("mmap: %lx\n", (uintptr_t)p);

        if ((intptr_t)p == -1) {
            perror("cannot map");
            exit(1);
        }

        *(p + 2 GiB) = 1;
        *(p + 4 GiB) = 2;
        *(p + 7 GiB) = 3;
        printf("Read get: %d\n", *(p + 4 GiB));
        printf("Read get: %d\n", *(p + 6 GiB));
        printf("Read get: %d\n", *(p + 7 GiB));
    }
    ```

    ```python
    import hexdump
    import mmap

    with open('/dev/sda', 'rb') as fp:
        mm = mmap.mmap(fp.fileno(),
                    prot=mmap.PROT_READ, length=128 << 30)
        hexdump.hexdump(mm[:512]) # 将磁盘sda的128GiB映射到内存，并查看前512字节
    ```
4. 入侵进程地址空间

    * 调试器 (gdb)
        - gdb 可以任意观测和修改程序的状态
    * Profiler (perf)
        - M3 中借助它理解程序的性能瓶颈

    例子：金山游侠

    * 地址空间那么大，哪个才是 “金钱”？
        - 包含动态分配的内存，每次地址都不一样
        - 思路：Everything is a state machine
            + 观察状态机的 trace，就知道哪个是金钱了

    * 查找 + Filter
        - 进入游戏时 exp = 4950
        - 打了个怪 exp = 5100
        - 符合 4950 → 5100 变化的内存地址是很少的
            + 好了，出门就是满级了

    knight.c: `sudo ./knight VirtualBoxVM` -> `s 5000` -> spend 800 -> `s 4200` -> `w 1000000`
    ```C
    #include <string>
    #include <vector>
    #include <algorithm>
    #include <iostream>
    #include <regex>
    #include <cstdio>
    #include <unistd.h>
    #include <fcntl.h>
    using std::string, std::to_string;

    struct Game {
        string name; // Name of the traced process
        int pid;     // Pid of the traced process
        int fd;      // Memory file of the traced process
        
        std::vector<uintptr_t> remain; // Watched addresses

    public:
        Game(string proc_name):
            name(proc_name),
            pid(stoi(run("pidof " + proc_name))) {

            // See: proc(5)
            string memfile = "/proc/" + to_string(pid) + "/mem";

            // We need root permission to open this file;
            // otherwise it would be too dangerous.
            fd = open(memfile.c_str(), O_RDWR);
            if (fd < 0) {
                perror(memfile.c_str());
                exit(1);
            }
        }

        ~Game() {
            close(fd);
        }

        void search_for(uint32_t val) {
            if (remain.size() == 0) {
                // No match. Start a new round of search.

                string maps = run("pmap -x " + to_string(pid));

                std::regex r(
                    R"(^([0-9a-f]+)\s+(\d+)\s+(\d+)\s+(\d+)\s+rw.*)"
                );

                std::istringstream iss(maps);
                for (string line; std::getline(iss, line); ) {
                    std::smatch match;
                    if (std::regex_search(line, match, r)) {
                        uintptr_t start = stoll(match[1].str(), nullptr, 16);
                        uintptr_t size = stoll(match[2], nullptr, 10) * 1024;
                        printf("Scanning %lx--%lx\n", start, start + size);

                        // Copy process memory to local
                        std::unique_ptr<uint32_t[]> mem(new uint32_t [size / 4]);
                        lseek(fd, start, SEEK_SET);
                        size = read(fd, mem.get(), size);

                        for (uintptr_t off = 0; off < size; off += 4) {
                            if (mem[off / 4] == val) {
                                // Found a match!
                                remain.push_back(start + off);
                            }
                        }
                    }
                }
            } else {
                // Search in the watched values.

                std::erase_if(remain, [this, val](uintptr_t addr) {
                    return load(addr) != val;
                });
            }
            printf("There are %ld match(es).\n", remain.size());
        }

        void reset() {
            remain.clear();
        }

        void overwrite(uint32_t val) {
            int nwrite = 0;
            for (uintptr_t addr : remain) {
                store(addr, val);
                nwrite++;
            }
            printf("%d value(s) written.\n", nwrite);
        }

    private:
        uint32_t load(uintptr_t addr) {
            // Load 32-bit value from another address space
            uint32_t val;
            lseek(fd, addr, SEEK_SET);
            read(fd, &val, sizeof(val));
            return val;
        }

        void store(uintptr_t addr, uint32_t val) {
            // Store 32-bit value to another address space
            lseek(fd, addr, SEEK_SET);
            write(fd, &val, sizeof(val));
        }

        static string run(const string &cmd) {
            std::array<char,128> buf;
            string result;

            FILE *pipe = popen(cmd.c_str(), "r");
            if (!pipe) {
                perror(cmd.c_str());
                exit(1);
            }

            while (fgets(buf.data(), buf.size(), pipe) != nullptr) {
                result += buf.data();
            }

            pclose(pipe);
            return result;
        }
    };


    int main(int argc, char *argv[]) {
        Game g(argv[1]);
        uint32_t val;
        char buf[64];

        printf(
            "Usage:\n"
            "  - s 100: search for value\n"
            "  - w 99999: overwrite value (for search matches)\n"
            "  - r: reset search\n\n"
        );

        while (!feof(stdin)) {
            printf("(%s %d) ", g.name.c_str(), g.pid);
            scanf("%s", buf);

            switch (buf[0]) {
                case 'q': return 0;
                case 's': scanf("%d", &val); g.search_for(val); break;
                case 'w': scanf("%d", &val); g.overwrite(val); break;
                case 'r': g.reset(); break;
            }
        }
    }
    ```

5. 给进程发送 GUI (键盘/鼠标)事件

    * 做个驱动 (可编程键盘/鼠标)
    * 利用操作系统/窗口管理器提供的 API
        - xdotool
        - ydotool
        - evdev (按键显示脚本；主播常用)
    
    例子：实现按键精灵，实现按键精灵不必入侵进程的地址空间。操作系统管理了 I/O 设备，我们相应模拟出按键的事件即可。当然，我们也可以为进程像游戏修改器那样注入按键事件。

    `sudo ./anjian`，then open https://js13kgames.com/games/spacebar-clicker/index.html
    ```bash
    #!/bin/bash

    # Needs sudo. Try:
    # https://js13kgames.com/games/spacebar-clicker/index.html

    echo 'Start in 5 seconds...'
    ydotoold &> /dev/null &
    sleep 5

    for _ in $(seq 1 200)
    do
        ydotool type ' '
        sleep 0.01
    done
    ```

6. 改变进程对时间的感知

    程序 = 状态机
    
    * “计算指令” 是不能感知时间的
        - spin count 计时会出现 “机器变快，游戏没法玩” 的情况
        - syscall 是感知时间的唯一方法
    
    * “劫持” 和时间相关的 syscall/库函数
        - 改变程序对时间的认知
        - 就像手表调快/慢了一样

    例子：变速齿轮 `./gear 10 tetris`

    gear：实际上就是个python脚本，调用 gdb 调试 tetris 游戏，劫持 gettimeofday 系统调用，实现变速齿轮。
    ```python
    #!/usr/bin/env python3

    import subprocess
    import sys

    try:
        ratio, exe = sys.argv[1:]
    except:
        print(f'Example: {sys.argv[0]} 10 tetris  # 10X speedup')
        exit(1)

    subprocess.run(
        [
            'gdb',
            '-ex', f'set $gear_ratio = {ratio}',
            '-x', 'gear-gdb.py',
            exe,
        ]
    )
    ```

    ```python
    import gdb
    import datetime

    ratio = float(gdb.parse_and_eval('$gear_ratio'))

    # Get the current time
    start = datetime.datetime.now()

    def hacked_time():
        now = datetime.datetime.now()
        
        # The speed of the clock is adjusted
        t = start + (now - start) * ratio

        tv_sec = int(t.timestamp())
        tv_usec = t.microsecond
        return (tv_sec, tv_usec)

    class SetTimevalBreakpoint(gdb.Breakpoint):
        def __init__(self):
            super(SetTimevalBreakpoint, self).__init__(
                'gettimeofday',
                gdb.BP_BREAKPOINT,
                internal=False
            )

        def stop(self):
            tv_sec, tv_usec = hacked_time()

            # Replace the function body
            gdb.execute(
                'set *(struct timeval *)($rdi) = {{ {}, {} }}'
                    .format(tv_sec, tv_usec)
            )
            gdb.execute('set $rax = 0')
            gdb.execute('return')

            return False  # Continue execution

    SetTimevalBreakpoint()
    gdb.execute('run')
    ```

7. 软件动态更新：我们可以通过 patch 函数的头部为一个跳转实现对一个函数的 “运行时热更新”。

    ```C
    #include <stdio.h>
    #include <string.h>
    #include <sys/mman.h>
    #include <stdint.h>
    #include <assert.h>

    __attribute__((noinline)) void foo() {
        printf("In old function %s\n", __func__);
    }

    __attribute__((noinline)) void foo_new() {
        printf("In new function %s\n", __func__);
    }

    // 48 b8 (64-bit imm)   movabs $imm,%rax
    // ff e0                jmpq   *%rax
    const char PATCH[] = "\x48\xb8--------\xff\xe0";

    void DSU(void *func, void *func_new) {
        int flag = PROT_WRITE | PROT_READ | PROT_EXEC, rc, np;

        // Grant write permission to the memory
        // We must handle boundary cases
        uintptr_t fn = (uintptr_t)func;
        uintptr_t base = fn & ~0xfff;
        if (fn + sizeof(PATCH) > base + 4096) {
            np = 2;  // Cross page boundary
        } else {
            np = 1;
        }
        printf("np = %d\n", np);

        rc = mprotect((void *)base, np * 4096, flag);
        assert(rc == 0);  // Not expecting a failure
    
        // Patch the first instruction (this is UB in C spec)
        memcpy(func, PATCH, sizeof(PATCH));
        memcpy((char *)func + 2, &func_new, sizeof(func_new));

        // Revoke the write permission
        rc = mprotect((void *)base, np * 4096, PROT_READ | PROT_EXEC);
        assert(rc == 0);  // Not expecting a failure
    }

    int main() {
        setbuf(stdout, NULL);
        foo();
        DSU(foo, foo_new);  // Dynamic software update
        foo();
    }
    ```

## Lecture 16 系统调用和UNIX Shell
!!! abstract "Take-away Messages"

    通过 freestanding 的 shell，我们阐释了 “可以在系统调用上创建整个操作系统应用世界” 的真正含义：操作系统的 API 和应用程序是互相成就、螺旋生长的：有了新的应用需求，就有了新的操作系统功能。而 UNIX 为我们提供了一个非常精简、稳定的接口 (fork, execve, exit, pipe ,...)，纵然有沉重的历史负担，它在今天依然工作得很好。

1. 操作系统对象：

    * 进程和地址空间
        - 进程管理：fork, execve, exit
        - 内存管理：mmap, munmap, mprotect
    * 文件和设备
        - 文件：有 “名字” 的对象，例如字节流 (终端) 或字节序列 (普通文件；包括 /proc/*)
        - 文件描述符 (file descriptor，Windows中叫handle句柄)：<span style="color:blue;">指向操作系统对象的 “指针”</span>
        - Everything is a file，通过指针可以访问 “一切”
        - 对象的访问都需要指针：open, close, read/write (解引用), lseek (指针内赋值/运算), dup (指针间赋值)
    * IPC Endpoints (Inter-Process Communication，进程间通信)
        - 管道：一个特殊的 “文件” (流)
            + 由读者/写者共享
            + 读口：支持 read `fd[0]`
            + 写口：支持 write `fd[1]`
        - 匿名管道
            + 返回两个文件描述符
            + 进程同时拥有读口和写口
        ```C
        int pipe(int pipefd[2]);
        ```

2. 文件描述符是一个用于访问文件或其他输入/输出资源的 “指针”。在 Unix 和类 Unix 操作系统中，文件描述符是一个非负整数，用于表示一个打开的文件、管道、网络连接或其他类似的资源。当一个程序打开一个文件或创建一个数据流时，操作系统会返回一个文件描述符，程序可以通过这个描述符来读取、写入或操作对应的文件或资源。

    ```C
    #include <stdio.h>
    #include <fcntl.h>
    #include <unistd.h>

    void try_open(const char *fname) {
        int fd = open(fname, O_RDWR);
        // fd is a "pointer" to a kernel object.

        printf("open(\"%s\") = %d\n", fname, fd);

        if (fd < 0) {
            perror(fname);
            goto release;
        } else {
            // ...
        }

    release:
        if (fd >= 0) {
            close(fd);
        }
    }

    int main() {
        try_open("/something/not/exist");
        try_open("/dev/sda"); // hard drive
    }
    ```

3. UNIX 管道 (pipe) 是一种典型的进程间通信机制，允许数据在不同的进程之间单向流动。管道可以被视为一种特殊的文件，其中一个进程将数据写入管道的一端，而另一个进程从另一端读取数据。

    * pipe read 在没有数据时会等待
    * pipe write 在有读者打开时，会写入操作系统的缓冲区并返回
    * write 如果 “不太多”，一对 write-read 是原子的
    * write 如果超过 PIPE_BUF，可能会被拆成多份
    * 如果读者关闭，会收到 SIGPIPE 信号
        - 经常看到的 “Broken Pipe”
    * “看不到” 的 SIGPIPE
        - `yes | head -n 1`
        - `(yes; echo $? > /dev/stderr) | head -n 1` (返回141而非0，所以实际上还是有SIGPIPE发生)
    * “看得到” 的 SIGPIPE
        - `python3 -c 'while True: print(1)' | head -n 1`

    ![alt text](../img/image-14.png)

    named_pipe.c:
    ```C
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <fcntl.h>
    #include <sys/stat.h>
    #include <unistd.h>
    #include <errno.h>

    // We also have UNIX domain sockets for local inter-process
    // communication--they also have a name in the file system
    // like "/var/run/docker.sock". This is similar to a named
    // pipe.
    #define PIPE_NAME "/tmp/my_pipe"

    void pipe_read() {
        int fd = open(PIPE_NAME, O_RDONLY);
        char buffer[1024];

        if (fd == -1) {
            perror("open");
            exit(1);
        }

        // Read from the pipe
        int num_read = read(fd, buffer, sizeof(buffer));
        if (num_read > 0) {
            printf("Received: %s\n", buffer);
        } else {
            printf("No data received.\n");
        }
        close(fd);
    }

    void pipe_write(const char *content) {
        // Open the pipe for writing
        int fd = open(PIPE_NAME, O_WRONLY);

        if (fd == -1) {
            perror("open");
            exit(1);
        }

        // Write the message to the pipe
        write(fd, content, strlen(content) + 1);
        close(fd);
    }

    int main(int argc, char *argv[]) {
        if (argc < 2) {
            fprintf(stderr, "Usage: %s read|write [message]\n", argv[0]);
            return 1;
        }

        // Create the named pipe if it does not exist
        if (mkfifo(PIPE_NAME, 0666) == -1) {
            if (errno != EEXIST) {
                perror("mkfifo");
                return 1;
            }
        } else {
            printf("Created " PIPE_NAME "\n");
        }

        if (strcmp(argv[1], "read") == 0) {
            pipe_read();
        } else if (strcmp(argv[1], "write") == 0) {
            pipe_write(argv[2]);
        } else {
            fprintf(stderr, "Invalid command. Use 'read' or 'write'.\n");
            return 1;
        }

        return 0;
    }
    ```

    anonymous-pipe.c：父进程持有写口，子进程持有读口。
    ```C
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <string.h>
    #include <sys/wait.h>

    void do_parent(int fd) {
        const char *msg = "Hello, world!";

        printf("[%d] Write: '%s'\n", getpid(), msg);
        write(fd, msg, strlen(msg) + 1);

        close(fd);

        // Wait for the child to finish
        wait(NULL);

        printf("[%d] Done.\n", getpid());
    }

    void do_child(int fd) {
        static char buf[1024];

        ssize_t num_read = read(fd, buf, sizeof(buf));
        if (num_read == -1) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        printf("[%d] Got: '%s'\n", getpid(), buf);

        // Close the read end of the pipe
        close(fd);
    }

    int main() {
        int pipefd[2];

        // Create a pipe
        if (pipe(pipefd) == -1) {
            perror("pipe");
            exit(EXIT_FAILURE);
        }

        // Fork the current process
        pid_t pid = fork();
        if (pid == -1) {
            perror("fork");
            exit(EXIT_FAILURE);
        }

        if (pid == 0) {
            // Child
            close(pipefd[1]); // Close unused write end
            do_child(pipefd[0]);
        } else {
            // Parent
            close(pipefd[0]); // Close unused read end
            do_parent(pipefd[1]);
        }

        return 0;
    }
    ```

4. sh.c debug：可以清楚地看到，进程3的标准输出`1`向管道里写数据，然后执行`runcmd(pcmd->left);`进程4的标准输入`0`从管道里读数据，然后执行`runcmd(pcmd->right);`


    ```bash
    Process 3 (11026)
    0 <-> /dev/pts/7
    1 --> [=== 2123156 ===]
    2 <-> /dev/pts/7

    Process 4 (11699)*
        0 <-- [=== 2123156 ===]
        1 <-> /dev/pts/7
        2 <-> /dev/pts/7

    112                 runcmd(pcmd->right);
    ```

5. 以下报错的原因：`>`和`|`一样，都是先把两边的文件描述符准备好，也就是说`sudo echo hello`和打开`/etc/a.txt`是分开执行的，因此无权限打开`/etc/a.txt`

    ```bash
    $ echo hello > /etc/a.txt
    bash: /etc/a.txt: Permission denied

    $ sudo echo hello > /etc/a.txt
    bash: /etc/a.txt: Permission denied
    ```

## Lecture 17 C 标准库和实现
!!! abstract "Take-away Messages"

    在系统调用和语言机制的基础上，libc 为我们提供了开发跨平台应用程序的 “第一级抽象”。在此基础上构建起了万千世界：C++ (扩充了 C 标准库)、Java、浏览器世界……今天，C 语言在应用开发方面有很多缺陷，但仍然为 “第一级抽象” 提供了一个有趣的范本。

1. C里的 `_start` 函数是程序执行的起点。当一个C程序被编译和链接成可执行文件后，操作系统会将程序加载到内存中，并跳转到 `_start` 函数开始执行。`_start` 函数通常是由编译器和链接器自动生成的，它负责初始化程序运行所需的环境，然后调用 `main` 函数。也就是说，`_start`函数是操作系统和二进制文件之间的约定（在libc里的Scrt1.o会帮忙定义好）。以下可以看到Entry point address是0x4019f5，正是`_start`的地址。

    ```bash
    linux$ readelf -h sh
    ELF Header:
    Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
    Class:                             ELF64
    Data:                              2's complement, little endian
    Version:                           1 (current)
    OS/ABI:                            UNIX - System V
    ABI Version:                       0
    Type:                              EXEC (Executable file)
    Machine:                           Advanced Micro Devices X86-64
    Version:                           0x1
    Entry point address:               0x4019f5
    Start of program headers:          64 (bytes into file)
    Start of section headers:          23696 (bytes into file)
    Flags:                             0x0
    Size of this header:               64 (bytes)
    Size of program headers:           56 (bytes)
    Number of program headers:         8
    Size of section headers:           64 (bytes)
    Number of section headers:         19
    Section header string table index: 18

    linux$ objdump -d sh | less
    00000000004019f5 <_start>:
    4019f5:       f3 0f 1e fa             endbr64 
    4019f9:       55                      push   %rbp
    4019fa:       48 89 e5                mov    %rsp,%rbp
    4019fd:       b8 00 00 00 00          mov    $0x0,%eax
    401a02:       e8 e9 fe ff ff          call   4018f0 <main>
    401a07:       be 00 00 00 00          mov    $0x0,%esi
    401a0c:       bf 3c 00 00 00          mov    $0x3c,%edi
    401a11:       b8 00 00 00 00          mov    $0x0,%eax
    401a16:       e8 e5 f5 ff ff          call   401000 <syscall>
    401a1b:       90                      nop
    401a1c:       5d                      pop    %rbp
    401a1d:       c3                      ret
    ```

2. <span style="color:blue;">系统调用是地基，C 语言是框架。</span>glibc 的代码有非常沉重的历史包袱，更适合学习的 libc 实现：[musl libc](https://musl.libc.org/)

    使用musl-gcc来编译，而不是gcc，看下musl-gcc的真面目：musl-gcc通过.specs脚本来控制编译器不要链接glibc而是链接自己的libc。
    
    ```bash
    linux$ cat (which musl-gcc)
    #!/bin/sh
    exec "${REALGCC:-x86_64-linux-gnu-gcc}" "$@" -specs "/usr/lib/x86_64-linux-musl/musl-gcc.specs"
    ```

3. debug dummy.c

    ```C
    int main() {
        return 1;
    }
    ```

    <figure markdown> 
        ![Image title](../img/image-15.png){ width="300" }
        <figcaption>操作系统将这些内容放入栈中</figcaption>
    </figure>

    env.c：

    ```C
    #include <stdio.h>

    // A mysteriously defined symbol.
    // Someone must defined it elsewhere.
    extern char **environ;

    // Like this even more mysterious one.
    // "end" can be of any type.
    extern void ******************************end;

    int main(int argc, char *argv[], char *envp[]) {
        printf("environ: %p\n", environ);
        printf("envp:    %p\n", envp);

        for (char **env = environ; *env; env++) {
            // key=value
            printf("%s\n", *env);
        }

        end = NULL; // ???
    }
    ```

    输出:

    ```bash
    environ: 0x7ffdb556d2d8
    envp:    0x7ffdb556d2d8
    SHELL=/bin/bash
    COLORTERM=truecolor
    ...
    ```

    <a id="system-v-abi"></a>
    [System V ABI](https://jyywiki.cn/OS/manuals/sysv-abi.pdf)里定义了规范：

    ![alt text](../img/image-16.png){ width="500" }

    其他状态 (主要是内存) 则是由可执行文件指定，详情看[Lecture 19](#minimal-loader)。

4. libc对系统调用与环境的抽象

    什么是stdout？

    ```C
    static unsigned char buf[BUFSIZ+UNGET];
    hidden FILE __stdout_FILE = {
        .buf = buf+UNGET,
        .buf_size = sizeof buf-UNGET,
        .fd = 1,
        .flags = F_PERM | F_NORD,
        .lbf = '\n',
        .write = __stdout_write,
        .seek = __stdio_seek,
        .close = __stdio_close,
        .lock = -1,
    };
    FILE *const stdout = &__stdout_FILE;
    ```

5. 所有 API 都可能失败，errno 是进程共享还是线程独享？➡️ 线程独享，gdb调试可以看到errno是tls (Thread Local Storage)的。

6. malloc() 的观察：我们需要管理的对象
    * 小对象：字符串、临时对象等；生存周期可长可短
    * 中对象：容器、复杂的对象；更长的生存周期
    * 大对象：巨大的容器、分配器；很长的生存周期

    设置两套系统：

    * Fast path (System I)
        - 性能极好、并行度极高、覆盖大部分情况
        - 但有小概率会失败 (fall back to slow path)
    * Slow path (System II)
        - 不在乎那么快
        - 但把困难的事情做好
    * 计算机系统里有很多这样的例子 (比如 cache)

    malloc: Fast Path 设计 ➡️ 立即在线程本地分配完成。浪费一点空间，但使所有 CPU 都能并行地申请内存
    
    * 线程都事先瓜分一些 “领地” (thread-local allocation buffer)
    * 默认从自己的领地里分配
        - 除了在另一个 CPU 释放，acquire lock 几乎总是成功
    * 如果自己的领地不足，就从全局的池子里借一点

    malloc: Slow Path 设计 ➡️ pgalloc()

7. 如何调试进入 musl libc

    ```bash
    tar -xzf musl-1.2.5.tar.gz  # 解压后进入
    cd musl-1.2.5
    ./configure --enable-debug  # 这步是关键!
    make && make install        # 编译并安装到 /usr/local/musl
    echo 'export PATH="/usr/local/musl/bin:$PATH"' >>  ~/.bashrc
    source ~/.bashrc            # 修改环境变量 path 并生效
    ```

## Lecture 18 Linux 操作系统
!!! abstract "Take-away Messages"

    我们从 CPU Reset 后的 “硬件初始状态” 到操作系统加载完 init 进程后的 “软件初始状态”，从此以后，计算机系统中的一切都是由应用程序主导的，操作系统只是提供系统调用这一服务接口。正是系统调用 (包括操作系统中的对象) 这个稳定的、向后兼容的接口随着历史演化和积累，形成了难以逾越的技术屏障，在颠覆性的技术革新到来之前，另起炉灶都是非常困难的。

1. 启动 Linux - Initial RAM FS

    硬件 (ISA) → 操作系统对象/系统调用 → libc → 系统工具 (coretuils, busybox, ...) → 应用程序 (xfce, vscode)

    ```bash
    make initramfs # 需要/boot/vmlinuz，wsl里没有，就没有做下去了
    make
    make run
    /bin/busybox ls
    ```

    ```bash
    exec switch_root /newroot/ /init
    # switch_root 程序首先将当前的根文件系统（initramfs）卸载。
    # 然后，它将新根文件系统（/newroot/）挂载到 / 目录。
    # 接下来，它执行新根文件系统中的初始化程序 /init，以启动系统的初始化进程。
    # 最后，当前的 shell 进程被替换为新的初始化进程，系统继续启动。
    # (exec：这是一个 shell 内置命令，用于执行指定的命令并替换当前的 shell 进程。)
    ```

    最小 Linux: 我们可以在 initramfs 中放置任意的数据——包括应用程序、内核模块 (驱动)、数据、脚本……操作系统世界已经开始运转；但直到执行 switch_root (pivot_root) (注意调用switch_root的pid必须是1)，才真正开始 今天 Linux 应用世界 (systemd) 的启动。

    ```bash
    linux$ ls /sbin/init # 现代的Linux启动用的是/sbin/init
    lrwxrwxrwx /sbin/init -> /lib/systemd/systemd
    ```

2. Initramfs: 并不是我们实际看到的 Linux

    启动的初级阶段

    * 加载剩余必要的驱动程序，例如磁盘/网卡
    * 挂载必要的文件系统
    * 将根文件系统和控制权移交给另一个程序，例如 systemd (system and service manager)

    启动的第二级阶段

    * 看一看系统里的 /sbin/init 是什么？
    * 计算机系统没有魔法 (一切都有合适的解释)
        - pstree 埋下的伏笔得到解答：pstree输出的根是systemd

    ```bash
    linux$ pstree
    systemd─┬─.vasd───.vasd───4*[.vasd]
            ├─ModemManager───2*[{ModemManager}]
            ├─NetworkManager───2*[{NetworkManager}]
            ├─accounts-daemon───2*[{accounts-daemon}]
            ├─acpid
            ├─at-spi-bus-laun─┬─dbus-daemon
            │                 └─3*[{at-spi-bus-laun}]
            ├─at-spi2-registr───2*[{at-spi2-registr}]
            ├─avahi-daemon───avahi-daemon
            ├─colord───2*[{colord}]
            ├─containerd───11*[{containerd}]
            ├─containerd-shim─┬─dumb-init─┬─bash───Xvfb
            │                 │           ├─2*[conhost.exe]
            │                 │           ├─...
            │                 │           └─wineserver
            │                 └─12*[{containerd-shim}]
            ├─containerd-shim─┬─dumb-init─┬─bash───Xvfb
            │                 │           └─mount.ntfs
            │                 └─12*[{containerd-shim}]
            ├─3*[containerd-shim─┬─dumb-init─┬─bash───Xvfb]
            │                    │           └─mount.ntfs]
            │                    └─11*[{containerd-shim}]]
            ├─cron
            ├...
            └─xrdp-sesman
    ```


## Lecture 19 可执行文件和加载
!!! abstract "Take-away Messages"

    可执行文件是一个描述状态机初始状态的数据结构 (字节序列)；加载器就是把这个 “初始状态” 搬运到操作系统中的程序。用数据结构的眼光看可执行文件，就不难发现它不好阅读的原因：它的设计者并没有打算让你阅读它。这样的难题在《操作系统》课程中经常出现；而我们的应对方法是先理解一个粗糙但重要的模型，然后在此基础上理解工业级实现面临的挑战和问题。

1. 什么是可执行文件？➡️ 进程初始状态的描述

    * 一个操作系统中的对象 (文件)
    * 一个字节序列 (我们可以把它当字符串编辑)
    * 一个描述了状态机初始状态的数据结构

    ELF: Executable and Linkable Format，[binutils](https://www.gnu.org/software/binutils/) 中的工具可以让我们查看其中的重要信息

2. UNIX a.out ➡️ “assembler output”
    
    以前的版本：一个相对平坦的数据结构

    ```C
    struct exec {
        uint32_t  a_midmag;  // Machine ID & Magic
        uint32_t  a_text;    // Text segment size
        uint32_t  a_data;    // Data segment size
        uint32_t  a_bss;     // BSS segment size (存储未初始化的全局变量和静态变量)
        uint32_t  a_syms;    // Symbol table size
        uint32_t  a_entry;   // Entry point
        uint32_t  a_trsize;  // Text reloc table size
        uint32_t  a_drsize;  // Data reloc table size
    };
    ```

3. Funny Linkable Executable

    核心设计思路

    * 一切都对人类直接可读 (所有信息都在局部)
    * 回归链接和加载中的核心概念：<span style="color:blue;">代码、符号、重定位</span> (多个文件链接起来必需符号、重定位。符号：main函数里一个global的变量x，别人可以用它；重定位：我用了一个变量x，是别人定义的)

    代码 (🔢)、符号 (📤)、重定位 (❓)：凑齐这三要素，我们就可以做可执行文件了！

    ```C
    🔢: ff ff ff ff ff ff ff
    🔢: ff ff ff ff ff ff ff
    📤: _start
    🔢: 48 c7 c0 3c 00 00 00
    🔢: 48 c7 c7 2a 00 00 00
                  ^
                  |
            This byte is return code (42).
    🔢: 0f 05 ff ff ff ff ff
    🔢: ff ff ff ff ff ff ff
    ❓: i32(unresolved_symbol - 0x4 - 📍)
    ```

    ```bash
    linux$ ./minimal.fle ; echo $?
    42    # 对应于minimal.fle里的 2a (return code)
    ```

    开头的`48 c7`是move指令，结尾的`0f 05`是syscall指令。

4. foo.c

    ```C
    #include "minilib.h"

    // Global data
    extern int n;
    char msg[] = "Hello World!\n";

    int foo() {
        return n;
    }
    ```

    ```bash
    linux$ make
    ./cc -Wall -g -Os foo.c -o foo.o
    ./cc -Wall -g -Os libc.c -o libc.o
    ./cc -Wall -g -Os main.c -o main.o
    ./ld foo.fle libc.fle main.fle -o hello
    ```

    foo.fle

    ```C
    {
        "type": ".obj",
        ".text": [
            "🏷️: _text",
            "📤: foo",
            "🔢: f3 0f 1e fa 8b 05",
            "❓: i32(n - 0x4 - 📍)",
            "🔢: c3"
        ],
        ".data": [
            "📤: msg",
            "🔢: 48 65 6c 6c 6f 20 57 6f 72 6c 64 21 0a 00"
        ],
        ".bss": []
    }
    ```
5. 生成可执行文件: .c → 预处理(-E) → .i → 编译(-S) → .s → 汇编(-c) → .o → 链接 → .out

    (1) 预处理

    * 源代码 (.c) → 源代码 (.i)          ➡️ `gcc -E foo.c -o foo.i`
    * Ctrl-C & Ctrl-V (#include)
    * 字符串替换
    * 今天：我们有[过程宏](https://doc.rust-lang.org/reference/procedural-macros.html)

    (2) 编译 (cc)

    * 源代码 (.i) → 汇编代码 (.s)         ➡️ `gcc -S foo.i -o foo.s`
    * “高级状态机” 到 “低级状态机” 的翻译
    * 最终生成带标注的指令序列

    (3) 汇编 (as)

    * 汇编代码 (.s) → 目标文件 (.o)       ➡️ `gcc -c foo.s -o foo.o`
    * 文件 = sections (.text, .data, .rodata.str.1, ...)
        - 对于 ELF，每个 section 有它的权限、内存对齐等信息
    * section 中的三要素
        - 代码 (字节序列)
        - 符号：标记 “当前” 的位置
        - 重定位：暂时不能确定的数值 (链接时确定)

    (4) 链接 (ld)                         ➡️ `gcc foo.o -o foo`

    * 多个目标文件 (.o) → 可执行文件 (a.out)
    * 合并所有的 sections
        - 分别合并 .text, .data, .bss 中的代码
        - 把 sections “平铺” 成字节序列
        - 确定所有符号的位置
        - 解析全部重定位
    * 得到一个可执行文件
        - (程序初始内存状态的描述)

6. 程序的加载：把 “字节序列” 搬到内存

    * 没错，就只做这一件事
    * 然后设置正确的 PC，开始运行

    ```python
    mem = mmap.mmap(
        fileno=-1, length=len(bs),
        prot=mmap.PROT_READ | mmap.PROT_WRITE | mmap.PROT_EXEC,
        flags=mmap.MAP_PRIVATE | mmap.MAP_ANONYMOUS,
    )
    mem.write(bs)
    mem.flush()
    call_pointer(mem, fle['symbols']['_start'])
    ```

7. `#!` - Shebang

    UNIX 对 # 注释的 “妙用”：在 UNIX 的早期，为了能更方便地将脚本作为可执行文件，实现了 #! 开头的 “可执行文件”，并沿用至今。Shebang 会调用第一行中执行的命令和参数，并把这个脚本文件作为命令行参数传入。

    file.bin:
    ```C
    #!A B C
    // 操作系统会执行 execve(A, ["A", "B C", "file.bin"], envp)
    ```

    example1:

    A.c如下，编译后得到可执行文件A
    
    ```C
    #include <stdio.h>

    int main(int argc, char *argv[]) {
        for (int i = 0; i < argc; i++) {
            printf("argv[%d] = %s\n", i, argv[i]);
        }
    }
    ```

    good脚本内容如下：

    ```bash
    #!A B C

    This can be any script.
    ```

    执行结果：
    ```bash
    linux$ ./good 1 2
    argv[0] = A
    argv[1] = B C
    argv[2] = ./good
    argv[3] = 1
    argv[4] = 2
    ```

    example2:

    b文件内容如下：
    ```bash
    #! /usr/bin/env python3

    print("Hello World");
    ```

    执行结果：
    ```bash
    linux$ ./b
    Hello World
    ```

8. ELF例子：a.c

    ```C
    int n;
    __thread int x;         // in tbss, t means thread local
    __thread int x1 = 100;  // in tdata, 已初始化的数据在data节
    static __thread int y;

    extern __thread int z;

    int foo()
    {
        return z; // 可以看到R_X86_64_GOTTPOFF z - 4
    }
    ```

    ```bash
    linux$ gcc -c fPIE a.c
    gcc: warning: fPIE: linker input file unused because linking not done
    gcc: error: fPIE: linker input file not found: No such file or directory
    linux$ ls
    total 8.0K
    -rw-r--r-- 1 chaofu chaofu 1.7K Nov  8 19:26 a.o
    -rw-r--r-- 1 chaofu chaofu  122 Nov  8 19:26 a.c
    linux$ readelf -a a.o
    ELF Header:
    Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
    Class:                             ELF64
    Data:                              2's complement, little endian
    Version:                           1 (current)
    OS/ABI:                            UNIX - System V
    ABI Version:                       0
    Type:                              REL (Relocatable file)
    Machine:                           Advanced Micro Devices X86-64
    Version:                           0x1
    Entry point address:               0x0
    Start of program headers:          0 (bytes into file)
    Start of section headers:          688 (bytes into file)
    Flags:                             0x0
    Size of this header:               64 (bytes)
    Size of program headers:           0 (bytes)
    Number of program headers:         0
    Size of section headers:           64 (bytes)
    Number of section headers:         15
    Section header string table index: 14

    Section Headers:
    [Nr] Name              Type             Address           Offset
        Size              EntSize          Flags  Link  Info  Align
    [ 0]                   NULL             0000000000000000  00000000
        0000000000000000  0000000000000000           0     0     0
    [ 1] .text             PROGBITS         0000000000000000  00000040
        0000000000000014  0000000000000000  AX       0     0     1
    [ 2] .rela.text        RELA             0000000000000000  00000200
        0000000000000018  0000000000000018   I      12     1     8
    [ 3] .data             PROGBITS         0000000000000000  00000054
        0000000000000000  0000000000000000  WA       0     0     1
    [ 4] .bss              NOBITS           0000000000000000  00000054
        0000000000000004  0000000000000000  WA       0     0     4
    [ 5] .tbss             NOBITS           0000000000000000  00000054
        0000000000000008  0000000000000000 WAT       0     0     4
    [ 6] .tdata            PROGBITS         0000000000000000  00000054
        0000000000000004  0000000000000000 WAT       0     0     4
    [ 7] .comment          PROGBITS         0000000000000000  00000058
        000000000000002c  0000000000000001  MS       0     0     1
    [ 8] .note.GNU-stack   PROGBITS         0000000000000000  00000084
        0000000000000000  0000000000000000           0     0     1
    [ 9] .note.gnu.pr[...] NOTE             0000000000000000  00000088
        0000000000000020  0000000000000000   A       0     0     8
    [10] .eh_frame         PROGBITS         0000000000000000  000000a8
        0000000000000038  0000000000000000   A       0     0     8
    [11] .rela.eh_frame    RELA             0000000000000000  00000218
        0000000000000018  0000000000000018   I      12    10     8
    [12] .symtab           SYMTAB           0000000000000000  000000e0
        00000000000000f0  0000000000000018          13     4     8
    [13] .strtab           STRTAB           0000000000000000  000001d0
        000000000000002a  0000000000000000           0     0     1
    [14] .shstrtab         STRTAB           0000000000000000  00000230
        0000000000000079  0000000000000000           0     0     1
    Key to Flags:
    W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
    L (link order), O (extra OS processing required), G (group), T (TLS),
    C (compressed), x (unknown), o (OS specific), E (exclude),
    D (mbind), l (large), p (processor specific)

    There are no section groups in this file.

    There are no program headers in this file.

    There is no dynamic section in this file.

    Relocation section '.rela.text' at offset 0x200 contains 1 entry:
    Offset          Info           Type           Sym. Value    Sym. Name + Addend
    00000000000b  000900000016 R_X86_64_GOTTPOFF 0000000000000000 z - 4

    Relocation section '.rela.eh_frame' at offset 0x218 contains 1 entry:
    Offset          Info           Type           Sym. Value    Sym. Name + Addend
    000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0
    No processor specific unwind information to decode

    Symbol table '.symtab' contains 10 entries:
    Num:    Value          Size Type    Bind   Vis      Ndx Name
        0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
        1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS a.c
        2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text
        3: 0000000000000004     4 TLS     LOCAL  DEFAULT    5 y
        4: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 n
        5: 0000000000000000     4 TLS     GLOBAL DEFAULT    5 x
        6: 0000000000000000     4 TLS     GLOBAL DEFAULT    6 x1
        7: 0000000000000000    20 FUNC    GLOBAL DEFAULT    1 foo
        8: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_
        9: 0000000000000000     0 TLS     GLOBAL DEFAULT  UND z

    No version information found in this file.

    Displaying notes found in: .note.gnu.property
    Owner                Data size        Description
    GNU                  0x00000010       NT_GNU_PROPERTY_TYPE_0
        Properties: x86 feature: IBT, SHSTK
    ```

9. 加载 ELF 文件

    * 将多段字节序列复制到地址空间中
        - 分别赋予可读/可写/可执行权限
    * 然后跳转到指定的 entry (默认为 _start) 执行
    * ELF 是 “二进制数据结构”，`readelf -l` 描述了如何加载它
        - Offset: segment 在文件中的偏移量
        - VirtAddr: 段在内存中应当被加载到的起始地址
        - PhysAddr (一般不用)
        - FileSiz: 段在文件中的字节数
        - MemSiz: 段在内存中的字节数 (可能大于文件大小)
        - Flags: 权限，例如 RWE
        - Align: 虚拟地址的对齐

    ```bash
    linux$ ./loader minimal 
    Hello, OS World
    linux$ ./minimal 
    Hello, OS World
    linux$ readelf -l minimal 

    Elf file type is EXEC (Executable file)
    Entry point 0x401000
    There are 2 program headers, starting at offset 64

    Program Headers:
    Type           Offset             VirtAddr           PhysAddr
                    FileSiz            MemSiz              Flags  Align
    LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                    0x00000000000000b0 0x00000000000000b0  R      0x1000
    LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000
                    0x0000000000000058 0x0000000000000058  R E    0x1000

    Section to Segment mapping:
    Segment Sections...
    00     
    01     .text 
    ```

    <a id="minimal-loader"></a>
    意思是，loader应当将minimal这个文件的offset为0的地方，大小为0xb0的一段区域搬到操作系统中虚拟内存的0x400000位置处；将offset为0x1000，大小为0x58的一段区域搬到操作系统中虚拟内存的0x401000位置处。然后准备好[initial process stack](#system-v-abi)里的argc/argv/envp等，再跳转到Entry point 0x401000，即可开始执行minimal。

    (静态 ELF 加载器: Linux 操作系统可以直接使用 execve 系统调用加载一个程序，实现状态机的 “重置”；同时，我们也可以自己动手模拟 execve 系统调用的行为：将 ELF 文件中需要加载的部分映射到内存，并根据 [ABI](https://jyywiki.cn/OS/manuals/sysv-abi.pdf) 构建正确的进程初始栈和寄存器，我们就能实现二进制文件的 “加载”。)

    loader.c:

    ```C
    #include <stdint.h>
    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <assert.h>
    #include <elf.h>
    #include <fcntl.h>
    #include <sys/mman.h>

    void my_execve(const char *file, char *argv[], char *envp[]);
    void *init_proc_stack(char *argv[], char *envp[]);

    int main(int argc, char *argv[], char *envp[]) {
        if (argc < 2) {
            fprintf(stderr, "Usage: %s file [args...]\n", argv[0]);
            exit(1);
        }

        my_execve(argv[1], argv + 1, envp);
    }

    void my_execve(const char *file, char *argv[], char *envp[]) {
        // WARNING: This execve leaks memory and ignores
        // error checing for brevity.

        int fd = open(file, O_RDONLY);
        assert(fd > 0);

        // Map ELF header to memory
        Elf64_Ehdr *h = mmap(NULL, 4096, PROT_READ, MAP_PRIVATE, fd, 0);

        #define ROUND(x, align) (((uintptr_t)x) & ~(align - 1))

        Elf64_Phdr *pht = (Elf64_Phdr *)((char *)h + h->e_phoff);
        for (int i = 0; i < h->e_phnum; i++) {
            Elf64_Phdr *p = &pht[i];

            if (p->p_type == PT_LOAD) {
                // Memory map region
                uintptr_t align = p->p_align;
                uintptr_t map_beg = ROUND(p->p_vaddr, align);

                // Memory map flags
                int prot = 0;
                if (p->p_flags & PF_R) prot |= PROT_READ;
                if (p->p_flags & PF_W) prot |= PROT_WRITE;
                if (p->p_flags & PF_X) prot |= PROT_EXEC;

                // Memory map size
                uintptr_t map_sz = ROUND(p->p_filesz + align - 1, align);
                uintptr_t alloc_sz = p->p_memsz - p->p_filesz;

                // Map file contents
                mmap(
                    (void *)map_beg,               // addr, rounded to ALIGN
                    map_sz,                        // length
                    prot,                          // protection
                    MAP_PRIVATE | MAP_FIXED,       // flags, private & strict
                    fd, ROUND(p->p_offset, align)  // file and offset
                );

                // Map anonymous memory (bss)
                if (alloc_sz > 0) {
                    mmap(
                        (void *)(map_beg + map_sz),// addr
                        alloc_sz,                  // length,
                        prot,                      // protection
                        MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED, // flags
                        -1, 0                      // no file and offset
                    );
                }

                // (Should check for return values.)
            }
        }
        close(fd);

        void *rsp = init_proc_stack(argv, envp);
        asm volatile(
            "mov $0, %%rdx;" // required by System-V ABI
            "mov %0, %%rsp;" // loader allocated
            "jmp *%1" : : "a"(rsp), "b"(h->e_entry)
        );
    }

    void *init_proc_stack(char *argv[], char *envp[]) {
        _Alignas(16) static char stack[1 << 20];
        static char rnd[16];

        void *sp = (void *)(stack + sizeof(stack) - 8192);
        #define push(sp, T, ...) ({ \
            *((T*)sp) = (T)__VA_ARGS__; \
            sp = (void *)((uintptr_t)(sp) + sizeof(T)); \
        })

        void *rsp = sp;

        // Calculate argc
        int argc = 0;
        while (argv[argc])
            argc++;

        // Create initial process stack
        push(sp, intptr_t, argc);

        // argv[], NULL-terminate
        for (int i = 0; i < argc; i++) {
            push(sp, intptr_t, argv[i]);
        }
        push(sp, intptr_t, 0);

        // envp[], NULL-terminate
        for (; *envp; envp++) {
            if (!strchr(*envp, '_')) {
                // remove some verbose ones
                push(sp, intptr_t, *envp);
            }
        }
        push(sp, intptr_t, 0);

        // auxv[], AT_NULL-terminate
        push(sp, Elf64_auxv_t,
            {.a_type = AT_RANDOM, .a_un.a_val = (uintptr_t)rnd}
        );
        push(sp, Elf64_auxv_t,
            {.a_type = AT_NULL}
        );

        // This stack layout is defined by System-V ABI.
        return rsp;
    }
    ```

## Lecture 20 动态链接和加载
!!! abstract "Take-away Messages"

    找到正确的思路，我们就能在复杂的机制中找到主干：在动态链接的例子里，我们试着自己实现动态链接和加载——在这个过程中，我们 “发明” 了 ELF 中的重要概念，例如 Global Offset Table, Procedure Linkage Table 等。

1. “拆解应用程序” 的需求:

    实现运行库和应用代码分离
    
    * 应用之间的库共享
        - 每个程序都需要 glibc
        - 但系统里只需要一个副本就可以了
            + 是的，我们可以用 ldd 命令查看（print shared object dependencies）
    * 大型项目的分解
        - 改一行代码不用重新链接 2GB 的文件
        - libjvm.so, libart.so, libcpu.so, ...
            + NEMU: 这就好像 “把 CPU 插上主板”，分离libcpu.so 和uncore的实现，需要的时候再链接起来
    * 如果 Linux 应用世界是静态链接的……
        - libc 紧急发布安全补丁 → 重新链接所有应用 😂

    a.c:

    ```C
    #include <stdio.h>

    int main()
    {
        printf("Hello!\n");
    }
    ```

    ```bash
    linux$ gcc a.c
    linux$ ls
    total 20K
    -rwxr-xr-x 1 chaofu chaofu 16K Nov  9 10:24 a.out # 动态链接的a.out大小为16KB
    -rw-r--r-- 1 chaofu chaofu  58 Nov  9 10:24 a.c
    linux$ file a.out
    a.out: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=521bcd29744268056ffbe7b2672bb94545d04d22, for GNU/Linux 3.2.0, not stripped
    linux$ ldd a.out
            linux-vdso.so.1 (0x00007ffeb4864000)
            libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fda081b9000)
            /lib64/ld-linux-x86-64.so.2 (0x00007fda083f5000)
    ```

    如何实现分离？

    方案 1: libc.o ❌

    * 在加载时完成重定位
        - 加载 = 静态链接
        - 省了磁盘空间，但没省内存
        - 致命缺点：时间 (链接需要解析很多不会用到的符号)
    * 方案 2: libc.so (shared object) ✅
        - 编译器生成位置无关代码 (程序可以在加载运行时动态地找到并调用所需的函数，而不需要在编译时就知道这些函数的确切地址。)
            + 加载 = mmap
            + 但函数调用时需要额外一次查表
        - 好处：多个进程映射同一个 libc.so，内存中只需要一个副本

    共享库测试：启动 100 个代码为 100M 的函数，通过观察系统中的内存占用来测试多个独立启动的进程是否只保留一份共享库的代码副本。

    bloat.c

    ```C
    void bloat() {
        // 100M of nops
        asm volatile(
            ".fill 104857600, 1, 0x90"
        );
    }
    ```

    main.c

    ```C
    #include <stdio.h>
    #include <unistd.h>

    // Dynamically linked.
    void bloat();

    int main() {
        bloat();
        printf("bloat() called; sleeping...\n");
        while (1) {
            sleep(1);
        }
    }
    ```

    ```bash
    linux$ make
    gcc -shared -o libbloat.so bloat.c
    cc    -c -o main.o main.c
    gcc -o bloat main.o -L. -lbloat
    linux$ LD_LIBRARY_PATH=. ./bloat
    bloat() called; sleeping...
    linux$ ./run
    linux$ ps -ax
    PID TTY      STAT   TIME COMMAND
        1 hvc0     Sl+    0:00 /init
        5 hvc0     Sl+    0:00 plan9
        8 ?        Ss     0:00 /init
        9 ?        S      0:00 /init
    ...
    30797 pts/6    S      0:00 ./bloat
    30798 pts/6    S      0:00 ./bloat
    30799 pts/6    S      0:00 ./bloat
    30800 pts/6    S      0:00 ./bloat
    ...
    linux$ pmap 30797 | grep libbloat.so
    00007f4af8c33000      4K r---- libbloat.so
    00007f4af8c34000 102404K r-x-- libbloat.so
    00007f4aff035000      4K r---- libbloat.so
    00007f4aff036000      4K r---- libbloat.so
    00007f4aff037000      4K rw--- libbloat.so
    linux$ pmap 30798 | grep libbloat.so
    00007f83552c4000      4K r---- libbloat.so
    00007f83552c5000 102404K r-x-- libbloat.so
    00007f835b6c6000      4K r---- libbloat.so
    00007f835b6c7000      4K r---- libbloat.so
    00007f835b6c8000      4K rw--- libbloat.so
    ```

    进程 30797 看到有连续 100MB 的 libbloat.so 在地址 00007f4af8c34000 处，实际上这是操作系统塑造的假象，在真实的内存条里它可能是这样分布的：(不同部分分布在不同的内存页上)

    ![alt text](../img/image-17.png)

    在 x86 架构中，CPU 里有一个特殊寄存器 CR3，用于存储当前运行进程的页目录基地址（Page Directory Base Address）。页目录是内存管理中的一个数据结构，用于将虚拟地址转换为物理地址。当 CPU 要访问 libbloat.so 的时候，通过 CR3 寄存器正确找到物理内存条上的 libbloat.so，塑造出 libbloat.so 是连续的 100MB 的假象。

2. 实现动态加载：A Layer of Indirection

    编译时，动态链接库调用 = 查表

    ```C
    call  *TABLE[printf@symtab]
    ```

    链接时，收集所有符号，“生成” 符号信息和相关代码：

    ```C
    #define foo@symtab     1
    #define printf@symtab  2
    ...

    void *TABLE[N_SYMBOLS];

    void load(struct loader *ld) {
        TABLE[foo@symtab] = ld->resolve("foo");
        TABLE[foo@printf] = ld->resolve("printf");
        ...
    }
    ```

    例子：

    main.S:

    ```asm
    #include "dl.h"

    DL_HEAD

    LOAD("libc.dl")
    LOAD("libhello.dl")
    IMPORT(hello)
    IMPORT(exit)
    EXPORT(_start)

    DL_CODE

    main:
        call DSYM(hello)
        call DSYM(hello)
        call DSYM(hello)
        call DSYM(hello)
        movq $0, %rax
        ret

    _start:
        call main
        jmp DSYM(exit)

    DL_END
    ```

    libhello.S:

    ```asm
    #include "dl.h"

    DL_HEAD

    LOAD("libc.dl")
    IMPORT(putchar)
    EXPORT(hello)

    DL_CODE

    hello:
        lea str(%rip), %rdi
        mov count(%rip), %eax
        push %rbx
        mov %rdi, %rbx
        inc %eax
        mov %eax, count(%rip)
        add $0x30, %eax
        movb %al, 0x6(%rdi)
    loop:
        movsbl (%rbx),%edi
        test %dil,%dil
        je out
        call DSYM(putchar)
        inc  %rbx
        jmp loop
    out:
        pop %rbx
        ret

    str:
        .asciz "Hello X\n"

    count:
        .int 0

    DL_END
    ```

    libc.S:

    ```asm
    #include "dl.h"
    #include <sys/syscall.h>

    DL_HEAD

    EXPORT(putchar)
    EXPORT(exit)

    DL_CODE

    putchar:
        mov %dil, buf(%rip)
        mov $SYS_write, %rax
        mov $1, %rdi
        lea buf(%rip), %rsi
        mov $1, %rdx
        syscall
        ret
    buf:
        .byte 0

    exit:
        movq $SYS_exit, %rax
        syscall

    DL_END
    ```

    ```bash
    linux$ make
    gcc  dlbox.c -o dlbox
    ./dlbox gcc libhello.S
    ./dlbox gcc libc.S
    ./dlbox gcc main.S
    ./dlbox objdump libhello.dl > libhello.txt
    ./dlbox objdump libc.dl > libc.txt
    ./dlbox objdump main.dl > main.txt
    rm -f *.o
    linux$ ./dlbox interp main.dl
    Hello 1
    Hello 2
    Hello 3
    Hello 4
    ```

    dl.h

    ```C
    #define REC_SZ 32
    #define DL_MAGIC "\x01\x14\x05\x14"

    #ifdef __ASSEMBLER__
        #define DL_HEAD     __hdr: \
                            /* magic */    .ascii DL_MAGIC; \
                            /* file_sz */  .4byte (__end - __hdr); \
                            /* code_off */ .4byte (__code - __hdr)
        #define DL_CODE     .fill REC_SZ - 1, 1, 0; \
                            .align REC_SZ, 0; \
                            __code:
        #define DL_END      __end:

        #define RECORD(sym, off, name) \
        .align REC_SZ, 0; \
        sym .8byte (off); .ascii name

        #define IMPORT(sym) RECORD(sym:,           0, "?" #sym "\0")
        #define EXPORT(sym) RECORD(    , sym - __hdr, "#" #sym "\0")
        #define LOAD(lib)   RECORD(    ,           0, "+" lib  "\0")
        #define DSYM(sym)   *sym(%rip)
    #else
        #include <stdint.h>

        struct dl_hdr {
            char magic[4];
            uint32_t file_sz, code_off;
        };

        struct symbol {
            int64_t offset;
            char type, name[REC_SZ - sizeof(int64_t) - 1];
        };
    #endif
    ```

    ```bash
    linux$ gcc -E main.S  # 我们可以通过 -E 选项来查看预处理后的结果
    # 0 "main.S"
    # 0 "<built-in>"
    # 0 "<command-line>"
    # 1 "/usr/include/stdc-predef.h" 1 3 4
    # 0 "<command-line>" 2
    # 1 "main.S"
    # 1 "dl.h" 1
    # 2 "main.S" 2

    __hdr: .ascii "\x01\x14\x05\x14"; .4byte (__end - __hdr); .4byte (__code - __hdr)

    .align 32, 0; .8byte (0); .ascii "+" "libc.dl" "\0"
    .align 32, 0; .8byte (0); .ascii "+" "libhello.dl" "\0"
    .align 32, 0; hello: .8byte (0); .ascii "?" "hello" "\0"
    .align 32, 0; exit: .8byte (0); .ascii "?" "exit" "\0"
    .align 32, 0; .8byte (_start - __hdr); .ascii "#" "_start" "\0"

    .fill 32 - 1, 1, 0; .align 32, 0; __code:

    main:
        call *hello(%rip)
        call *hello(%rip)
        call *hello(%rip)
        call *hello(%rip)
        movq $0, %rax
        ret

    _start:
        call main
        jmp *exit(%rip)

    __end:
    ```

    ![alt text](../img/image-18.png){ width="480" }

    我们 “发明” 了 GOT (Global Offset Table)！

    * 对于每个需要动态解析的符号，GOT 中都有一个位置
    * ELF: Relocation section “.rela.dyn”

    ```C
    #include <stdio.h>

    int main()
    {
        exit(0);
    }
    ```

    ```bash
    linux$ file a.out
    a.out: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=4f42832abaead61246b7dd248749f056c3e2c373, for GNU/Linux 3.2.0, not stripped
    linux$ readelf -a a.out
    Relocation section '.rela.plt' at offset 0x610 contains 1 entry:
    Offset          Info           Type           Sym. Value      Sym. Name + Addend
    000000003fd0  000400000007 R_X86_64_JUMP_SLO 0000000000000000 exit@GLIBC_2.2.5 + 0
    linux$ pmap 15539
    15539:   /home/chaofu/jyy_os_2024/lecture/lect20/my/a.out
    0000555555554000      4K r---- a.out
    0000555555555000      4K r-x-- a.out
    ...
    total             2644K
    linux$ python
    Python 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] on linux
    Type "help", "copyright", "credits" or "license" for more information.
    >>> hex(0x000000003fd0 + 0x0000555555554000)
    '0x555555557fd0'
    >>> 
    ```

    这意味着 0x3fd0 + ELF header地址就是这个 GOT 表项的地址，这个表项里存放的是 exit 真正的地址。在 gdb 调试的时候我们可以看到 a.out 在运行时的地址空间从 0x0000555555554000 开始，我们计算得知 0x555555557fd0 是 exit 的地址，可以在这个地址上打`rwatch *0x555555557fd0`看到，确实有人读了这个地方的代码，且这个地方的确是 exit 的代码。

    ```C
    #include <stdio.h>

    int main() {
        printf("printf: %p\n", main);
        printf("main: %p\n", printf);
    }
    ```

    ```bash
    linux$ readelf -a a.out
    Relocation section '.rela.dyn' at offset 0x550 contains 9 entries:
    Offset          Info           Type           Sym. Value    Sym. Name + Addend
    000000003fe0  000500000006 R_X86_64_GLOB_DAT 0000000000000000 printf@GLIBC_2.2.5 + 0
    ```

3. 动态链接的主要功能：实现代码的动态链接和加载

    * main (.o) 调用 printf (.so)
    * main (.o) 调用 foo (.o)

    难题：怎么决定到底要不要查表？调用自己写的 foo 和调用库函数里的 printf 一样都要查表吗？

    这是个历史遗留问题：先编译、后链接

    编译器的选择 1: 全部查表跳转 (调用个 foo 都多查一次表，性能不能忍❌)
    
    ```C
    ff 25 00 00 00 00   call *FOO_OFFSET(%rip)
    ```

    编译器的选择 2: 全部直接跳转 (跳不过去❌)

    ```C
    e8 00 00 00 00      call <reloc>
    ```

    * %rip: 00005559892b7000
    * libc.so.6: 00007fdcdf800000
        - 相差了 2a8356549000
        - 4-byte 立即数放不下，无论如何也跳不过去

    编译器的选择 3: PLT (Procedure Linkage Table) ✅

    * 为了性能，“全部直接跳转” 是唯一选择
    * 如果这个符号在链接时发现是 printf (来自动态加载)，就在 a.out 里 “合成” 一段小代码：
        - i.e. 库函数的才需要 plt，需要查表 GOT。（先跳一小步到 plt，再通过 plt 查到的 GOT 表项跳一大步）自己写的 foo.c 不需要，直接跳转

    ```C
    printf@plt:
        jmp *PRINTF_OFFSET(%rip)
    ```

3. 上面只是解决了代码的动态加载加载和链接，如何实现数据的动态加载和链接？

    * main (.o) 访问 stderr (libc.so)
    * libjvm (.so) 访问 stderr (libc.so)
    * libjvm (.so) 访问 heap (libjvm.so)
        - 编译时同样不知道数据在哪里

    对于数据，我们不能 “间接跳转”！

    * x = 1, 同一个 .so (或 executable)

    ```asm
    mov $1, offset_of_x(%rip) # 直接知道地址
    ```

    * x = 1, 另一个 .so

    ```asm
    mov GOT[x], %rdi          # 需要查 GOT 表才知道地址
    mov $1, (%rdi)
    ```

    `__attribute__((visibility("hidden")))` 意思是明确知道这个变量属于本 so，不是外部库里的。

    main.c

    ```C
    #include <stdio.h>

    void A();
    void B();

    extern int x;

    int main() {
        A();

        printf("main: &stderr = %p\n", &stderr);
        printf("main: &x      = %p\n", &x);

        B();
    }
    ```

    liba-1.c

    ```C
    int x = 1;
    ```

    liba-2.c

    ```C
    #include <stdio.h>

    extern int x;

    void A() {
        printf("liba: x = %d\n", x++);
    }
    ```

    libb-1.c

    ```C
    #include <stdio.h>

    // This x is from liba.
    extern int x;

    // This y is from libb.
    extern int __attribute__((visibility("hidden"))) y;

    void *get_x_addr() {
        return &x;
    }

    void *get_y_addr() {
        return &y;
    }

    void set_x() {
        x = 1;
    }

    void set_y() {
        y = 1;
    }

    void *get_stderr() {
        return &stderr;
    }

    void B() {
        printf("B   : &stderr = %p\n", &stderr);
        printf("B   : &x      = %p\n", &x);
    }
    ```

    libb-2.c

    ```C
    int y = 0;
    ```

    ```bash
    linux$ make
    gcc -Wall -fPIC -Os -c main.c -o main.o
    gcc -Wall -fPIC -Os -c liba-1.c -o liba-1.o
    gcc -Wall -fPIC -Os -c liba-2.c -o liba-2.o
    gcc -shared -o liba.so liba-1.o liba-2.o
    gcc -Wall -fPIC -Os -c libb-1.c -o libb-1.o
    gcc -Wall -fPIC -Os -c libb-2.c -o libb-2.o
    gcc -shared -o libb.so libb-1.o libb-2.o -L. -la
    gcc -o main main.o -L. -la -lb
    linux$ LD_LIBRARY_PATH=. ./main 
    liba: x = 1
    main: &stderr = 0x7f5b3bad6860
    main: &x      = 0x7f5b3bafa028
    B   : &stderr = 0x7f5b3bad6860
    B   : &x      = 0x7f5b3bafa028
    ```

    ```bash
    linux$ objdump -d libb.so
    0000000000001119 <get_x_addr>:
        1119:       f3 0f 1e fa             endbr64 
        111d:       48 8b 05 b4 2e 00 00    mov    0x2eb4(%rip),%rax        # 3fd8 <x@Base>
        1124:       c3                      ret    

    0000000000001125 <get_y_addr>:
        1125:       f3 0f 1e fa             endbr64 
        1129:       48 8d 05 fc 2e 00 00    lea    0x2efc(%rip),%rax        # 402c <y>
        1130:       c3                      ret    
    linux$ readelf -a libb.so # 看看 x 在哪里，是在 GOT 表项
    Relocation section '.rela.dyn' at offset 0x588 contains 9 entries:
    Offset          Info           Type           Sym. Value    Sym. Name + Addend
    ...
    000000003fd8  000200000006 R_X86_64_GLOB_DAT 0000000000000000 x + 0
    ```

    可以看到由于 x 是另外一个库 liba.so 里的，所以需要 mov 指令另外查表，而 y 是本库 libb.so 里的，所以可以直接用 lea 指令去 load 地址。

4. 对于一个动态链接的二进制文件，execve后的第一条指令在哪里？

    在现代操作系统中，当一个动态链接的二进制文件通过execve系统调用被加载和执行时，第一条指令的执行位置通常不是直接在应用程序的代码中，而是在动态链接器（也称为动态加载器）中。以下是一个简要的过程描述：

    1. **加载二进制文件**：操作系统内核会加载二进制文件的头部信息（例如ELF头部）以确定文件类型和所需的动态链接器。

    2. **加载动态链接器**：根据二进制文件的头部信息，内核会加载指定的动态链接器 (例如，在Linux系统上，通常是/lib/ld-linux.so或类似路径的文件)。

    3. **跳转到动态链接器**：内核将控制权交给动态链接器。此时，动态链接器成为第一个执行的代码。

    4. **动态链接和加载**：动态链接器负责解析和加载所有需要的共享库，进行符号解析和重定位等工作。

    5. **跳转到程序入口点**：一旦所有的动态链接和加载工作完成，动态链接器会跳转到应用程序的入口点（通常是_start函数），从而开始执行应用程序的代码。

    因此，execve后的第一条指令通常是在动态链接器中，而不是直接在应用程序的代码中。动态链接器完成其工作后，才会将控制权交给应用程序的入口点。

    这个过程确保了所有动态库和依赖项在应用程序开始执行之前都已经正确加载和链接。

5. 如何编译出一个不使用默认ld.so作为interpreter的ELF动态链接可执行文件?

    要编译一个不使用默认ld.so作为解释器(interpreter)的 ELF动态链接可执行文件，你可以使用`gcc`或`ld`并指定自定义的解释器路径。以下是具体步骤：

    1. **编写一个简单的C程序** (例如hello.c)

    ```C
    #include <stdio.h> 
    
    int main()
    {
        printf("Hello, World!\n"); 
        return 0;
    }
    ```

    2. **编译并链接程序**，指定自定义的解释器路径。你可以使用`-Wl,--dynamic-linker`选项来指定解释器路径。例如，假设你想使用/path/to/custom/ld.so作为解释器：

    ```sh
    gcc -o hello hello.c -Wl,--dynamic-linker /path/to/custom/ld.so
    ```

    3. **验证ELF文件的解释器**。你可以使用`readelf`工具来检查生成的LF文件的解释器路径：

    ```sh
    readelf -a hello | grep "program interpreter" 
    ```
    
    输出应该类似于：

    ```sh
    [Requesting program interpreter: /path/to/custom/ld.so] 
    ```

6. LD_PRELOAD: 在加载之前 preload
    
    * 如果能链接我们 “修改” 过的 libc 就好了 → 甚至我们都不需要修改 libc
    * 动态加载的全局符号：先到先得，所以用 LD_PRELOAD 先占据你想要占据的东西即可

## Lecture 21 系统调用、中断和上下文切换
!!! abstract "Take-away Messages"

    系统调用指令是一种特殊的 “长跳转”——而跳转的目标是由操作系统配置好、应用程序不能决定的。类似地，处理器中断也会被动调用长跳转到操作系统内核。操作系统内核代码会 “封存” 进程的状态机：

    1. 对于内存中的页面，保持原封不动；
    2. 使用精心构造的代码，小心地将所有寄存器保存到内存中。

    此时，计算机系统就处于所有程序都被封存、操作系统代码正在执行的状态。操作系统会选择性地调度下一个寄存器现场到 CPU 上，实现上下文切换。

1. 系统调用：向操作系统的 “函数调用”

    [syscall](https://www.felixcloutier.com/x86/syscall): “跳转并获得无限的权力”

    ```asm
    call  printf@plt        // PLT; dynamic linked
    call  pmm_alloc         // locally linked

    // syscall的行为如下：
    syscall = “jal”:        // jump and link, syscall的逆操作是sysret
        mov %rip, %rcx      // 把下一条要执行的指令给rcx
        mov %rflags, %r11   // 把rflags给r11，保存好现场
        set CS = kernel, SS = kernel, CPL = 0 // 进入高权限的内核
        jmp IA32_LSTAR      // 跳转到 Long System Target Address Register
    ```

    * 此时 RIP = IA32_LSTAR, CPL = 0
    * 操作系统可以配置 IA32_LSTAR
        - setjmp() → 在另一个栈中执行 → longjmp() → sysret
        - 执行时可以直接访问 I/O 设备和内核数据结构
        - 操作系统 = C 程序
    * 进程的内存被 “拆散”，并且被 Page Table 重组了
        - 从 M[LSTAR] 的虚拟地址处取指令
        - [Complete kernel virtual memory map](https://www.kernel.org/doc/html/v6.3/x86/x86_64/mm.html)

    我们怎么在一个 syscall 指令上打断点？➡️ 借助 minimal.S 静态链接的系统调用和 QEMU 的断点机制，我们就能 “抓住” 一个系统调用，并且查看前后寄存器数值的变化。init.py 中的代码对大家理解系统软件 (尤其是和寄存器保存/恢复相关的汇编代码) 的指令级行为，是非常有用的

    ```bash
    0xffffffff8dc00040 in ?? ()
    rcx 0x0 -> 0x40101e
    r11 0x0 -> 0x202 
    rip 0x40101c -> 0xffffffff8dc00040 
    eflags [ IOPL=0 IF ] -> [ IOPL=0 ]
    cs 0x33 -> 0x10
    ss 0x2b -> 0x18 
    (gdb)
    ```

    init.py

    ```python
    import gdb
    import re

    R = {}

    def stop_handler(event):
        if isinstance(event, gdb.StopEvent):
            regs = [
                line for line in 
                    gdb.execute('info registers',
                                to_string=True).
                                strip().split('\n')
                        if not line.startswith('xmm')
            ]
            for line in regs:
                parts = line.split()
                key = parts[0]

                if m := re.search(r'(\[.*?\])', line):
                    val = m.group(1)
                else:
                    val = parts[1]

                if key in R and R[key] != val:
                    print(key, R[key], '->', val)
                R[key] = val

    gdb.events.stop.connect(stop_handler)

    gdb.execute('target remote localhost:1234')
    gdb.execute('hb *0x401000')
    gdb.execute('continue')
    ```

2. 中断 = 一根线。“告诉处理器：停停，有事来了”，剩下全是处理器的事。另一种理解中断的方式：<span style="color:blue;">被强制 “插入” 的 syscall</span>

    ![alt text](../img/6502-pinout.webp){ width="270" }

    处理器的中断行为，如果处理器中断打开：
    
    * x86 Family (CISC 的历史遗迹；处理器实现的噩梦)
        - 询问中断控制器获得中断号 `n`
        - 保存 `CS`, `EIP`, `EFLAGS`, `SS`, `ESP` 到堆栈
        - 跳转到 `IDT[n]` 中的 “Gate”
            + 一个描述带权限切换长跳转的数据结构
    * RISC-V (M-Mode, Direct Exception Mode)
        - 检查 `mie` 是否屏蔽此次中断
        - 跳转 `PC = (mtvec & ~0xf)`
        - 更新 `mcause.Interrupt = 1`

    以 RISC-V 为例，中断其实是一种被强制 “插入” 的 syscall: (“无论你现在在做什么，都去执行一下操作系统内核的代码吧”)

    <table>
    <tr>
    <td>中断</td>
    <td>系统调用 (ecall)</td>
    </tr>
    <tr>
    <td><ul>
    <li>保存 <code>mepc = PC</code></li>
    <li>跳转 <code>PC = (mtvec & ~0xf)</code></li>
    <li>更新 <code>mcause.Interrupt = 1</code></li>
    </ul></td>
    <td><ul>
    <li>保存 <code>mepc = PC</code></li>
    <li>跳转 <code>PC = (mtvec & ~0xf)</code></li>
    <li>更新 <code>mcause.Ecall = 1</code></li>
    </ul></td>
    </tr>
    </table>

    中断来了，操作系统代码应该做什么？

    * mov (kernel_rsp), %rsp
        - 这将是致命的
        - 进程 (状态机) 的状态就永远丢失了
    * 首先：封存状态机 (寄存器) 到内存上
        - 内存由数据结构控制
    * 然后：执行操作系统代码
        - C 代码可以任意使用寄存器
        - 操作系统代码选择一个返回的状态机
        - 恢复寄存器状态，执行 sysret (iret)

    thread-os.c

    ```C
    #include <am.h>
    #include <klib.h>
    #include <klib-macros.h>

    typedef union thread {
        struct {
            const char    *name;
            void          (*entry)(void *);
            Context       context;
            union thread  *next;
            char          end[0];
        };
        uint8_t stack[8192];
    } Thread;

    void T1(void *);
    void T2(void *);
    void T3(void *);

    Thread threads[] = {
        // Context for the bootstrap code:
        { .name = "_", .entry = NULL, .next = &threads[1] },

        // Thread contests:
        { .name = "1", .entry = T1, .next = &threads[2] },
        { .name = "2", .entry = T2, .next = &threads[3] },
        { .name = "3", .entry = T3, .next = &threads[1] },
    };
    Thread *current = &threads[0];

    Context *on_interrupt(Event ev, Context *ctx) {
        // Save context.
        current->context = *ctx;

        // Thread schedule.
        current = current->next;

        // Restore current thread's context.
        return &current->context;
    }

    int main() {
        cte_init(on_interrupt);

        for (int i = 1; i < LENGTH(threads); i++) {
            Thread *t = &threads[i];
            t->context = *kcontext(
                // a Thread object:
                // +--------------------------------------------+
                // | name, ... end[0] | Kernel stack ...        |
                // +------------------+-------------------------+
                // ^                  ^                         ^     
                // t                  &t->end                   t + 1
                (Area) { .start = &t->end, .end = t + 1, },
                t->entry, NULL
            );
        }

        yield();    // 执行 yield() 后再也不回来了
        assert(0);  // Never returns. 永远不可能走到这一行
        // 操作系统：加载第一个程序，然后变成后台的一个中断处理程序
    }


    void delay() {
        for (int volatile i = 0;
            i < 10000000; i++);
    }

    void T1(void *arg) { while (1) { putch('A'); delay(); } }
    void T2(void *arg) { while (1) { putch('B'); delay(); } }
    void T3(void *arg) { while (1) { putch('C'); delay(); } }
    ```

    ```bash
    linux$ make
    # Building kernel-image [x86_64-qemu]
    + CC thread-os.c
    # Building am-archive [x86_64-qemu]
    # Building klib-archive [x86_64-qemu]
    + LD -> build/kernel-x86_64-qemu.elf
    # Creating image [x86_64-qemu]
    + CREATE -> build/kernel-x86_64-qemu
    linux$ make run
    # Building kernel-run [x86_64-qemu]
    # Building am-archive [x86_64-qemu]
    # Building klib-archive [x86_64-qemu]
    + LD -> build/kernel-x86_64-qemu.elf
    # Creating image [x86_64-qemu]
    + CREATE -> build/kernel-x86_64-qemu
    ABCACBABCABCABCABCBACABCABCBACBACABCBCABCABACBCABCABCABCABCABCABCABCABACBCABCABCABCABACBCABCABACBACBCABACABCBACABCABCAB
    linux$ make debug # 然后另外开一个窗口 gdb -x init.gdb, 再layout asm/si单步执行
    ```

## Lecture 22 进程的实现
!!! abstract "Take-away Messages"

    Everything is a state machine; 而操作系统在中断/系统调用时，“封存” 了所有进程的状态机，并且可以将它们重新加载到 CPU 上执行。顺着这个思路，我们不难看到 UNIX 操作系统和系统调用的 “直接” 实现。而进程不过是 “线程” 加上了一个地址翻译函数 (只要加上虚拟内存 (VR 眼镜))。

1. 进程 = 戴上 VR 眼镜的线程。一个函数 f，使所有对内存地址 x 的访问都转换为 f(x)。

    ![alt text](../img/page-table.webp){ width="270" }

2. Demand Paging

    进程能做的
    
    * 执行一条 load/store 访问一个地址
    
    操作系统看到的
    
    * 数据结构维护的区间列表 (pmap)
        - 有些部分分配了，有些部分没分配
        - 哪些页面要保留在内存，操作系统说了算
    * 如果发生 Page Fault
        - 合法，未分配：改变 f (数据结构)，映射一页
        - 非法：SIGSEGV

3. Copy-on-write fork()：函数 f 的妙用

    * fork() 后直接把父子进程地址空间标记成只读
        - 在最顶层页表标记即可
    * 任何合法的 store Page Fault 时就会分成两种情况
        - 未分配：直接分配
        - 已分配 (read-only)：复制一份
            + share_count--
            + share_count == 1 最后一份只读副本也变成可写

    fork() 在进行状态机复制时，虽然理论上需要做出完整的状态复制，但本着 “复制的数据可能立即被浪费掉” 的观察，操作系统希望只在 “不得不复制” 时才复制。

    现代操作系统会维护页面的共享情况，并在 fork 后将父子进程的地址空间都标记为 read-only，而当双方中的任何一个进程写入发生 page fault 时，才复制一页。对于连续的 fork()，则会产生多个进程共享页面的情况。

4. [xv6: a simple, Unix-like teaching operating system](https://jyywiki.cn/OS/manuals/book-riscv-rev3.pdf)

## Lecture 23 处理器调度
!!! abstract "Take-away Messages"

    计算机系统设计中的一个重要主题就是机制和策略的分离——它帮助我们分离计算机系统中的复杂性，使我们能在一个干净的概念体系上处理复杂的系统。我们看到许多这样的例子：分页机制和 demand-paging 策略；上下文切换机制和调度策略；安全机制和访问控制策略等等。通过将机制和策略分离，我们可以在不改变底层机制的情况下调整策略，从而更灵活地适应不同的需求和环境。这种分离还使得系统的设计和实现更加模块化和可维护，便于调试和优化。

1. 处理器调度

    UNIX Niceness：-20 ... 19 的整数，越 nice 越让别人得到 CPU
    
    * -20: 极坏; most favorable to the process
    * 19: 极好; least favorable to the process

    ```bash
    linux$ # 将进程绑定到 cpu 3上执行，设置nice值为19和9，看到CPU利用率有10倍之差
    taskset -c 3 nice -n 19 yes > /dev/null &
    taskset -c 3 nice -n  9 yes > /dev/null &
    linux$ top
    PID  USER     PR  NI   VIRT   RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    1539 linux    29   9   3208   1004   908 R  90.4   0.0   0:16.90 yes
    1538 linux    39  19   3208   1032   940 R   9.6   0.0   0:01.84 yes
    ```

2. 策略：动态优先级 (MLFQ)。系统自动设定优先级：
    
    * 用完时间片 → 坏人 (请让它变得 “更好”，优先级变低 ↓)
    * 让出 CPU (I/O) → 好人 (可以变得更坏，优先级变高 ↑)

    ![alt text](../img/MLFQ.webp){ width="210" }

    策略：Complete Fair Scheduling (CFS)。“让系统里的所有进程尽可能公平地共享处理器”：

    * 为每个进程记录精确的运行时间
    * 中断/异常发生后，切换到运行时间最少的进程执行

3. `lstopo`: 用于显示系统硬件拓扑结构的命令行工具，它可以帮助用户了解系统中各个硬件组件之间的连接关系和层次结构。

    ![alt text](../img/image-19.png)

4. 真实的处理器调度

    * 优先级反转：只有一个处理器时，jyy 在持有互斥锁的时候被中优先级进程 changxu 赶下了处理器（没做完工作，锁还没释放），然而更高优先级的xxm 来了后因为没有获得锁，只能最后被排到。
    
    ```C
    void jyy@nju.edu.cn() {
        nice(10);
        mutex_lock(&restroom_lock);
    }

    void changxu@nju.edu.cn() {
        nice(0);
        while (1) ;
    }

    void xxm@nju.edu.cn() {
        nice(-10);
        mutex_lock(&restroom_lock);
    }
    ```

    * 今天的计算机系统：SMP (Symmetric Multi-processing)
        - 既不能简单地 “分配线程到处理器”
            + 线程退出，瞬间处理器开始围观
        - 也不能简单地 “谁空丢给谁”
            + 在处理器之间迁移会导致 cache/TLB 全都白给
            + mmap/munmap/mprotect 会触发 TLB Shootdown

    * 而且还有很多不同的实际情况
        - NUMA (Non-uniform memory access): 共享内存密集型程序在远/近 CPU 上性能差达到数倍
        - 多用户: 单线程的 A 和 10,000 线程的 B 在 CFS 上共享 CPU...？
        - 异构处理器: Intel Core Ultra 7: 6P (× 2T) + 8E + 2LPE，大小核...
        - 更少的处理器，反而更快...

        ```bash
        linux$ time ./sum 
        sum = 200000000
        2*n = 200000000

        ________________________________________________________
        Executed in 2.37 secs    fish           external
        usr time    4.70 secs  224.00 micros    4.70 secs
        sys time    0.01 secs  168.00 micros    0.01 secs

        linux$ time taskset -c 0 ./sum
        sum = 200000000
        2*n = 200000000

        ________________________________________________________
        Executed in 1.12 secs    fish           external
        usr time    1.12 secs  421.00 micros    1.12 secs
        sys time    0.00 secs  252.00 micros    0.00 secs

        linux$ time taskset -c 0,1,2,3 ./sum
        sum = 200000000
        2*n = 200000000

        ________________________________________________________
        Executed in 2.13 secs    fish           external
        usr time    4.24 secs  323.00 micros    4.24 secs
        sys time    0.01 secs  194.00 micros    0.01 secs

        linux$ 
        ```

## Lecture 24 状态机模型的应用
!!! abstract "Take-away Messages"

    在这门课中，我们从 “数学” 的视角去理解计算机系统中的一切——当我们把程序、程序的执行、计算机系统的执行、系统调用……这些看起来包罗万象的复杂概念都投射到一个简单的模型上，用 “干净” 的思绪去寻找问题的本质。无论是你希望实现一个机制 (例如今天的信号)，还是希望诊断一个复杂的问题，状态机的视角都帮助你排除干扰、找到关键。

1. Profiler: 实现 - 隔一段时间 “暂停” 程序、观察状态机的执行

    * 中断就可以做到 (例如中断处理的时候 printf current pc...)
    * 给 s → s′ 的指令 “记账”
        - 对应的语句
        - 函数调用栈
    * 得到统计意义的性能摘要

2. 为什么 Ctrl-C 可以终止程序? ➡️ Ctrl-C 是一个信号，称为 SIGINT（Interrupt Signal）。当用户在终端中按下 Ctrl-C 时，操作系统会向当前正在运行的前台进程发送 SIGINT 信号，这个信号的目的是请求进程终止执行。

    kill 系统调用: 发送信号 (不是 “杀死”)

    * UNIX: 我们就这么随手一命名 😂
    * 命令行：`kill -SIGNAME pid`
        - 可以 `SIGINT`, `SIGQUIT`, ...
            + `SIGKILL` (9) 是不可忽略的信号
            + 强行终止，因此不推荐

    ```C
    #include <stdio.h>
    #include <stdlib.h>
    #include <signal.h>
    #include <unistd.h>

    void handler(int signum) {
        switch (signum) {
            case SIGINT:
                printf("Received SIGINT!\n");
                break;   // ctrl+c 无法退出
            case SIGQUIT:
                printf("Received SIGQUIT!\n");
                exit(0); // 因此只有 ctrl+\ 才能退出
                break;
        }
    }

    void cleanup() {
        printf("atexit() cleanup\n");
    }

    int main() {
        signal(SIGINT,  handler);
        signal(SIGQUIT, handler);
        atexit(cleanup);

        while (1) {
            char buf[4096];
            int nread = read(STDIN_FILENO, buf, sizeof(buf));
            buf[nread - 1] = '\0';
            printf("[%d] Got: %s\n", getpid(), buf);
            if (nread < 0) {
                perror("read");
                exit(1);
            }
            sleep(1);
        }
    }
    ```

    ```bash
    linux$ ./signal 
    ^CReceived SIGINT!
    ^\Received SIGQUIT!
    atexit() cleanup
    ```