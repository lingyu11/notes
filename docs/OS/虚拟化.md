# è™šæ‹ŸåŒ–

## Lecture 14 æ“ä½œç³»ç»Ÿä¸Šçš„è¿›ç¨‹
!!! abstract "Take-away Messages"

    å› ä¸º â€œç¨‹åº = çŠ¶æ€æœºâ€ï¼Œæ“ä½œç³»ç»Ÿä¸Šè¿›ç¨‹ (è¿è¡Œçš„ç¨‹åº) ç®¡ç†çš„ API å¾ˆè‡ªç„¶åœ°å°±æ˜¯çŠ¶æ€æœºçš„ç®¡ç†ã€‚åœ¨ UNIX/Linux ä¸–ç•Œä¸­ï¼Œä»¥ä¸‹ä¸‰ä¸ªç³»ç»Ÿè°ƒç”¨åˆ›å»ºäº†æ•´ä¸ª â€œè¿›ç¨‹ä¸–ç•Œâ€ï¼Œä¸è®ºæ˜¯æˆ‘ä»¬å¸¸ç”¨çš„ IDE å’Œæµè§ˆå™¨ï¼Œè¿˜æ˜¯ç¼–è¯‘æ—¶åœ¨åå°è°ƒç”¨çš„ gccã€‚å…¶ä¸­ï¼š
    
    * fork: å¯¹å½“å‰çŠ¶æ€æœºçŠ¶æ€è¿›è¡Œå®Œæ•´å¤åˆ¶
    * execve: å°†å½“å‰çŠ¶æ€æœºçŠ¶æ€é‡ç½®ä¸ºæŸä¸ªå¯æ‰§è¡Œæ–‡ä»¶æè¿°çš„çŠ¶æ€æœº
    * exit: é”€æ¯å½“å‰çŠ¶æ€æœº
        
    åœ¨å¯¹è¿™ä¸ªæ¦‚å¿µæœ‰äº†ç»å¯¹æ­£ç¡®ä¸”ç»å¯¹ä¸¥è°¨çš„ç†è§£åï¼Œæ“ä½œç³»ç»Ÿä¹Ÿå°±æ˜¾å¾—ä¸é‚£ä¹ˆç¥ç§˜äº†ã€‚

1. fork: åˆ›å»ºçŠ¶æ€æœºã€‚åšä¸€ä»½çŠ¶æ€æœºå®Œæ•´çš„å¤åˆ¶ (å†…å­˜ã€å¯„å­˜å™¨ç°åœº)ã€‚
    ```C
    pid_t fork(void);
    ```

    fork() çš„è¡Œä¸º

    * ç«‹å³å¤åˆ¶çŠ¶æ€æœº
        - åŒ…æ‹¬æ‰€æœ‰ä¿¡æ¯çš„å®Œæ•´æ‹·è´
            + æ¯ä¸€ä¸ªå­—èŠ‚çš„å†…å­˜
            + æ‰“å¼€çš„æ–‡ä»¶ (å…±äº«)
            + â€¦â€¦
            + å¤åˆ¶å¤±è´¥è¿”å› -1
                + errno ä¼šè¿”å›é”™è¯¯åŸå›  (man fork)

    * å¦‚ä½•åŒºåˆ†ä¸¤ä¸ªçŠ¶æ€æœºï¼Ÿ
        * æ–°åˆ›å»ºè¿›ç¨‹ï¼šå¾—åˆ°çš„è¿”å›å€¼æ˜¯ 0
        * æ‰§è¡Œ fork çš„çˆ¶è¿›ç¨‹ï¼šå¾—åˆ°çš„è¿”å›å€¼æ˜¯å­è¿›ç¨‹çš„è¿›ç¨‹å·

2. é˜…è¯»ä»¥ä¸‹ç¨‹åºï¼Œå†™å‡ºè¿è¡Œç»“æœ
    ```C
    pid_t x = fork();
    pid_t y = fork();
    printf("%d %d\n", x, y);
    ```

    è¾“å‡ºï¼š
    ```bash
    19489 19490
    19489 0
    0 19491
    0 0
    ```
    ![alt text](../img/image-11.png)

    ```C
    for (int i = 0; i < 2; i++) {
        fork();
        printf("Hello\n");
    }
    ```
    è¾“å‡ºï¼š6ä¸ªHello
    ```C
    Hello
    Hello
    Hello
    Hello
    Hello
    Hello
    ```

    ç¨‹åºç­‰ä»·äºï¼š
    ```C
    fork();
    printf("Hello\n");
    fork();
    printf("Hello\n");
    ```
    ![alt text](../img/image-12.png)

    ç„¶è€Œï¼Œ`./demo-2 | wc -l`è¾“å‡ºçš„æ˜¯`8`ã€‚åŸå› ï¼šåœ¨ç»ˆç«¯é‡Œæ¢è¡Œæ‰“å°æ—¶ä½¿ç”¨çš„æ˜¯line bufferï¼Œæ­¤æ—¶æ‰“å°6ä¸ªï¼›é‡å®šå‘åˆ°æ–‡ä»¶æˆ–ä½¿ç”¨ç®¡é“æ—¶ä½¿ç”¨çš„æ˜¯full bufferï¼Œæ­¤æ—¶ä¼šæ‰“å°8ä¸ªï¼Œæ²¡æœ‰åˆ·æ–°bufferï¼Œå¯¼è‡´æ‰€æœ‰å¸¦æœ‰å€¼çš„bufferä¹Ÿè¢«forkäº†ã€‚`man setbuf`å¯ä»¥çœ‹åˆ°æœ‰ä¸‰ç§æ¨¡å¼`_IONBF unbuffered`/`_IOLBF line buffered`/`_IOFBF fully buffered`ã€‚
    æ­¤æ—¶ç¨‹åºç­‰ä»·äºï¼š
    ```C
    fork();
    buf += "Hello";
    fork();
    buf += "Hello";
    flush(buf);
    ```
    ![alt text](../img/image-13.png)

3. execveï¼šé‡ç½®çŠ¶æ€æœºã€‚å°†å½“å‰è¿›ç¨‹é‡ç½®æˆä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶æè¿°çŠ¶æ€æœºçš„åˆå§‹çŠ¶æ€ã€‚

    ```C
    int execve(const char *filename,
               char * const argv[], char * const envp[]);
    // ä¸‰ä¸ªå‚æ•°ï¼šå¯æ‰§è¡Œæ–‡ä»¶çš„è·¯å¾„ã€ä¼ é€’ç»™ main å‡½æ•°çš„å‚æ•°å’Œç¯å¢ƒå˜é‡ã€‚
    ```
    execve è¡Œä¸º

    * æ‰§è¡Œåä¸º `filename` çš„ç¨‹åº
    * å…è®¸å¯¹æ–°çŠ¶æ€æœºè®¾ç½®å‚æ•° `argv` (v) å’Œç¯å¢ƒå˜é‡ `envp` (e)
        - åˆšå¥½å¯¹åº”äº† `main()` çš„å‚æ•°ï¼
    * execve æ˜¯å”¯ä¸€èƒ½å¤Ÿ â€œæ‰§è¡Œç¨‹åºâ€ çš„ç³»ç»Ÿè°ƒç”¨
        - å› æ­¤ä¹Ÿæ˜¯ä¸€åˆ‡è¿›ç¨‹ strace çš„ç¬¬ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨

4. UNIX ä¸­å®ç° â€œåˆ›å»ºæ–°çŠ¶æ€æœºâ€ çš„æ–¹å¼ï¼šfork + execve ï¼ˆç›¸å½“äºspawnï¼‰
    ```C
    int pid = fork();
    if (pid == -1) {
        // forkå¤±è´¥
        perror("fork"); goto fail;
    } else if (pid == 0) {
        // Child
        execve(...);
        // å¦‚æœ execve æˆåŠŸæ‰§è¡Œï¼Œå®ƒå°†æ›¿æ¢å½“å‰è¿›ç¨‹çš„å†…å­˜ç©ºé—´å¹¶å¼€å§‹æ‰§è¡Œæ–°çš„ç¨‹åºï¼Œ
        // å› æ­¤ perror("execve") ä¸ä¼šè¢«æ‰§è¡Œã€‚perror("execve") åªä¼šåœ¨ execve
        // è°ƒç”¨å¤±è´¥æ—¶æ‰§è¡Œ
        perror("execve"); goto fail;
    } else {
        // Parent
        ...
    }
    ```

    demo:
    ```C
    #include <unistd.h>
    #include <stdio.h>

    int main() {
        char *const argv[] = {
            "/bin/bash",
            "-c",
            "env",
            NULL,
        };

        char *const envp[] = {
            "HELLO=WORLD",
            NULL,
        };

        // Reset the state machine to "/bin/bash"
        execve(argv[0], argv, envp);

        // We are here only on error.
        printf("Hello, World!\n");
    }
    ```
    è¾“å‡ºï¼š
    ```bash
    PWD=/home/user/jyy_os_2024/lecture/lect14/execve-demo
    HELLO=WORLD
    SHLVL=0
    _=/usr/bin/env
    ```
    è¿™æ¯”ç›´æ¥åœ¨bashé‡Œæ‰§è¡Œ`/bin/bash -c env`å¾—åˆ°çš„ä¸€å¤§å †è¾“å‡ºæ›´åŠ ç®€å•ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬åœ¨ä»£ç é‡Œçš„ç¯å¢ƒå˜é‡evnpåªä¿ç•™äº†`HELLO=WORLD`ï¼ˆå½“ç„¶å®é™…ä¸Šæ‰§è¡Œexecveè¿˜æ˜¯æœ‰PWD/SHLVLç­‰è¢«åŠ ä¸Šçš„ç¯å¢ƒå˜é‡ï¼‰ã€‚

5. _exit()ï¼šé”€æ¯çŠ¶æ€æœºã€‚ç«‹å³æ‘§æ¯çŠ¶æ€æœºï¼Œå…è®¸æœ‰ä¸€ä¸ªè¿”å›å€¼ã€‚å­è¿›ç¨‹ç»ˆæ­¢ä¼šé€šçŸ¥çˆ¶è¿›ç¨‹ã€‚
    ```C
    void _exit(int status);
    ```

    ç»“æŸç¨‹åºæ‰§è¡Œçš„ä¸‰ç§æ–¹æ³•

    * exit(0)
        - provided by libc
        - ä¼šè°ƒç”¨ atexit
    * _exit(0)
        - æ‰§è¡Œ â€œexit_groupâ€ ç³»ç»Ÿè°ƒç”¨ç»ˆæ­¢æ•´ä¸ªè¿›ç¨‹ (æ‰€æœ‰çº¿ç¨‹)
        - ä¸ä¼šè°ƒç”¨ atexit 
    * syscall(SYS_exit, 0)
        - æ‰§è¡Œ â€œexitâ€ ç³»ç»Ÿè°ƒç”¨ç»ˆæ­¢å½“å‰çº¿ç¨‹
        - ä¸ä¼šè°ƒç”¨ atexitï¼ˆlibcå½“ç„¶ä¸äº†è§£ç³»ç»Ÿè°ƒç”¨ï¼Œä¹Ÿå°±æ— æ³•åœ¨é€€å‡ºæ—¶è°ƒç”¨libcçš„atexitå‡½æ•°ï¼‰

## Lecture 15 è¿›ç¨‹çš„åœ°å€ç©ºé—´
!!! abstract "Take-away Messages"

    çŠ¶æ€æœºçš„è§†è§’è‡ªç„¶åœ°å°†æˆ‘ä»¬å¼•å…¥ â€œå†…å­˜åˆ°åº•æ˜¯ä»€ä¹ˆâ€ çš„é—®é¢˜â€”â€”å®ƒçš„ç­”æ¡ˆåŒæ ·ä¹Ÿå¾ˆè‡ªç„¶ï¼šå¸¦æœ‰è®¿é—®æƒé™æ§åˆ¶çš„è¿ç»­å†…å­˜æ®µã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ <span style="color:lightblue;">mmapã€munmapã€mprotect</span> ä¸‰ä¸ªç³»ç»Ÿè°ƒç”¨è°ƒæ•´çŠ¶æ€æœºçš„åœ°å€ç©ºé—´ï¼ŒåŒ…æ‹¬åˆ†é…åŒ¿åçš„å†…å­˜ã€æ˜ å°„æ–‡ä»¶å†…å®¹åˆ°å†…å­˜ã€ä¿®æ”¹è®¿é—®æƒé™ç­‰ï¼ˆå¢/åˆ /æ”¹ï¼‰ã€‚æ›´æœ‰è¶£çš„æ˜¯æ“ä½œç³»ç»Ÿæœ‰ â€œèƒ½å¤Ÿå®ç°ä¸€åˆ‡åº”ç”¨ç¨‹åºâ€ çš„éœ€æ±‚ï¼Œè°ƒè¯•å™¨ä¹Ÿä¸åœ¨è¯ä¸‹â€”â€”è¿™ä¹Ÿç»™äº†æˆ‘ä»¬å…¥ä¾µå…¶ä»–è¿›ç¨‹åœ°å€ç©ºé—´çš„æœºåˆ¶ã€‚

1. ä»¥ä¸‹ç¨‹åºçš„ (å¯èƒ½) è¾“å‡ºæ˜¯ä»€ä¹ˆï¼Ÿ
    ```C
    int main()
    {
        int x = *(int *)main;
        printf("%x\n", x);    // fa1e0ff3ï¼ˆå°ç«¯ï¼‰
        printf("%p\n", main); //0x556b3315c149ï¼Œæ¯æ¬¡ä¸ä¸€æ ·
    }
    ```

    ```bash
    objdump -d a.out
    0000000000001149 <main>:
    1149:       f3 0f 1e fa             endbr64 
    114d:       55                      push   %rbp
    114e:       48 89 e5                mov    %rsp,%rbp
    1151:       48 83 ec 10             sub    $0x10,%rsp
    ...
    ```
2. æŸ¥çœ‹è¿›ç¨‹çš„åœ°å€ç©ºé—´ï¼š

    * /proc/[pid]/maps

        ```bash
        linux$ ps
        PID TTY          TIME CMD
        18222 pts/3    00:00:00 dbus-launch
        22713 pts/3    00:00:01 bash
        29368 pts/3    00:00:00 ps
        linux$ vi /proc/22713/maps
        55e7a0632000-55e7a0711000 r-xp 0002f000 08:20 1241                       /usr/bin/bash
        55e7a0711000-55e7a074b000 r--p 0010e000 08:20 1241                       /usr/bin/bash
        55e7a074c000-55e7a0750000 r--p 00148000 08:20 1241                       /usr/bin/bash
        55e7a0750000-55e7a0759000 rw-p 0014c000 08:20 1241                       /usr/bin/bash
        ...
        7ffdf9eb0000-7ffdf9ed2000 rw-p 00000000 00:00 0                          [stack]
        7ffdf9f79000-7ffdf9f7d000 r--p 00000000 00:00 0                          [vvar]
        7ffdf9f7d000-7ffdf9f7f000 r-xp 00000000 00:00 0                          [vdso]
        ```

        æ— éœ€é™·å…¥å†…æ ¸çš„ç³»ç»Ÿè°ƒç”¨: vvar (data)/vdso (code)ã€‚ä¾‹å¦‚æ—¶é—´è¿™æ ·çš„æ•°æ®ï¼Œåªæœ‰æ“ä½œç³»ç»Ÿæœ‰ï¼Œè€Œåº”ç”¨ç¨‹åºåªæ˜¯è¯»æ—¶é—´æˆ³ï¼Œä¸ä¼šæ”¹å®ƒï¼Œå¯¹äºè¿™æ ·åªè¯»çš„æ•°æ®ï¼Œæ— éœ€è¿›å…¥æ“ä½œç³»ç»Ÿå†…æ ¸ã€‚å› æ­¤ï¼Œ**æ“ä½œç³»ç»Ÿé‡Œåªè¯»çš„æ•°æ®å¯ä»¥é€šè¿‡å†…å­˜çš„æ–¹å¼å…±äº«ç»™è¿›ç¨‹**ã€‚

    * pmap [pid]

        ```bash
        linux$ pmap 22713
        22713:   /bin/bash
        000055e7a0603000    188K r---- bash
        000055e7a0632000    892K r-x-- bash
        000055e7a0711000    232K r---- bash
        000055e7a074c000     16K r---- bash
        000055e7a0750000     36K rw--- bash
        000055e7a0759000     44K rw---   [ anon ]
        000055e7a1dbc000   1832K rw---   [ anon ]
        ...
        ```

    * gdb cmd: `info proc mappings`

3. ç®¡ç†è¿›ç¨‹åœ°å€ç©ºé—´ï¼šåœ¨çŠ¶æ€æœºçŠ¶æ€ä¸Šå¢åŠ /åˆ é™¤/ä¿®æ”¹ä¸€æ®µå¯è®¿é—®çš„å†…å­˜

    ```C
    // æ˜ å°„
    void *mmap(void *addr, size_t length, int prot, int flags,
               int fd, off_t offset);
    int munmap(void *addr, size_t length);

    // ä¿®æ”¹æ˜ å°„æƒé™
    int mprotect(void *addr, size_t length, int prot);
    ```

    ä¾‹å­ï¼š

    ```C
    #include <unistd.h>
    #include <stdint.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <sys/mman.h>

    #define GiB * (1024LL * 1024 * 1024)

    int main() {
        volatile uint8_t *p = mmap(
            NULL,
            8 GiB,
            PROT_READ | PROT_WRITE,
            MAP_ANONYMOUS | MAP_PRIVATE,
            -1, 0
        );

        printf("mmap: %lx\n", (uintptr_t)p);

        if ((intptr_t)p == -1) {
            perror("cannot map");
            exit(1);
        }

        *(p + 2 GiB) = 1;
        *(p + 4 GiB) = 2;
        *(p + 7 GiB) = 3;
        printf("Read get: %d\n", *(p + 4 GiB));
        printf("Read get: %d\n", *(p + 6 GiB));
        printf("Read get: %d\n", *(p + 7 GiB));
    }
    ```

    ```python
    import hexdump
    import mmap

    with open('/dev/sda', 'rb') as fp:
        mm = mmap.mmap(fp.fileno(),
                    prot=mmap.PROT_READ, length=128 << 30)
        hexdump.hexdump(mm[:512]) # å°†ç£ç›˜sdaçš„128GiBæ˜ å°„åˆ°å†…å­˜ï¼Œå¹¶æŸ¥çœ‹å‰512å­—èŠ‚
    ```
4. å…¥ä¾µè¿›ç¨‹åœ°å€ç©ºé—´

    * è°ƒè¯•å™¨ (gdb)
        - gdb å¯ä»¥ä»»æ„è§‚æµ‹å’Œä¿®æ”¹ç¨‹åºçš„çŠ¶æ€
    * Profiler (perf)
        - M3 ä¸­å€ŸåŠ©å®ƒç†è§£ç¨‹åºçš„æ€§èƒ½ç“¶é¢ˆ

    ä¾‹å­ï¼šé‡‘å±±æ¸¸ä¾ 

    * åœ°å€ç©ºé—´é‚£ä¹ˆå¤§ï¼Œå“ªä¸ªæ‰æ˜¯ â€œé‡‘é’±â€ï¼Ÿ
        - åŒ…å«åŠ¨æ€åˆ†é…çš„å†…å­˜ï¼Œæ¯æ¬¡åœ°å€éƒ½ä¸ä¸€æ ·
        - æ€è·¯ï¼šEverything is a state machine
            + è§‚å¯ŸçŠ¶æ€æœºçš„ traceï¼Œå°±çŸ¥é“å“ªä¸ªæ˜¯é‡‘é’±äº†

    * æŸ¥æ‰¾ + Filter
        - è¿›å…¥æ¸¸æˆæ—¶ exp = 4950
        - æ‰“äº†ä¸ªæ€ª exp = 5100
        - ç¬¦åˆ 4950 â†’ 5100 å˜åŒ–çš„å†…å­˜åœ°å€æ˜¯å¾ˆå°‘çš„
            + å¥½äº†ï¼Œå‡ºé—¨å°±æ˜¯æ»¡çº§äº†

    knight.c: `sudo ./knight VirtualBoxVM` -> `s 5000` -> spend 800 -> `s 4200` -> `w 1000000`
    ```C
    #include <string>
    #include <vector>
    #include <algorithm>
    #include <iostream>
    #include <regex>
    #include <cstdio>
    #include <unistd.h>
    #include <fcntl.h>
    using std::string, std::to_string;

    struct Game {
        string name; // Name of the traced process
        int pid;     // Pid of the traced process
        int fd;      // Memory file of the traced process
        
        std::vector<uintptr_t> remain; // Watched addresses

    public:
        Game(string proc_name):
            name(proc_name),
            pid(stoi(run("pidof " + proc_name))) {

            // See: proc(5)
            string memfile = "/proc/" + to_string(pid) + "/mem";

            // We need root permission to open this file;
            // otherwise it would be too dangerous.
            fd = open(memfile.c_str(), O_RDWR);
            if (fd < 0) {
                perror(memfile.c_str());
                exit(1);
            }
        }

        ~Game() {
            close(fd);
        }

        void search_for(uint32_t val) {
            if (remain.size() == 0) {
                // No match. Start a new round of search.

                string maps = run("pmap -x " + to_string(pid));

                std::regex r(
                    R"(^([0-9a-f]+)\s+(\d+)\s+(\d+)\s+(\d+)\s+rw.*)"
                );

                std::istringstream iss(maps);
                for (string line; std::getline(iss, line); ) {
                    std::smatch match;
                    if (std::regex_search(line, match, r)) {
                        uintptr_t start = stoll(match[1].str(), nullptr, 16);
                        uintptr_t size = stoll(match[2], nullptr, 10) * 1024;
                        printf("Scanning %lx--%lx\n", start, start + size);

                        // Copy process memory to local
                        std::unique_ptr<uint32_t[]> mem(new uint32_t [size / 4]);
                        lseek(fd, start, SEEK_SET);
                        size = read(fd, mem.get(), size);

                        for (uintptr_t off = 0; off < size; off += 4) {
                            if (mem[off / 4] == val) {
                                // Found a match!
                                remain.push_back(start + off);
                            }
                        }
                    }
                }
            } else {
                // Search in the watched values.

                std::erase_if(remain, [this, val](uintptr_t addr) {
                    return load(addr) != val;
                });
            }
            printf("There are %ld match(es).\n", remain.size());
        }

        void reset() {
            remain.clear();
        }

        void overwrite(uint32_t val) {
            int nwrite = 0;
            for (uintptr_t addr : remain) {
                store(addr, val);
                nwrite++;
            }
            printf("%d value(s) written.\n", nwrite);
        }

    private:
        uint32_t load(uintptr_t addr) {
            // Load 32-bit value from another address space
            uint32_t val;
            lseek(fd, addr, SEEK_SET);
            read(fd, &val, sizeof(val));
            return val;
        }

        void store(uintptr_t addr, uint32_t val) {
            // Store 32-bit value to another address space
            lseek(fd, addr, SEEK_SET);
            write(fd, &val, sizeof(val));
        }

        static string run(const string &cmd) {
            std::array<char,128> buf;
            string result;

            FILE *pipe = popen(cmd.c_str(), "r");
            if (!pipe) {
                perror(cmd.c_str());
                exit(1);
            }

            while (fgets(buf.data(), buf.size(), pipe) != nullptr) {
                result += buf.data();
            }

            pclose(pipe);
            return result;
        }
    };


    int main(int argc, char *argv[]) {
        Game g(argv[1]);
        uint32_t val;
        char buf[64];

        printf(
            "Usage:\n"
            "  - s 100: search for value\n"
            "  - w 99999: overwrite value (for search matches)\n"
            "  - r: reset search\n\n"
        );

        while (!feof(stdin)) {
            printf("(%s %d) ", g.name.c_str(), g.pid);
            scanf("%s", buf);

            switch (buf[0]) {
                case 'q': return 0;
                case 's': scanf("%d", &val); g.search_for(val); break;
                case 'w': scanf("%d", &val); g.overwrite(val); break;
                case 'r': g.reset(); break;
            }
        }
    }
    ```

5. ç»™è¿›ç¨‹å‘é€ GUI (é”®ç›˜/é¼ æ ‡)äº‹ä»¶

    * åšä¸ªé©±åŠ¨ (å¯ç¼–ç¨‹é”®ç›˜/é¼ æ ‡)
    * åˆ©ç”¨æ“ä½œç³»ç»Ÿ/çª—å£ç®¡ç†å™¨æä¾›çš„ API
        - xdotool
        - ydotool
        - evdev (æŒ‰é”®æ˜¾ç¤ºè„šæœ¬ï¼›ä¸»æ’­å¸¸ç”¨)
    
    ä¾‹å­ï¼šå®ç°æŒ‰é”®ç²¾çµï¼Œå®ç°æŒ‰é”®ç²¾çµä¸å¿…å…¥ä¾µè¿›ç¨‹çš„åœ°å€ç©ºé—´ã€‚æ“ä½œç³»ç»Ÿç®¡ç†äº† I/O è®¾å¤‡ï¼Œæˆ‘ä»¬ç›¸åº”æ¨¡æ‹Ÿå‡ºæŒ‰é”®çš„äº‹ä»¶å³å¯ã€‚å½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ä¸ºè¿›ç¨‹åƒæ¸¸æˆä¿®æ”¹å™¨é‚£æ ·æ³¨å…¥æŒ‰é”®äº‹ä»¶ã€‚

    `sudo ./anjian`ï¼Œthen open https://js13kgames.com/games/spacebar-clicker/index.html
    ```bash
    #!/bin/bash

    # Needs sudo. Try:
    # https://js13kgames.com/games/spacebar-clicker/index.html

    echo 'Start in 5 seconds...'
    ydotoold &> /dev/null &
    sleep 5

    for _ in $(seq 1 200)
    do
        ydotool type ' '
        sleep 0.01
    done
    ```

6. æ”¹å˜è¿›ç¨‹å¯¹æ—¶é—´çš„æ„ŸçŸ¥

    ç¨‹åº = çŠ¶æ€æœº
    
    * â€œè®¡ç®—æŒ‡ä»¤â€ æ˜¯ä¸èƒ½æ„ŸçŸ¥æ—¶é—´çš„
        - spin count è®¡æ—¶ä¼šå‡ºç° â€œæœºå™¨å˜å¿«ï¼Œæ¸¸æˆæ²¡æ³•ç©â€ çš„æƒ…å†µ
        - syscall æ˜¯æ„ŸçŸ¥æ—¶é—´çš„å”¯ä¸€æ–¹æ³•
    
    * â€œåŠ«æŒâ€ å’Œæ—¶é—´ç›¸å…³çš„ syscall/åº“å‡½æ•°
        - æ”¹å˜ç¨‹åºå¯¹æ—¶é—´çš„è®¤çŸ¥
        - å°±åƒæ‰‹è¡¨è°ƒå¿«/æ…¢äº†ä¸€æ ·

    ä¾‹å­ï¼šå˜é€Ÿé½¿è½® `./gear 10 tetris`

    gearï¼šå®é™…ä¸Šå°±æ˜¯ä¸ªpythonè„šæœ¬ï¼Œè°ƒç”¨ gdb è°ƒè¯• tetris æ¸¸æˆï¼ŒåŠ«æŒ gettimeofday ç³»ç»Ÿè°ƒç”¨ï¼Œå®ç°å˜é€Ÿé½¿è½®ã€‚
    ```python
    #!/usr/bin/env python3

    import subprocess
    import sys

    try:
        ratio, exe = sys.argv[1:]
    except:
        print(f'Example: {sys.argv[0]} 10 tetris  # 10X speedup')
        exit(1)

    subprocess.run(
        [
            'gdb',
            '-ex', f'set $gear_ratio = {ratio}',
            '-x', 'gear-gdb.py',
            exe,
        ]
    )
    ```

    ```python
    import gdb
    import datetime

    ratio = float(gdb.parse_and_eval('$gear_ratio'))

    # Get the current time
    start = datetime.datetime.now()

    def hacked_time():
        now = datetime.datetime.now()
        
        # The speed of the clock is adjusted
        t = start + (now - start) * ratio

        tv_sec = int(t.timestamp())
        tv_usec = t.microsecond
        return (tv_sec, tv_usec)

    class SetTimevalBreakpoint(gdb.Breakpoint):
        def __init__(self):
            super(SetTimevalBreakpoint, self).__init__(
                'gettimeofday',
                gdb.BP_BREAKPOINT,
                internal=False
            )

        def stop(self):
            tv_sec, tv_usec = hacked_time()

            # Replace the function body
            gdb.execute(
                'set *(struct timeval *)($rdi) = {{ {}, {} }}'
                    .format(tv_sec, tv_usec)
            )
            gdb.execute('set $rax = 0')
            gdb.execute('return')

            return False  # Continue execution

    SetTimevalBreakpoint()
    gdb.execute('run')
    ```

7. è½¯ä»¶åŠ¨æ€æ›´æ–°ï¼šæˆ‘ä»¬å¯ä»¥é€šè¿‡ patch å‡½æ•°çš„å¤´éƒ¨ä¸ºä¸€ä¸ªè·³è½¬å®ç°å¯¹ä¸€ä¸ªå‡½æ•°çš„ â€œè¿è¡Œæ—¶çƒ­æ›´æ–°â€ã€‚

    ```C
    #include <stdio.h>
    #include <string.h>
    #include <sys/mman.h>
    #include <stdint.h>
    #include <assert.h>

    __attribute__((noinline)) void foo() {
        printf("In old function %s\n", __func__);
    }

    __attribute__((noinline)) void foo_new() {
        printf("In new function %s\n", __func__);
    }

    // 48 b8 (64-bit imm)   movabs $imm,%rax
    // ff e0                jmpq   *%rax
    const char PATCH[] = "\x48\xb8--------\xff\xe0";

    void DSU(void *func, void *func_new) {
        int flag = PROT_WRITE | PROT_READ | PROT_EXEC, rc, np;

        // Grant write permission to the memory
        // We must handle boundary cases
        uintptr_t fn = (uintptr_t)func;
        uintptr_t base = fn & ~0xfff;
        if (fn + sizeof(PATCH) > base + 4096) {
            np = 2;  // Cross page boundary
        } else {
            np = 1;
        }
        printf("np = %d\n", np);

        rc = mprotect((void *)base, np * 4096, flag);
        assert(rc == 0);  // Not expecting a failure
    
        // Patch the first instruction (this is UB in C spec)
        memcpy(func, PATCH, sizeof(PATCH));
        memcpy((char *)func + 2, &func_new, sizeof(func_new));

        // Revoke the write permission
        rc = mprotect((void *)base, np * 4096, PROT_READ | PROT_EXEC);
        assert(rc == 0);  // Not expecting a failure
    }

    int main() {
        setbuf(stdout, NULL);
        foo();
        DSU(foo, foo_new);  // Dynamic software update
        foo();
    }
    ```

## Lecture 16 ç³»ç»Ÿè°ƒç”¨å’ŒUNIX Shell
!!! abstract "Take-away Messages"

    é€šè¿‡ freestanding çš„ shellï¼Œæˆ‘ä»¬é˜é‡Šäº† â€œå¯ä»¥åœ¨ç³»ç»Ÿè°ƒç”¨ä¸Šåˆ›å»ºæ•´ä¸ªæ“ä½œç³»ç»Ÿåº”ç”¨ä¸–ç•Œâ€ çš„çœŸæ­£å«ä¹‰ï¼šæ“ä½œç³»ç»Ÿçš„ API å’Œåº”ç”¨ç¨‹åºæ˜¯äº’ç›¸æˆå°±ã€èºæ—‹ç”Ÿé•¿çš„ï¼šæœ‰äº†æ–°çš„åº”ç”¨éœ€æ±‚ï¼Œå°±æœ‰äº†æ–°çš„æ“ä½œç³»ç»ŸåŠŸèƒ½ã€‚è€Œ UNIX ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªéå¸¸ç²¾ç®€ã€ç¨³å®šçš„æ¥å£ (fork, execve, exit, pipe ,...)ï¼Œçºµç„¶æœ‰æ²‰é‡çš„å†å²è´Ÿæ‹…ï¼Œå®ƒåœ¨ä»Šå¤©ä¾ç„¶å·¥ä½œå¾—å¾ˆå¥½ã€‚

1. æ“ä½œç³»ç»Ÿå¯¹è±¡ï¼š

    * è¿›ç¨‹å’Œåœ°å€ç©ºé—´
        - è¿›ç¨‹ç®¡ç†ï¼šfork, execve, exit
        - å†…å­˜ç®¡ç†ï¼šmmap, munmap, mprotect
    * æ–‡ä»¶å’Œè®¾å¤‡
        - æ–‡ä»¶ï¼šæœ‰ â€œåå­—â€ çš„å¯¹è±¡ï¼Œä¾‹å¦‚å­—èŠ‚æµ (ç»ˆç«¯) æˆ–å­—èŠ‚åºåˆ— (æ™®é€šæ–‡ä»¶ï¼›åŒ…æ‹¬ /proc/*)
        - æ–‡ä»¶æè¿°ç¬¦ (file descriptorï¼ŒWindowsä¸­å«handleå¥æŸ„)ï¼š<span style="color:lightblue;">æŒ‡å‘æ“ä½œç³»ç»Ÿå¯¹è±¡çš„ â€œæŒ‡é’ˆâ€</span>
        - Everything is a fileï¼Œé€šè¿‡æŒ‡é’ˆå¯ä»¥è®¿é—® â€œä¸€åˆ‡â€
        - å¯¹è±¡çš„è®¿é—®éƒ½éœ€è¦æŒ‡é’ˆï¼šopen, close, read/write (è§£å¼•ç”¨), lseek (æŒ‡é’ˆå†…èµ‹å€¼/è¿ç®—), dup (æŒ‡é’ˆé—´èµ‹å€¼)
    * IPC Endpoints (Inter-Process Communicationï¼Œè¿›ç¨‹é—´é€šä¿¡)
        - ç®¡é“ï¼šä¸€ä¸ªç‰¹æ®Šçš„ â€œæ–‡ä»¶â€ (æµ)
            + ç”±è¯»è€…/å†™è€…å…±äº«
            + è¯»å£ï¼šæ”¯æŒ read `fd[0]`
            + å†™å£ï¼šæ”¯æŒ write `fd[1]`
        - åŒ¿åç®¡é“
            + è¿”å›ä¸¤ä¸ªæ–‡ä»¶æè¿°ç¬¦
            + è¿›ç¨‹åŒæ—¶æ‹¥æœ‰è¯»å£å’Œå†™å£
        ```C
        int pipe(int pipefd[2]);
        ```

2. æ–‡ä»¶æè¿°ç¬¦æ˜¯ä¸€ä¸ªç”¨äºè®¿é—®æ–‡ä»¶æˆ–å…¶ä»–è¾“å…¥/è¾“å‡ºèµ„æºçš„ â€œæŒ‡é’ˆâ€ã€‚åœ¨ Unix å’Œç±» Unix æ“ä½œç³»ç»Ÿä¸­ï¼Œæ–‡ä»¶æè¿°ç¬¦æ˜¯ä¸€ä¸ªéè´Ÿæ•´æ•°ï¼Œç”¨äºè¡¨ç¤ºä¸€ä¸ªæ‰“å¼€çš„æ–‡ä»¶ã€ç®¡é“ã€ç½‘ç»œè¿æ¥æˆ–å…¶ä»–ç±»ä¼¼çš„èµ„æºã€‚å½“ä¸€ä¸ªç¨‹åºæ‰“å¼€ä¸€ä¸ªæ–‡ä»¶æˆ–åˆ›å»ºä¸€ä¸ªæ•°æ®æµæ—¶ï¼Œæ“ä½œç³»ç»Ÿä¼šè¿”å›ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œç¨‹åºå¯ä»¥é€šè¿‡è¿™ä¸ªæè¿°ç¬¦æ¥è¯»å–ã€å†™å…¥æˆ–æ“ä½œå¯¹åº”çš„æ–‡ä»¶æˆ–èµ„æºã€‚

    ```C
    #include <stdio.h>
    #include <fcntl.h>
    #include <unistd.h>

    void try_open(const char *fname) {
        int fd = open(fname, O_RDWR);
        // fd is a "pointer" to a kernel object.

        printf("open(\"%s\") = %d\n", fname, fd);

        if (fd < 0) {
            perror(fname);
            goto release;
        } else {
            // ...
        }

    release:
        if (fd >= 0) {
            close(fd);
        }
    }

    int main() {
        try_open("/something/not/exist");
        try_open("/dev/sda"); // hard drive
    }
    ```

3. UNIX ç®¡é“ (pipe) æ˜¯ä¸€ç§å…¸å‹çš„è¿›ç¨‹é—´é€šä¿¡æœºåˆ¶ï¼Œå…è®¸æ•°æ®åœ¨ä¸åŒçš„è¿›ç¨‹ä¹‹é—´å•å‘æµåŠ¨ã€‚ç®¡é“å¯ä»¥è¢«è§†ä¸ºä¸€ç§ç‰¹æ®Šçš„æ–‡ä»¶ï¼Œå…¶ä¸­ä¸€ä¸ªè¿›ç¨‹å°†æ•°æ®å†™å…¥ç®¡é“çš„ä¸€ç«¯ï¼Œè€Œå¦ä¸€ä¸ªè¿›ç¨‹ä»å¦ä¸€ç«¯è¯»å–æ•°æ®ã€‚

    * pipe read åœ¨æ²¡æœ‰æ•°æ®æ—¶ä¼šç­‰å¾…
    * pipe write åœ¨æœ‰è¯»è€…æ‰“å¼€æ—¶ï¼Œä¼šå†™å…¥æ“ä½œç³»ç»Ÿçš„ç¼“å†²åŒºå¹¶è¿”å›
    * write å¦‚æœ â€œä¸å¤ªå¤šâ€ï¼Œä¸€å¯¹ write-read æ˜¯åŸå­çš„
    * write å¦‚æœè¶…è¿‡ PIPE_BUFï¼Œå¯èƒ½ä¼šè¢«æ‹†æˆå¤šä»½
    * å¦‚æœè¯»è€…å…³é—­ï¼Œä¼šæ”¶åˆ° SIGPIPE ä¿¡å·
        - ç»å¸¸çœ‹åˆ°çš„ â€œBroken Pipeâ€
    * â€œçœ‹ä¸åˆ°â€ çš„ SIGPIPE
        - `yes | head -n 1`
        - `(yes; echo $? > /dev/stderr) | head -n 1` (è¿”å›141è€Œé0ï¼Œæ‰€ä»¥å®é™…ä¸Šè¿˜æ˜¯æœ‰SIGPIPEå‘ç”Ÿ)
    * â€œçœ‹å¾—åˆ°â€ çš„ SIGPIPE
        - `python3 -c 'while True: print(1)' | head -n 1`

    ![alt text](../img/image-14.png)

    named_pipe.c:
    ```C
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <fcntl.h>
    #include <sys/stat.h>
    #include <unistd.h>
    #include <errno.h>

    // We also have UNIX domain sockets for local inter-process
    // communication--they also have a name in the file system
    // like "/var/run/docker.sock". This is similar to a named
    // pipe.
    #define PIPE_NAME "/tmp/my_pipe"

    void pipe_read() {
        int fd = open(PIPE_NAME, O_RDONLY);
        char buffer[1024];

        if (fd == -1) {
            perror("open");
            exit(1);
        }

        // Read from the pipe
        int num_read = read(fd, buffer, sizeof(buffer));
        if (num_read > 0) {
            printf("Received: %s\n", buffer);
        } else {
            printf("No data received.\n");
        }
        close(fd);
    }

    void pipe_write(const char *content) {
        // Open the pipe for writing
        int fd = open(PIPE_NAME, O_WRONLY);

        if (fd == -1) {
            perror("open");
            exit(1);
        }

        // Write the message to the pipe
        write(fd, content, strlen(content) + 1);
        close(fd);
    }

    int main(int argc, char *argv[]) {
        if (argc < 2) {
            fprintf(stderr, "Usage: %s read|write [message]\n", argv[0]);
            return 1;
        }

        // Create the named pipe if it does not exist
        if (mkfifo(PIPE_NAME, 0666) == -1) {
            if (errno != EEXIST) {
                perror("mkfifo");
                return 1;
            }
        } else {
            printf("Created " PIPE_NAME "\n");
        }

        if (strcmp(argv[1], "read") == 0) {
            pipe_read();
        } else if (strcmp(argv[1], "write") == 0) {
            pipe_write(argv[2]);
        } else {
            fprintf(stderr, "Invalid command. Use 'read' or 'write'.\n");
            return 1;
        }

        return 0;
    }
    ```

    anonymous-pipe.cï¼šçˆ¶è¿›ç¨‹æŒæœ‰å†™å£ï¼Œå­è¿›ç¨‹æŒæœ‰è¯»å£ã€‚
    ```C
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <string.h>
    #include <sys/wait.h>

    void do_parent(int fd) {
        const char *msg = "Hello, world!";

        printf("[%d] Write: '%s'\n", getpid(), msg);
        write(fd, msg, strlen(msg) + 1);

        close(fd);

        // Wait for the child to finish
        wait(NULL);

        printf("[%d] Done.\n", getpid());
    }

    void do_child(int fd) {
        static char buf[1024];

        ssize_t num_read = read(fd, buf, sizeof(buf));
        if (num_read == -1) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        printf("[%d] Got: '%s'\n", getpid(), buf);

        // Close the read end of the pipe
        close(fd);
    }

    int main() {
        int pipefd[2];

        // Create a pipe
        if (pipe(pipefd) == -1) {
            perror("pipe");
            exit(EXIT_FAILURE);
        }

        // Fork the current process
        pid_t pid = fork();
        if (pid == -1) {
            perror("fork");
            exit(EXIT_FAILURE);
        }

        if (pid == 0) {
            // Child
            close(pipefd[1]); // Close unused write end
            do_child(pipefd[0]);
        } else {
            // Parent
            close(pipefd[0]); // Close unused read end
            do_parent(pipefd[1]);
        }

        return 0;
    }
    ```

4. sh.c debugï¼šå¯ä»¥æ¸…æ¥šåœ°çœ‹åˆ°ï¼Œè¿›ç¨‹3çš„æ ‡å‡†è¾“å‡º`1`å‘ç®¡é“é‡Œå†™æ•°æ®ï¼Œç„¶åæ‰§è¡Œ`runcmd(pcmd->left);`è¿›ç¨‹4çš„æ ‡å‡†è¾“å…¥`0`ä»ç®¡é“é‡Œè¯»æ•°æ®ï¼Œç„¶åæ‰§è¡Œ`runcmd(pcmd->right);`


    ```bash
    Process 3 (11026)
    0 <-> /dev/pts/7
    1 --> [=== 2123156 ===]
    2 <-> /dev/pts/7

    Process 4 (11699)*
        0 <-- [=== 2123156 ===]
        1 <-> /dev/pts/7
        2 <-> /dev/pts/7

    112                 runcmd(pcmd->right);
    ```

5. ä»¥ä¸‹æŠ¥é”™çš„åŸå› ï¼š`>`å’Œ`|`ä¸€æ ·ï¼Œéƒ½æ˜¯å…ˆæŠŠä¸¤è¾¹çš„æ–‡ä»¶æè¿°ç¬¦å‡†å¤‡å¥½ï¼Œä¹Ÿå°±æ˜¯è¯´`sudo echo hello`å’Œæ‰“å¼€`/etc/a.txt`æ˜¯åˆ†å¼€æ‰§è¡Œçš„ï¼Œå› æ­¤æ— æƒé™æ‰“å¼€`/etc/a.txt`

    ```bash
    $ echo hello > /etc/a.txt
    bash: /etc/a.txt: Permission denied

    $ sudo echo hello > /etc/a.txt
    bash: /etc/a.txt: Permission denied
    ```

## Lecture 17 C æ ‡å‡†åº“å’Œå®ç°
!!! abstract "Take-away Messages"

    åœ¨ç³»ç»Ÿè°ƒç”¨å’Œè¯­è¨€æœºåˆ¶çš„åŸºç¡€ä¸Šï¼Œlibc ä¸ºæˆ‘ä»¬æä¾›äº†å¼€å‘è·¨å¹³å°åº”ç”¨ç¨‹åºçš„ â€œç¬¬ä¸€çº§æŠ½è±¡â€ã€‚åœ¨æ­¤åŸºç¡€ä¸Šæ„å»ºèµ·äº†ä¸‡åƒä¸–ç•Œï¼šC++ (æ‰©å……äº† C æ ‡å‡†åº“)ã€Javaã€æµè§ˆå™¨ä¸–ç•Œâ€¦â€¦ä»Šå¤©ï¼ŒC è¯­è¨€åœ¨åº”ç”¨å¼€å‘æ–¹é¢æœ‰å¾ˆå¤šç¼ºé™·ï¼Œä½†ä»ç„¶ä¸º â€œç¬¬ä¸€çº§æŠ½è±¡â€ æä¾›äº†ä¸€ä¸ªæœ‰è¶£çš„èŒƒæœ¬ã€‚

1. Cé‡Œçš„ `_start` å‡½æ•°æ˜¯ç¨‹åºæ‰§è¡Œçš„èµ·ç‚¹ã€‚å½“ä¸€ä¸ªCç¨‹åºè¢«ç¼–è¯‘å’Œé“¾æ¥æˆå¯æ‰§è¡Œæ–‡ä»¶åï¼Œæ“ä½œç³»ç»Ÿä¼šå°†ç¨‹åºåŠ è½½åˆ°å†…å­˜ä¸­ï¼Œå¹¶è·³è½¬åˆ° `_start` å‡½æ•°å¼€å§‹æ‰§è¡Œã€‚`_start` å‡½æ•°é€šå¸¸æ˜¯ç”±ç¼–è¯‘å™¨å’Œé“¾æ¥å™¨è‡ªåŠ¨ç”Ÿæˆçš„ï¼Œå®ƒè´Ÿè´£åˆå§‹åŒ–ç¨‹åºè¿è¡Œæ‰€éœ€çš„ç¯å¢ƒï¼Œç„¶åè°ƒç”¨ `main` å‡½æ•°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ`_start`å‡½æ•°æ˜¯æ“ä½œç³»ç»Ÿå’ŒäºŒè¿›åˆ¶æ–‡ä»¶ä¹‹é—´çš„çº¦å®šï¼ˆåœ¨libcé‡Œçš„Scrt1.oä¼šå¸®å¿™å®šä¹‰å¥½ï¼‰ã€‚ä»¥ä¸‹å¯ä»¥çœ‹åˆ°Entry point addressæ˜¯0x4019f5ï¼Œæ­£æ˜¯`_start`çš„åœ°å€ã€‚

    ```bash
    linux$ readelf -h sh
    ELF Header:
    Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
    Class:                             ELF64
    Data:                              2's complement, little endian
    Version:                           1 (current)
    OS/ABI:                            UNIX - System V
    ABI Version:                       0
    Type:                              EXEC (Executable file)
    Machine:                           Advanced Micro Devices X86-64
    Version:                           0x1
    Entry point address:               0x4019f5
    Start of program headers:          64 (bytes into file)
    Start of section headers:          23696 (bytes into file)
    Flags:                             0x0
    Size of this header:               64 (bytes)
    Size of program headers:           56 (bytes)
    Number of program headers:         8
    Size of section headers:           64 (bytes)
    Number of section headers:         19
    Section header string table index: 18

    linux$ objdump -d sh | less
    00000000004019f5 <_start>:
    4019f5:       f3 0f 1e fa             endbr64 
    4019f9:       55                      push   %rbp
    4019fa:       48 89 e5                mov    %rsp,%rbp
    4019fd:       b8 00 00 00 00          mov    $0x0,%eax
    401a02:       e8 e9 fe ff ff          call   4018f0 <main>
    401a07:       be 00 00 00 00          mov    $0x0,%esi
    401a0c:       bf 3c 00 00 00          mov    $0x3c,%edi
    401a11:       b8 00 00 00 00          mov    $0x0,%eax
    401a16:       e8 e5 f5 ff ff          call   401000 <syscall>
    401a1b:       90                      nop
    401a1c:       5d                      pop    %rbp
    401a1d:       c3                      ret
    ```

2. <span style="color:lightblue;">ç³»ç»Ÿè°ƒç”¨æ˜¯åœ°åŸºï¼ŒC è¯­è¨€æ˜¯æ¡†æ¶ã€‚</span>glibc çš„ä»£ç æœ‰éå¸¸æ²‰é‡çš„å†å²åŒ…è¢±ï¼Œæ›´é€‚åˆå­¦ä¹ çš„ libc å®ç°ï¼š[musl libc](https://musl.libc.org/)

    ä½¿ç”¨musl-gccæ¥ç¼–è¯‘ï¼Œè€Œä¸æ˜¯gccï¼Œçœ‹ä¸‹musl-gccçš„çœŸé¢ç›®ï¼šmusl-gccé€šè¿‡.specsè„šæœ¬æ¥æ§åˆ¶ç¼–è¯‘å™¨ä¸è¦é“¾æ¥glibcè€Œæ˜¯é“¾æ¥è‡ªå·±çš„libcã€‚
    
    ```bash
    linux$ cat (which musl-gcc)
    #!/bin/sh
    exec "${REALGCC:-x86_64-linux-gnu-gcc}" "$@" -specs "/usr/lib/x86_64-linux-musl/musl-gcc.specs"
    ```

3. debug dummy.c

    ```C
    int main() {
        return 1;
    }
    ```

    <figure markdown> 
        ![Image title](../img/image-15.png){ width="300" }
        <figcaption>æ“ä½œç³»ç»Ÿå°†è¿™äº›å†…å®¹æ”¾å…¥æ ˆä¸­</figcaption>
    </figure>

    env.cï¼š

    ```C
    #include <stdio.h>

    // A mysteriously defined symbol.
    // Someone must defined it elsewhere.
    extern char **environ;

    // Like this even more mysterious one.
    // "end" can be of any type.
    extern void ******************************end;

    int main(int argc, char *argv[], char *envp[]) {
        printf("environ: %p\n", environ);
        printf("envp:    %p\n", envp);

        for (char **env = environ; *env; env++) {
            // key=value
            printf("%s\n", *env);
        }

        end = NULL; // ???
    }
    ```

    è¾“å‡º:

    ```bash
    environ: 0x7ffdb556d2d8
    envp:    0x7ffdb556d2d8
    SHELL=/bin/bash
    COLORTERM=truecolor
    ...
    ```

    <a id="system-v-abi"></a>
    [System V ABI](https://jyywiki.cn/OS/manuals/sysv-abi.pdf)é‡Œå®šä¹‰äº†è§„èŒƒï¼š

    ![alt text](../img/image-16.png){ width="500" }

    å…¶ä»–çŠ¶æ€ (ä¸»è¦æ˜¯å†…å­˜) åˆ™æ˜¯ç”±å¯æ‰§è¡Œæ–‡ä»¶æŒ‡å®šï¼Œè¯¦æƒ…çœ‹[Lecture 19](#minimal-loader)ã€‚

4. libcå¯¹ç³»ç»Ÿè°ƒç”¨ä¸ç¯å¢ƒçš„æŠ½è±¡

    ä»€ä¹ˆæ˜¯stdoutï¼Ÿ

    ```C
    static unsigned char buf[BUFSIZ+UNGET];
    hidden FILE __stdout_FILE = {
        .buf = buf+UNGET,
        .buf_size = sizeof buf-UNGET,
        .fd = 1,
        .flags = F_PERM | F_NORD,
        .lbf = '\n',
        .write = __stdout_write,
        .seek = __stdio_seek,
        .close = __stdio_close,
        .lock = -1,
    };
    FILE *const stdout = &__stdout_FILE;
    ```

5. æ‰€æœ‰ API éƒ½å¯èƒ½å¤±è´¥ï¼Œerrno æ˜¯è¿›ç¨‹å…±äº«è¿˜æ˜¯çº¿ç¨‹ç‹¬äº«ï¼Ÿâ¡ï¸ çº¿ç¨‹ç‹¬äº«ï¼Œgdbè°ƒè¯•å¯ä»¥çœ‹åˆ°errnoæ˜¯tls (Thread Local Storage)çš„ã€‚

6. malloc() çš„è§‚å¯Ÿï¼šæˆ‘ä»¬éœ€è¦ç®¡ç†çš„å¯¹è±¡
    * å°å¯¹è±¡ï¼šå­—ç¬¦ä¸²ã€ä¸´æ—¶å¯¹è±¡ç­‰ï¼›ç”Ÿå­˜å‘¨æœŸå¯é•¿å¯çŸ­
    * ä¸­å¯¹è±¡ï¼šå®¹å™¨ã€å¤æ‚çš„å¯¹è±¡ï¼›æ›´é•¿çš„ç”Ÿå­˜å‘¨æœŸ
    * å¤§å¯¹è±¡ï¼šå·¨å¤§çš„å®¹å™¨ã€åˆ†é…å™¨ï¼›å¾ˆé•¿çš„ç”Ÿå­˜å‘¨æœŸ

    è®¾ç½®ä¸¤å¥—ç³»ç»Ÿï¼š

    * Fast path (System I)
        - æ€§èƒ½æå¥½ã€å¹¶è¡Œåº¦æé«˜ã€è¦†ç›–å¤§éƒ¨åˆ†æƒ…å†µ
        - ä½†æœ‰å°æ¦‚ç‡ä¼šå¤±è´¥ (fall back to slow path)
    * Slow path (System II)
        - ä¸åœ¨ä¹é‚£ä¹ˆå¿«
        - ä½†æŠŠå›°éš¾çš„äº‹æƒ…åšå¥½
    * è®¡ç®—æœºç³»ç»Ÿé‡Œæœ‰å¾ˆå¤šè¿™æ ·çš„ä¾‹å­ (æ¯”å¦‚ cache)

    malloc: Fast Path è®¾è®¡ â¡ï¸ ç«‹å³åœ¨çº¿ç¨‹æœ¬åœ°åˆ†é…å®Œæˆã€‚æµªè´¹ä¸€ç‚¹ç©ºé—´ï¼Œä½†ä½¿æ‰€æœ‰ CPU éƒ½èƒ½å¹¶è¡Œåœ°ç”³è¯·å†…å­˜
    
    * çº¿ç¨‹éƒ½äº‹å…ˆç“œåˆ†ä¸€äº› â€œé¢†åœ°â€ (thread-local allocation buffer)
    * é»˜è®¤ä»è‡ªå·±çš„é¢†åœ°é‡Œåˆ†é…
        - é™¤äº†åœ¨å¦ä¸€ä¸ª CPU é‡Šæ”¾ï¼Œacquire lock å‡ ä¹æ€»æ˜¯æˆåŠŸ
    * å¦‚æœè‡ªå·±çš„é¢†åœ°ä¸è¶³ï¼Œå°±ä»å…¨å±€çš„æ± å­é‡Œå€Ÿä¸€ç‚¹

    malloc: Slow Path è®¾è®¡ â¡ï¸ pgalloc()

7. å¦‚ä½•è°ƒè¯•è¿›å…¥ musl libc

    ```bash
    tar -xzf musl-1.2.5.tar.gz  # è§£å‹åè¿›å…¥
    cd musl-1.2.5
    ./configure --enable-debug  # è¿™æ­¥æ˜¯å…³é”®!
    make && make install        # ç¼–è¯‘å¹¶å®‰è£…åˆ° /usr/local/musl
    echo 'export PATH="/usr/local/musl/bin:$PATH"' >>  ~/.bashrc
    source ~/.bashrc            # ä¿®æ”¹ç¯å¢ƒå˜é‡ path å¹¶ç”Ÿæ•ˆ
    ```

## Lecture 18 Linux æ“ä½œç³»ç»Ÿ
!!! abstract "Take-away Messages"

    æˆ‘ä»¬ä» CPU Reset åçš„ â€œç¡¬ä»¶åˆå§‹çŠ¶æ€â€ åˆ°æ“ä½œç³»ç»ŸåŠ è½½å®Œ init è¿›ç¨‹åçš„ â€œè½¯ä»¶åˆå§‹çŠ¶æ€â€ï¼Œä»æ­¤ä»¥åï¼Œè®¡ç®—æœºç³»ç»Ÿä¸­çš„ä¸€åˆ‡éƒ½æ˜¯ç”±åº”ç”¨ç¨‹åºä¸»å¯¼çš„ï¼Œæ“ä½œç³»ç»Ÿåªæ˜¯æä¾›ç³»ç»Ÿè°ƒç”¨è¿™ä¸€æœåŠ¡æ¥å£ã€‚æ­£æ˜¯ç³»ç»Ÿè°ƒç”¨ (åŒ…æ‹¬æ“ä½œç³»ç»Ÿä¸­çš„å¯¹è±¡) è¿™ä¸ªç¨³å®šçš„ã€å‘åå…¼å®¹çš„æ¥å£éšç€å†å²æ¼”åŒ–å’Œç§¯ç´¯ï¼Œå½¢æˆäº†éš¾ä»¥é€¾è¶Šçš„æŠ€æœ¯å±éšœï¼Œåœ¨é¢ è¦†æ€§çš„æŠ€æœ¯é©æ–°åˆ°æ¥ä¹‹å‰ï¼Œå¦èµ·ç‚‰ç¶éƒ½æ˜¯éå¸¸å›°éš¾çš„ã€‚

1. å¯åŠ¨ Linux - Initial RAM FS

    ç¡¬ä»¶ (ISA) â†’ æ“ä½œç³»ç»Ÿå¯¹è±¡/ç³»ç»Ÿè°ƒç”¨ â†’ libc â†’ ç³»ç»Ÿå·¥å…· (coretuils, busybox, ...) â†’ åº”ç”¨ç¨‹åº (xfce, vscode)

    ```bash
    make initramfs # éœ€è¦/boot/vmlinuzï¼Œwslé‡Œæ²¡æœ‰ï¼Œå°±æ²¡æœ‰åšä¸‹å»äº†
    make
    make run
    /bin/busybox ls
    ```

    ```bash
    exec switch_root /newroot/ /init
    # switch_root ç¨‹åºé¦–å…ˆå°†å½“å‰çš„æ ¹æ–‡ä»¶ç³»ç»Ÿï¼ˆinitramfsï¼‰å¸è½½ã€‚
    # ç„¶åï¼Œå®ƒå°†æ–°æ ¹æ–‡ä»¶ç³»ç»Ÿï¼ˆ/newroot/ï¼‰æŒ‚è½½åˆ° / ç›®å½•ã€‚
    # æ¥ä¸‹æ¥ï¼Œå®ƒæ‰§è¡Œæ–°æ ¹æ–‡ä»¶ç³»ç»Ÿä¸­çš„åˆå§‹åŒ–ç¨‹åº /initï¼Œä»¥å¯åŠ¨ç³»ç»Ÿçš„åˆå§‹åŒ–è¿›ç¨‹ã€‚
    # æœ€åï¼Œå½“å‰çš„ shell è¿›ç¨‹è¢«æ›¿æ¢ä¸ºæ–°çš„åˆå§‹åŒ–è¿›ç¨‹ï¼Œç³»ç»Ÿç»§ç»­å¯åŠ¨ã€‚
    # (execï¼šè¿™æ˜¯ä¸€ä¸ª shell å†…ç½®å‘½ä»¤ï¼Œç”¨äºæ‰§è¡ŒæŒ‡å®šçš„å‘½ä»¤å¹¶æ›¿æ¢å½“å‰çš„ shell è¿›ç¨‹ã€‚)
    ```

    æœ€å° Linux: æˆ‘ä»¬å¯ä»¥åœ¨ initramfs ä¸­æ”¾ç½®ä»»æ„çš„æ•°æ®â€”â€”åŒ…æ‹¬åº”ç”¨ç¨‹åºã€å†…æ ¸æ¨¡å— (é©±åŠ¨)ã€æ•°æ®ã€è„šæœ¬â€¦â€¦æ“ä½œç³»ç»Ÿä¸–ç•Œå·²ç»å¼€å§‹è¿è½¬ï¼›ä½†ç›´åˆ°æ‰§è¡Œ switch_root (pivot_root) (æ³¨æ„è°ƒç”¨switch_rootçš„pidå¿…é¡»æ˜¯1)ï¼Œæ‰çœŸæ­£å¼€å§‹ ä»Šå¤© Linux åº”ç”¨ä¸–ç•Œ (systemd) çš„å¯åŠ¨ã€‚

    ```bash
    linux$ ls /sbin/init # ç°ä»£çš„Linuxå¯åŠ¨ç”¨çš„æ˜¯/sbin/init
    lrwxrwxrwx /sbin/init -> /lib/systemd/systemd
    ```

2. Initramfs: å¹¶ä¸æ˜¯æˆ‘ä»¬å®é™…çœ‹åˆ°çš„ Linux

    å¯åŠ¨çš„åˆçº§é˜¶æ®µ

    * åŠ è½½å‰©ä½™å¿…è¦çš„é©±åŠ¨ç¨‹åºï¼Œä¾‹å¦‚ç£ç›˜/ç½‘å¡
    * æŒ‚è½½å¿…è¦çš„æ–‡ä»¶ç³»ç»Ÿ
    * å°†æ ¹æ–‡ä»¶ç³»ç»Ÿå’Œæ§åˆ¶æƒç§»äº¤ç»™å¦ä¸€ä¸ªç¨‹åºï¼Œä¾‹å¦‚ systemd (system and service manager)

    å¯åŠ¨çš„ç¬¬äºŒçº§é˜¶æ®µ

    * çœ‹ä¸€çœ‹ç³»ç»Ÿé‡Œçš„ /sbin/init æ˜¯ä»€ä¹ˆï¼Ÿ
    * è®¡ç®—æœºç³»ç»Ÿæ²¡æœ‰é­”æ³• (ä¸€åˆ‡éƒ½æœ‰åˆé€‚çš„è§£é‡Š)
        - pstree åŸ‹ä¸‹çš„ä¼ç¬”å¾—åˆ°è§£ç­”ï¼špstreeè¾“å‡ºçš„æ ¹æ˜¯systemd

    ```bash
    linux$ pstree
    systemdâ”€â”¬â”€.vasdâ”€â”€â”€.vasdâ”€â”€â”€4*[.vasd]
            â”œâ”€ModemManagerâ”€â”€â”€2*[{ModemManager}]
            â”œâ”€NetworkManagerâ”€â”€â”€2*[{NetworkManager}]
            â”œâ”€accounts-daemonâ”€â”€â”€2*[{accounts-daemon}]
            â”œâ”€acpid
            â”œâ”€at-spi-bus-launâ”€â”¬â”€dbus-daemon
            â”‚                 â””â”€3*[{at-spi-bus-laun}]
            â”œâ”€at-spi2-registrâ”€â”€â”€2*[{at-spi2-registr}]
            â”œâ”€avahi-daemonâ”€â”€â”€avahi-daemon
            â”œâ”€colordâ”€â”€â”€2*[{colord}]
            â”œâ”€containerdâ”€â”€â”€11*[{containerd}]
            â”œâ”€containerd-shimâ”€â”¬â”€dumb-initâ”€â”¬â”€bashâ”€â”€â”€Xvfb
            â”‚                 â”‚           â”œâ”€2*[conhost.exe]
            â”‚                 â”‚           â”œâ”€...
            â”‚                 â”‚           â””â”€wineserver
            â”‚                 â””â”€12*[{containerd-shim}]
            â”œâ”€containerd-shimâ”€â”¬â”€dumb-initâ”€â”¬â”€bashâ”€â”€â”€Xvfb
            â”‚                 â”‚           â””â”€mount.ntfs
            â”‚                 â””â”€12*[{containerd-shim}]
            â”œâ”€3*[containerd-shimâ”€â”¬â”€dumb-initâ”€â”¬â”€bashâ”€â”€â”€Xvfb]
            â”‚                    â”‚           â””â”€mount.ntfs]
            â”‚                    â””â”€11*[{containerd-shim}]]
            â”œâ”€cron
            â”œ...
            â””â”€xrdp-sesman
    ```


## Lecture 19 å¯æ‰§è¡Œæ–‡ä»¶å’ŒåŠ è½½
!!! abstract "Take-away Messages"

    å¯æ‰§è¡Œæ–‡ä»¶æ˜¯ä¸€ä¸ªæè¿°çŠ¶æ€æœºåˆå§‹çŠ¶æ€çš„æ•°æ®ç»“æ„ (å­—èŠ‚åºåˆ—)ï¼›åŠ è½½å™¨å°±æ˜¯æŠŠè¿™ä¸ª â€œåˆå§‹çŠ¶æ€â€ æ¬è¿åˆ°æ“ä½œç³»ç»Ÿä¸­çš„ç¨‹åºã€‚ç”¨æ•°æ®ç»“æ„çš„çœ¼å…‰çœ‹å¯æ‰§è¡Œæ–‡ä»¶ï¼Œå°±ä¸éš¾å‘ç°å®ƒä¸å¥½é˜…è¯»çš„åŸå› ï¼šå®ƒçš„è®¾è®¡è€…å¹¶æ²¡æœ‰æ‰“ç®—è®©ä½ é˜…è¯»å®ƒã€‚è¿™æ ·çš„éš¾é¢˜åœ¨ã€Šæ“ä½œç³»ç»Ÿã€‹è¯¾ç¨‹ä¸­ç»å¸¸å‡ºç°ï¼›è€Œæˆ‘ä»¬çš„åº”å¯¹æ–¹æ³•æ˜¯å…ˆç†è§£ä¸€ä¸ªç²—ç³™ä½†é‡è¦çš„æ¨¡å‹ï¼Œç„¶ååœ¨æ­¤åŸºç¡€ä¸Šç†è§£å·¥ä¸šçº§å®ç°é¢ä¸´çš„æŒ‘æˆ˜å’Œé—®é¢˜ã€‚

1. ä»€ä¹ˆæ˜¯å¯æ‰§è¡Œæ–‡ä»¶ï¼Ÿâ¡ï¸ è¿›ç¨‹åˆå§‹çŠ¶æ€çš„æè¿°

    * ä¸€ä¸ªæ“ä½œç³»ç»Ÿä¸­çš„å¯¹è±¡ (æ–‡ä»¶)
    * ä¸€ä¸ªå­—èŠ‚åºåˆ— (æˆ‘ä»¬å¯ä»¥æŠŠå®ƒå½“å­—ç¬¦ä¸²ç¼–è¾‘)
    * ä¸€ä¸ªæè¿°äº†çŠ¶æ€æœºåˆå§‹çŠ¶æ€çš„æ•°æ®ç»“æ„

    ELF: Executable and Linkable Formatï¼Œ[binutils](https://www.gnu.org/software/binutils/) ä¸­çš„å·¥å…·å¯ä»¥è®©æˆ‘ä»¬æŸ¥çœ‹å…¶ä¸­çš„é‡è¦ä¿¡æ¯

2. UNIX a.out â¡ï¸ â€œassembler outputâ€
    
    ä»¥å‰çš„ç‰ˆæœ¬ï¼šä¸€ä¸ªç›¸å¯¹å¹³å¦çš„æ•°æ®ç»“æ„

    ```C
    struct exec {
        uint32_t  a_midmag;  // Machine ID & Magic
        uint32_t  a_text;    // Text segment size
        uint32_t  a_data;    // Data segment size
        uint32_t  a_bss;     // BSS segment size (å­˜å‚¨æœªåˆå§‹åŒ–çš„å…¨å±€å˜é‡å’Œé™æ€å˜é‡)
        uint32_t  a_syms;    // Symbol table size
        uint32_t  a_entry;   // Entry point
        uint32_t  a_trsize;  // Text reloc table size
        uint32_t  a_drsize;  // Data reloc table size
    };
    ```

3. Funny Linkable Executable

    æ ¸å¿ƒè®¾è®¡æ€è·¯

    * ä¸€åˆ‡éƒ½å¯¹äººç±»ç›´æ¥å¯è¯» (æ‰€æœ‰ä¿¡æ¯éƒ½åœ¨å±€éƒ¨)
    * å›å½’é“¾æ¥å’ŒåŠ è½½ä¸­çš„æ ¸å¿ƒæ¦‚å¿µï¼š<span style="color:lightblue;">ä»£ç ã€ç¬¦å·ã€é‡å®šä½</span> (å¤šä¸ªæ–‡ä»¶é“¾æ¥èµ·æ¥å¿…éœ€ç¬¦å·ã€é‡å®šä½ã€‚ç¬¦å·ï¼šmainå‡½æ•°é‡Œä¸€ä¸ªglobalçš„å˜é‡xï¼Œåˆ«äººå¯ä»¥ç”¨å®ƒï¼›é‡å®šä½ï¼šæˆ‘ç”¨äº†ä¸€ä¸ªå˜é‡xï¼Œæ˜¯åˆ«äººå®šä¹‰çš„)

    ä»£ç  (ğŸ”¢)ã€ç¬¦å· (ğŸ“¤)ã€é‡å®šä½ (â“)ï¼šå‡‘é½è¿™ä¸‰è¦ç´ ï¼Œæˆ‘ä»¬å°±å¯ä»¥åšå¯æ‰§è¡Œæ–‡ä»¶äº†ï¼

    ```C
    ğŸ”¢: ff ff ff ff ff ff ff
    ğŸ”¢: ff ff ff ff ff ff ff
    ğŸ“¤: _start
    ğŸ”¢: 48 c7 c0 3c 00 00 00
    ğŸ”¢: 48 c7 c7 2a 00 00 00
                  ^
                  |
            This byte is return code (42).
    ğŸ”¢: 0f 05 ff ff ff ff ff
    ğŸ”¢: ff ff ff ff ff ff ff
    â“: i32(unresolved_symbol - 0x4 - ğŸ“)
    ```

    ```bash
    linux$ ./minimal.fle ; echo $?
    42    # å¯¹åº”äºminimal.fleé‡Œçš„ 2a (return code)
    ```

    å¼€å¤´çš„`48 c7`æ˜¯moveæŒ‡ä»¤ï¼Œç»“å°¾çš„`0f 05`æ˜¯syscallæŒ‡ä»¤ã€‚

4. foo.c

    ```C
    #include "minilib.h"

    // Global data
    extern int n;
    char msg[] = "Hello World!\n";

    int foo() {
        return n;
    }
    ```

    ```bash
    linux$ make
    ./cc -Wall -g -Os foo.c -o foo.o
    ./cc -Wall -g -Os libc.c -o libc.o
    ./cc -Wall -g -Os main.c -o main.o
    ./ld foo.fle libc.fle main.fle -o hello
    ```

    foo.fle

    ```C
    {
        "type": ".obj",
        ".text": [
            "ğŸ·ï¸: _text",
            "ğŸ“¤: foo",
            "ğŸ”¢: f3 0f 1e fa 8b 05",
            "â“: i32(n - 0x4 - ğŸ“)",
            "ğŸ”¢: c3"
        ],
        ".data": [
            "ğŸ“¤: msg",
            "ğŸ”¢: 48 65 6c 6c 6f 20 57 6f 72 6c 64 21 0a 00"
        ],
        ".bss": []
    }
    ```
5. ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶

    (1) é¢„å¤„ç†

    * æºä»£ç  (.c) â†’ æºä»£ç  (.i)          â¡ï¸ `gcc -E foo.c -o foo.i`
    * Ctrl-C & Ctrl-V (#include)
    * å­—ç¬¦ä¸²æ›¿æ¢
    * ä»Šå¤©ï¼šæˆ‘ä»¬æœ‰[è¿‡ç¨‹å®](https://doc.rust-lang.org/reference/procedural-macros.html)

    (2) ç¼–è¯‘ (cc)

    * æºä»£ç  (.i) â†’ æ±‡ç¼–ä»£ç  (.s)         â¡ï¸ `gcc -S foo.i -o foo.s`
    * â€œé«˜çº§çŠ¶æ€æœºâ€ åˆ° â€œä½çº§çŠ¶æ€æœºâ€ çš„ç¿»è¯‘
    * æœ€ç»ˆç”Ÿæˆå¸¦æ ‡æ³¨çš„æŒ‡ä»¤åºåˆ—

    (3) æ±‡ç¼– (as)

    * æ±‡ç¼–ä»£ç  (.s) â†’ ç›®æ ‡æ–‡ä»¶ (.o)       â¡ï¸ `gcc -c foo.s -o foo.o`
    * æ–‡ä»¶ = sections (.text, .data, .rodata.str.1, ...)
        - å¯¹äº ELFï¼Œæ¯ä¸ª section æœ‰å®ƒçš„æƒé™ã€å†…å­˜å¯¹é½ç­‰ä¿¡æ¯
    * section ä¸­çš„ä¸‰è¦ç´ 
        - ä»£ç  (å­—èŠ‚åºåˆ—)
        - ç¬¦å·ï¼šæ ‡è®° â€œå½“å‰â€ çš„ä½ç½®
        - é‡å®šä½ï¼šæš‚æ—¶ä¸èƒ½ç¡®å®šçš„æ•°å€¼ (é“¾æ¥æ—¶ç¡®å®š)

    (4) é“¾æ¥ (ld)                         â¡ï¸ `gcc foo.o -o foo`

    * å¤šä¸ªç›®æ ‡æ–‡ä»¶ (.o) â†’ å¯æ‰§è¡Œæ–‡ä»¶ (a.out)
    * åˆå¹¶æ‰€æœ‰çš„ sections
        - åˆ†åˆ«åˆå¹¶ .text, .data, .bss ä¸­çš„ä»£ç 
        - æŠŠ sections â€œå¹³é“ºâ€ æˆå­—èŠ‚åºåˆ—
        - ç¡®å®šæ‰€æœ‰ç¬¦å·çš„ä½ç½®
        - è§£æå…¨éƒ¨é‡å®šä½
    * å¾—åˆ°ä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶
        - (ç¨‹åºåˆå§‹å†…å­˜çŠ¶æ€çš„æè¿°)

6. ç¨‹åºçš„åŠ è½½ï¼šæŠŠ â€œå­—èŠ‚åºåˆ—â€ æ¬åˆ°å†…å­˜

    * æ²¡é”™ï¼Œå°±åªåšè¿™ä¸€ä»¶äº‹
    * ç„¶åè®¾ç½®æ­£ç¡®çš„ PCï¼Œå¼€å§‹è¿è¡Œ

    ```python
    mem = mmap.mmap(
        fileno=-1, length=len(bs),
        prot=mmap.PROT_READ | mmap.PROT_WRITE | mmap.PROT_EXEC,
        flags=mmap.MAP_PRIVATE | mmap.MAP_ANONYMOUS,
    )
    mem.write(bs)
    mem.flush()
    call_pointer(mem, fle['symbols']['_start'])
    ```

7. `#!` - Shebang

    UNIX å¯¹ # æ³¨é‡Šçš„ â€œå¦™ç”¨â€ï¼šåœ¨ UNIX çš„æ—©æœŸï¼Œä¸ºäº†èƒ½æ›´æ–¹ä¾¿åœ°å°†è„šæœ¬ä½œä¸ºå¯æ‰§è¡Œæ–‡ä»¶ï¼Œå®ç°äº† #! å¼€å¤´çš„ â€œå¯æ‰§è¡Œæ–‡ä»¶â€ï¼Œå¹¶æ²¿ç”¨è‡³ä»Šã€‚Shebang ä¼šè°ƒç”¨ç¬¬ä¸€è¡Œä¸­æ‰§è¡Œçš„å‘½ä»¤å’Œå‚æ•°ï¼Œå¹¶æŠŠè¿™ä¸ªè„šæœ¬æ–‡ä»¶ä½œä¸ºå‘½ä»¤è¡Œå‚æ•°ä¼ å…¥ã€‚

    file.bin:
    ```C
    #!A B C
    // æ“ä½œç³»ç»Ÿä¼šæ‰§è¡Œ execve(A, ["A", "B C", "file.bin"], envp)
    ```

    example1:

    A.cå¦‚ä¸‹ï¼Œç¼–è¯‘åå¾—åˆ°å¯æ‰§è¡Œæ–‡ä»¶A
    
    ```C
    #include <stdio.h>

    int main(int argc, char *argv[]) {
        for (int i = 0; i < argc; i++) {
            printf("argv[%d] = %s\n", i, argv[i]);
        }
    }
    ```

    goodè„šæœ¬å†…å®¹å¦‚ä¸‹ï¼š

    ```bash
    #!A B C

    This can be any script.
    ```

    æ‰§è¡Œç»“æœï¼š
    ```bash
    linux$ ./good 1 2
    argv[0] = A
    argv[1] = B C
    argv[2] = ./good
    argv[3] = 1
    argv[4] = 2
    ```

    example2:

    bæ–‡ä»¶å†…å®¹å¦‚ä¸‹ï¼š
    ```bash
    #! /usr/bin/env python3

    print("Hello World");
    ```

    æ‰§è¡Œç»“æœï¼š
    ```bash
    linux$ ./b
    Hello World
    ```

8. ELFä¾‹å­ï¼ša.c

    ```C
    int n;
    __thread int x;         // in tbss, t means thread local
    __thread int x1 = 100;  // in tdata, å·²åˆå§‹åŒ–çš„æ•°æ®åœ¨dataèŠ‚
    static __thread int y;

    extern __thread int z;

    int foo()
    {
        return z; // å¯ä»¥çœ‹åˆ°R_X86_64_GOTTPOFF z - 4
    }
    ```

    ```bash
    linux$ gcc -c fPIE a.c
    gcc: warning: fPIE: linker input file unused because linking not done
    gcc: error: fPIE: linker input file not found: No such file or directory
    linux$ ls
    total 8.0K
    -rw-r--r-- 1 chaofu chaofu 1.7K Nov  8 19:26 a.o
    -rw-r--r-- 1 chaofu chaofu  122 Nov  8 19:26 a.c
    linux$ readelf -a a.o
    ELF Header:
    Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
    Class:                             ELF64
    Data:                              2's complement, little endian
    Version:                           1 (current)
    OS/ABI:                            UNIX - System V
    ABI Version:                       0
    Type:                              REL (Relocatable file)
    Machine:                           Advanced Micro Devices X86-64
    Version:                           0x1
    Entry point address:               0x0
    Start of program headers:          0 (bytes into file)
    Start of section headers:          688 (bytes into file)
    Flags:                             0x0
    Size of this header:               64 (bytes)
    Size of program headers:           0 (bytes)
    Number of program headers:         0
    Size of section headers:           64 (bytes)
    Number of section headers:         15
    Section header string table index: 14

    Section Headers:
    [Nr] Name              Type             Address           Offset
        Size              EntSize          Flags  Link  Info  Align
    [ 0]                   NULL             0000000000000000  00000000
        0000000000000000  0000000000000000           0     0     0
    [ 1] .text             PROGBITS         0000000000000000  00000040
        0000000000000014  0000000000000000  AX       0     0     1
    [ 2] .rela.text        RELA             0000000000000000  00000200
        0000000000000018  0000000000000018   I      12     1     8
    [ 3] .data             PROGBITS         0000000000000000  00000054
        0000000000000000  0000000000000000  WA       0     0     1
    [ 4] .bss              NOBITS           0000000000000000  00000054
        0000000000000004  0000000000000000  WA       0     0     4
    [ 5] .tbss             NOBITS           0000000000000000  00000054
        0000000000000008  0000000000000000 WAT       0     0     4
    [ 6] .tdata            PROGBITS         0000000000000000  00000054
        0000000000000004  0000000000000000 WAT       0     0     4
    [ 7] .comment          PROGBITS         0000000000000000  00000058
        000000000000002c  0000000000000001  MS       0     0     1
    [ 8] .note.GNU-stack   PROGBITS         0000000000000000  00000084
        0000000000000000  0000000000000000           0     0     1
    [ 9] .note.gnu.pr[...] NOTE             0000000000000000  00000088
        0000000000000020  0000000000000000   A       0     0     8
    [10] .eh_frame         PROGBITS         0000000000000000  000000a8
        0000000000000038  0000000000000000   A       0     0     8
    [11] .rela.eh_frame    RELA             0000000000000000  00000218
        0000000000000018  0000000000000018   I      12    10     8
    [12] .symtab           SYMTAB           0000000000000000  000000e0
        00000000000000f0  0000000000000018          13     4     8
    [13] .strtab           STRTAB           0000000000000000  000001d0
        000000000000002a  0000000000000000           0     0     1
    [14] .shstrtab         STRTAB           0000000000000000  00000230
        0000000000000079  0000000000000000           0     0     1
    Key to Flags:
    W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
    L (link order), O (extra OS processing required), G (group), T (TLS),
    C (compressed), x (unknown), o (OS specific), E (exclude),
    D (mbind), l (large), p (processor specific)

    There are no section groups in this file.

    There are no program headers in this file.

    There is no dynamic section in this file.

    Relocation section '.rela.text' at offset 0x200 contains 1 entry:
    Offset          Info           Type           Sym. Value    Sym. Name + Addend
    00000000000b  000900000016 R_X86_64_GOTTPOFF 0000000000000000 z - 4

    Relocation section '.rela.eh_frame' at offset 0x218 contains 1 entry:
    Offset          Info           Type           Sym. Value    Sym. Name + Addend
    000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0
    No processor specific unwind information to decode

    Symbol table '.symtab' contains 10 entries:
    Num:    Value          Size Type    Bind   Vis      Ndx Name
        0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
        1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS a.c
        2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text
        3: 0000000000000004     4 TLS     LOCAL  DEFAULT    5 y
        4: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 n
        5: 0000000000000000     4 TLS     GLOBAL DEFAULT    5 x
        6: 0000000000000000     4 TLS     GLOBAL DEFAULT    6 x1
        7: 0000000000000000    20 FUNC    GLOBAL DEFAULT    1 foo
        8: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_
        9: 0000000000000000     0 TLS     GLOBAL DEFAULT  UND z

    No version information found in this file.

    Displaying notes found in: .note.gnu.property
    Owner                Data size        Description
    GNU                  0x00000010       NT_GNU_PROPERTY_TYPE_0
        Properties: x86 feature: IBT, SHSTK
    ```

9. åŠ è½½ ELF æ–‡ä»¶

    * å°†å¤šæ®µå­—èŠ‚åºåˆ—å¤åˆ¶åˆ°åœ°å€ç©ºé—´ä¸­
        - åˆ†åˆ«èµ‹äºˆå¯è¯»/å¯å†™/å¯æ‰§è¡Œæƒé™
    * ç„¶åè·³è½¬åˆ°æŒ‡å®šçš„ entry (é»˜è®¤ä¸º _start) æ‰§è¡Œ
    * ELF æ˜¯ â€œäºŒè¿›åˆ¶æ•°æ®ç»“æ„â€ï¼Œ`readelf -l` æè¿°äº†å¦‚ä½•åŠ è½½å®ƒ
        - Offset: segment åœ¨æ–‡ä»¶ä¸­çš„åç§»é‡
        - VirtAddr: æ®µåœ¨å†…å­˜ä¸­åº”å½“è¢«åŠ è½½åˆ°çš„èµ·å§‹åœ°å€
        - PhysAddr (ä¸€èˆ¬ä¸ç”¨)
        - FileSiz: æ®µåœ¨æ–‡ä»¶ä¸­çš„å­—èŠ‚æ•°
        - MemSiz: æ®µåœ¨å†…å­˜ä¸­çš„å­—èŠ‚æ•° (å¯èƒ½å¤§äºæ–‡ä»¶å¤§å°)
        - Flags: æƒé™ï¼Œä¾‹å¦‚ RWE
        - Align: è™šæ‹Ÿåœ°å€çš„å¯¹é½

    ```bash
    linux$ ./loader minimal 
    Hello, OS World
    linux$ ./minimal 
    Hello, OS World
    linux$ readelf -l minimal 

    Elf file type is EXEC (Executable file)
    Entry point 0x401000
    There are 2 program headers, starting at offset 64

    Program Headers:
    Type           Offset             VirtAddr           PhysAddr
                    FileSiz            MemSiz              Flags  Align
    LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                    0x00000000000000b0 0x00000000000000b0  R      0x1000
    LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000
                    0x0000000000000058 0x0000000000000058  R E    0x1000

    Section to Segment mapping:
    Segment Sections...
    00     
    01     .text 
    ```

    <a id="minimal-loader"></a>
    æ„æ€æ˜¯ï¼Œloaderåº”å½“å°†minimalè¿™ä¸ªæ–‡ä»¶çš„offsetä¸º0çš„åœ°æ–¹ï¼Œå¤§å°ä¸º0xb0çš„ä¸€æ®µåŒºåŸŸæ¬åˆ°æ“ä½œç³»ç»Ÿä¸­è™šæ‹Ÿå†…å­˜çš„0x400000ä½ç½®å¤„ï¼›å°†offsetä¸º0x1000ï¼Œå¤§å°ä¸º0x58çš„ä¸€æ®µåŒºåŸŸæ¬åˆ°æ“ä½œç³»ç»Ÿä¸­è™šæ‹Ÿå†…å­˜çš„0x401000ä½ç½®å¤„ã€‚ç„¶åå‡†å¤‡å¥½[initial process stack](#system-v-abi)é‡Œçš„argc/argv/envpç­‰ï¼Œå†è·³è½¬åˆ°Entry point 0x401000ï¼Œå³å¯å¼€å§‹æ‰§è¡Œminimalã€‚

    (é™æ€ ELF åŠ è½½å™¨: Linux æ“ä½œç³»ç»Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨ execve ç³»ç»Ÿè°ƒç”¨åŠ è½½ä¸€ä¸ªç¨‹åºï¼Œå®ç°çŠ¶æ€æœºçš„ â€œé‡ç½®â€ï¼›åŒæ—¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è‡ªå·±åŠ¨æ‰‹æ¨¡æ‹Ÿ execve ç³»ç»Ÿè°ƒç”¨çš„è¡Œä¸ºï¼šå°† ELF æ–‡ä»¶ä¸­éœ€è¦åŠ è½½çš„éƒ¨åˆ†æ˜ å°„åˆ°å†…å­˜ï¼Œå¹¶æ ¹æ® [ABI](https://jyywiki.cn/OS/manuals/sysv-abi.pdf) æ„å»ºæ­£ç¡®çš„è¿›ç¨‹åˆå§‹æ ˆå’Œå¯„å­˜å™¨ï¼Œæˆ‘ä»¬å°±èƒ½å®ç°äºŒè¿›åˆ¶æ–‡ä»¶çš„ â€œåŠ è½½â€ã€‚)

## Lecture 20 åŠ¨æ€é“¾æ¥å’ŒåŠ è½½
!!! abstract "Take-away Messages"

    Bugs (åŒ…æ‹¬å¹¶å‘ bugs) ä¸€ç›´ä»¥æ¥å›°æ‰°ç€æ‰€æœ‰è½¯ä»¶å·¥ç¨‹çš„å®è·µè€…ã€‚æˆ‘ä»¬ä¸ä»…è¦åº”å¯¹ specification crisis (å®šä¹‰åˆ°åº•ä»€ä¹ˆæ˜¯å¯¹çš„)ï¼Œç”šè‡³å³ä¾¿çŸ¥é“ specificationï¼Œä¹Ÿéš¾ä»¥åº”å¯¹ç°ä»£è½¯ä»¶çš„å¤æ‚æ€§ã€‚ä¸ºäº†éƒ¨åˆ†åº”å¯¹è¿™ä¸€ç‚¹ä»è€Œå®ç° â€œæ›´æ­£ç¡®â€ çš„è½¯ä»¶ï¼Œæˆ‘ä»¬æŠŠå¯¹ç¨‹åºçš„é¢„æœŸè¡¨è¾¾åœ¨ç¨‹åºä¸­ (race-free, lock ordering, ...)ï¼Œè€Œä¸æ˜¯è®©ç¨‹åºåœ¨è‡ªç„¶çŠ¶æ€ä¸‹æ‚„æ‚„è¿›å…¥æœ‰é—®é¢˜çš„çŠ¶æ€ï¼Œå°±æ˜¯æˆ‘ä»¬ç›®å‰è§£å†³ç¨‹åºè°ƒè¯•é—®é¢˜çš„æŠ˜ä¸­åŠæ³•ã€‚â€œå±±å¯¨â€ sanitizer ç»™æˆ‘ä»¬å¸¦æ¥çš„å¯å‘åˆ™æ˜¯ï¼šå¦‚æœæˆ‘ä»¬èƒ½æ¸…æ¥šåœ°è¿½æº¯åˆ°é—®é¢˜äº§ç”Ÿçš„æœ¬æºï¼Œæˆ‘ä»¬å°±æ€»æ˜¯èƒ½æ‰¾åˆ°å¥½çš„åº”å¯¹æ–¹æ³•â€”â€”å±±å¯¨çš„ sanitizers åœ¨æš—ä¸­å¸®åŠ©ä½ å®ç° fail-fast çš„ç¨‹åºï¼Œä»è€Œå‡è½»ä½ è°ƒè¯•é—®é¢˜çš„è´Ÿæ‹…ã€‚

## Lecture 21 ç³»ç»Ÿè°ƒç”¨ã€ä¸­æ–­å’Œä¸Šä¸‹æ–‡åˆ‡æ¢
!!! abstract "Take-away Messages"

    Bugs (åŒ…æ‹¬å¹¶å‘ bugs) ä¸€ç›´ä»¥æ¥å›°æ‰°ç€æ‰€æœ‰è½¯ä»¶å·¥ç¨‹çš„å®è·µè€…ã€‚æˆ‘ä»¬ä¸ä»…è¦åº”å¯¹ specification crisis (å®šä¹‰åˆ°åº•ä»€ä¹ˆæ˜¯å¯¹çš„)ï¼Œç”šè‡³å³ä¾¿çŸ¥é“ specificationï¼Œä¹Ÿéš¾ä»¥åº”å¯¹ç°ä»£è½¯ä»¶çš„å¤æ‚æ€§ã€‚ä¸ºäº†éƒ¨åˆ†åº”å¯¹è¿™ä¸€ç‚¹ä»è€Œå®ç° â€œæ›´æ­£ç¡®â€ çš„è½¯ä»¶ï¼Œæˆ‘ä»¬æŠŠå¯¹ç¨‹åºçš„é¢„æœŸè¡¨è¾¾åœ¨ç¨‹åºä¸­ (race-free, lock ordering, ...)ï¼Œè€Œä¸æ˜¯è®©ç¨‹åºåœ¨è‡ªç„¶çŠ¶æ€ä¸‹æ‚„æ‚„è¿›å…¥æœ‰é—®é¢˜çš„çŠ¶æ€ï¼Œå°±æ˜¯æˆ‘ä»¬ç›®å‰è§£å†³ç¨‹åºè°ƒè¯•é—®é¢˜çš„æŠ˜ä¸­åŠæ³•ã€‚â€œå±±å¯¨â€ sanitizer ç»™æˆ‘ä»¬å¸¦æ¥çš„å¯å‘åˆ™æ˜¯ï¼šå¦‚æœæˆ‘ä»¬èƒ½æ¸…æ¥šåœ°è¿½æº¯åˆ°é—®é¢˜äº§ç”Ÿçš„æœ¬æºï¼Œæˆ‘ä»¬å°±æ€»æ˜¯èƒ½æ‰¾åˆ°å¥½çš„åº”å¯¹æ–¹æ³•â€”â€”å±±å¯¨çš„ sanitizers åœ¨æš—ä¸­å¸®åŠ©ä½ å®ç° fail-fast çš„ç¨‹åºï¼Œä»è€Œå‡è½»ä½ è°ƒè¯•é—®é¢˜çš„è´Ÿæ‹…ã€‚

## Lecture 22 è¿›ç¨‹çš„å®ç°
!!! abstract "Take-away Messages"

    Bugs (åŒ…æ‹¬å¹¶å‘ bugs) ä¸€ç›´ä»¥æ¥å›°æ‰°ç€æ‰€æœ‰è½¯ä»¶å·¥ç¨‹çš„å®è·µè€…ã€‚æˆ‘ä»¬ä¸ä»…è¦åº”å¯¹ specification crisis (å®šä¹‰åˆ°åº•ä»€ä¹ˆæ˜¯å¯¹çš„)ï¼Œç”šè‡³å³ä¾¿çŸ¥é“ specificationï¼Œä¹Ÿéš¾ä»¥åº”å¯¹ç°ä»£è½¯ä»¶çš„å¤æ‚æ€§ã€‚ä¸ºäº†éƒ¨åˆ†åº”å¯¹è¿™ä¸€ç‚¹ä»è€Œå®ç° â€œæ›´æ­£ç¡®â€ çš„è½¯ä»¶ï¼Œæˆ‘ä»¬æŠŠå¯¹ç¨‹åºçš„é¢„æœŸè¡¨è¾¾åœ¨ç¨‹åºä¸­ (race-free, lock ordering, ...)ï¼Œè€Œä¸æ˜¯è®©ç¨‹åºåœ¨è‡ªç„¶çŠ¶æ€ä¸‹æ‚„æ‚„è¿›å…¥æœ‰é—®é¢˜çš„çŠ¶æ€ï¼Œå°±æ˜¯æˆ‘ä»¬ç›®å‰è§£å†³ç¨‹åºè°ƒè¯•é—®é¢˜çš„æŠ˜ä¸­åŠæ³•ã€‚â€œå±±å¯¨â€ sanitizer ç»™æˆ‘ä»¬å¸¦æ¥çš„å¯å‘åˆ™æ˜¯ï¼šå¦‚æœæˆ‘ä»¬èƒ½æ¸…æ¥šåœ°è¿½æº¯åˆ°é—®é¢˜äº§ç”Ÿçš„æœ¬æºï¼Œæˆ‘ä»¬å°±æ€»æ˜¯èƒ½æ‰¾åˆ°å¥½çš„åº”å¯¹æ–¹æ³•â€”â€”å±±å¯¨çš„ sanitizers åœ¨æš—ä¸­å¸®åŠ©ä½ å®ç° fail-fast çš„ç¨‹åºï¼Œä»è€Œå‡è½»ä½ è°ƒè¯•é—®é¢˜çš„è´Ÿæ‹…ã€‚

## Lecture 23 å¤„ç†å™¨è°ƒåº¦
!!! abstract "Take-away Messages"

    Bugs (åŒ…æ‹¬å¹¶å‘ bugs) ä¸€ç›´ä»¥æ¥å›°æ‰°ç€æ‰€æœ‰è½¯ä»¶å·¥ç¨‹çš„å®è·µè€…ã€‚æˆ‘ä»¬ä¸ä»…è¦åº”å¯¹ specification crisis (å®šä¹‰åˆ°åº•ä»€ä¹ˆæ˜¯å¯¹çš„)ï¼Œç”šè‡³å³ä¾¿çŸ¥é“ specificationï¼Œä¹Ÿéš¾ä»¥åº”å¯¹ç°ä»£è½¯ä»¶çš„å¤æ‚æ€§ã€‚ä¸ºäº†éƒ¨åˆ†åº”å¯¹è¿™ä¸€ç‚¹ä»è€Œå®ç° â€œæ›´æ­£ç¡®â€ çš„è½¯ä»¶ï¼Œæˆ‘ä»¬æŠŠå¯¹ç¨‹åºçš„é¢„æœŸè¡¨è¾¾åœ¨ç¨‹åºä¸­ (race-free, lock ordering, ...)ï¼Œè€Œä¸æ˜¯è®©ç¨‹åºåœ¨è‡ªç„¶çŠ¶æ€ä¸‹æ‚„æ‚„è¿›å…¥æœ‰é—®é¢˜çš„çŠ¶æ€ï¼Œå°±æ˜¯æˆ‘ä»¬ç›®å‰è§£å†³ç¨‹åºè°ƒè¯•é—®é¢˜çš„æŠ˜ä¸­åŠæ³•ã€‚â€œå±±å¯¨â€ sanitizer ç»™æˆ‘ä»¬å¸¦æ¥çš„å¯å‘åˆ™æ˜¯ï¼šå¦‚æœæˆ‘ä»¬èƒ½æ¸…æ¥šåœ°è¿½æº¯åˆ°é—®é¢˜äº§ç”Ÿçš„æœ¬æºï¼Œæˆ‘ä»¬å°±æ€»æ˜¯èƒ½æ‰¾åˆ°å¥½çš„åº”å¯¹æ–¹æ³•â€”â€”å±±å¯¨çš„ sanitizers åœ¨æš—ä¸­å¸®åŠ©ä½ å®ç° fail-fast çš„ç¨‹åºï¼Œä»è€Œå‡è½»ä½ è°ƒè¯•é—®é¢˜çš„è´Ÿæ‹…ã€‚

## Lecture 24 çŠ¶æ€æœºæ¨¡å‹çš„åº”ç”¨
!!! abstract "Take-away Messages"

    Bugs (åŒ…æ‹¬å¹¶å‘ bugs) ä¸€ç›´ä»¥æ¥å›°æ‰°ç€æ‰€æœ‰è½¯ä»¶å·¥ç¨‹çš„å®è·µè€…ã€‚æˆ‘ä»¬ä¸ä»…è¦åº”å¯¹ specification crisis (å®šä¹‰åˆ°åº•ä»€ä¹ˆæ˜¯å¯¹çš„)ï¼Œç”šè‡³å³ä¾¿çŸ¥é“ specificationï¼Œä¹Ÿéš¾ä»¥åº”å¯¹ç°ä»£è½¯ä»¶çš„å¤æ‚æ€§ã€‚ä¸ºäº†éƒ¨åˆ†åº”å¯¹è¿™ä¸€ç‚¹ä»è€Œå®ç° â€œæ›´æ­£ç¡®â€ çš„è½¯ä»¶ï¼Œæˆ‘ä»¬æŠŠå¯¹ç¨‹åºçš„é¢„æœŸè¡¨è¾¾åœ¨ç¨‹åºä¸­ (race-free, lock ordering, ...)ï¼Œè€Œä¸æ˜¯è®©ç¨‹åºåœ¨è‡ªç„¶çŠ¶æ€ä¸‹æ‚„æ‚„è¿›å…¥æœ‰é—®é¢˜çš„çŠ¶æ€ï¼Œå°±æ˜¯æˆ‘ä»¬ç›®å‰è§£å†³ç¨‹åºè°ƒè¯•é—®é¢˜çš„æŠ˜ä¸­åŠæ³•ã€‚â€œå±±å¯¨â€ sanitizer ç»™æˆ‘ä»¬å¸¦æ¥çš„å¯å‘åˆ™æ˜¯ï¼šå¦‚æœæˆ‘ä»¬èƒ½æ¸…æ¥šåœ°è¿½æº¯åˆ°é—®é¢˜äº§ç”Ÿçš„æœ¬æºï¼Œæˆ‘ä»¬å°±æ€»æ˜¯èƒ½æ‰¾åˆ°å¥½çš„åº”å¯¹æ–¹æ³•â€”â€”å±±å¯¨çš„ sanitizers åœ¨æš—ä¸­å¸®åŠ©ä½ å®ç° fail-fast çš„ç¨‹åºï¼Œä»è€Œå‡è½»ä½ è°ƒè¯•é—®é¢˜çš„è´Ÿæ‹…ã€‚
