# è™šæ‹ŸåŒ–

## Lecture 14 æ“ä½œç³»ç»Ÿä¸Šçš„è¿›ç¨‹
!!! abstract "Take-away Messages"

    å› ä¸º â€œç¨‹åº = çŠ¶æ€æœºâ€ï¼Œæ“ä½œç³»ç»Ÿä¸Šè¿›ç¨‹ (è¿è¡Œçš„ç¨‹åº) ç®¡ç†çš„ API å¾ˆè‡ªç„¶åœ°å°±æ˜¯çŠ¶æ€æœºçš„ç®¡ç†ã€‚åœ¨ UNIX/Linux ä¸–ç•Œä¸­ï¼Œä»¥ä¸‹ä¸‰ä¸ªç³»ç»Ÿè°ƒç”¨åˆ›å»ºäº†æ•´ä¸ª â€œè¿›ç¨‹ä¸–ç•Œâ€ï¼Œä¸è®ºæ˜¯æˆ‘ä»¬å¸¸ç”¨çš„ IDE å’Œæµè§ˆå™¨ï¼Œè¿˜æ˜¯ç¼–è¯‘æ—¶åœ¨åå°è°ƒç”¨çš„ gccã€‚å…¶ä¸­ï¼š
    
    * fork: å¯¹å½“å‰çŠ¶æ€æœºçŠ¶æ€è¿›è¡Œå®Œæ•´å¤åˆ¶
    * execve: å°†å½“å‰çŠ¶æ€æœºçŠ¶æ€é‡ç½®ä¸ºæŸä¸ªå¯æ‰§è¡Œæ–‡ä»¶æè¿°çš„çŠ¶æ€æœº
    * exit: é”€æ¯å½“å‰çŠ¶æ€æœº
        
    åœ¨å¯¹è¿™ä¸ªæ¦‚å¿µæœ‰äº†ç»å¯¹æ­£ç¡®ä¸”ç»å¯¹ä¸¥è°¨çš„ç†è§£åï¼Œæ“ä½œç³»ç»Ÿä¹Ÿå°±æ˜¾å¾—ä¸é‚£ä¹ˆç¥ç§˜äº†ã€‚

1. fork: åˆ›å»ºçŠ¶æ€æœºã€‚åšä¸€ä»½çŠ¶æ€æœºå®Œæ•´çš„å¤åˆ¶ (å†…å­˜ã€å¯„å­˜å™¨ç°åœº)ã€‚
    ```C
    pid_t fork(void);
    ```

    fork() çš„è¡Œä¸º

    * ç«‹å³å¤åˆ¶çŠ¶æ€æœº
        - åŒ…æ‹¬æ‰€æœ‰ä¿¡æ¯çš„å®Œæ•´æ‹·è´
            + æ¯ä¸€ä¸ªå­—èŠ‚çš„å†…å­˜
            + æ‰“å¼€çš„æ–‡ä»¶ (å…±äº«)
            + â€¦â€¦
            + å¤åˆ¶å¤±è´¥è¿”å› -1
                + errno ä¼šè¿”å›é”™è¯¯åŸå›  (man fork)

    * å¦‚ä½•åŒºåˆ†ä¸¤ä¸ªçŠ¶æ€æœºï¼Ÿ
        * æ–°åˆ›å»ºè¿›ç¨‹ï¼šå¾—åˆ°çš„è¿”å›å€¼æ˜¯ 0
        * æ‰§è¡Œ fork çš„çˆ¶è¿›ç¨‹ï¼šå¾—åˆ°çš„è¿”å›å€¼æ˜¯å­è¿›ç¨‹çš„è¿›ç¨‹å·

2. é˜…è¯»ä»¥ä¸‹ç¨‹åºï¼Œå†™å‡ºè¿è¡Œç»“æœ
    ```C
    pid_t x = fork();
    pid_t y = fork();
    printf("%d %d\n", x, y);
    ```

    è¾“å‡ºï¼š
    ```bash
    19489 19490
    19489 0
    0 19491
    0 0
    ```
    ![alt text](../img/image-11.png)

    ```C
    for (int i = 0; i < 2; i++) {
        fork();
        printf("Hello\n");
    }
    ```
    è¾“å‡ºï¼š6ä¸ªHello
    ```C
    Hello
    Hello
    Hello
    Hello
    Hello
    Hello
    ```

    ç¨‹åºç­‰ä»·äºï¼š
    ```C
    fork();
    printf("Hello\n");
    fork();
    printf("Hello\n");
    ```
    ![alt text](../img/image-12.png)

    ç„¶è€Œï¼Œ`./demo-2 | wc -l`è¾“å‡ºçš„æ˜¯`8`ã€‚åŸå› ï¼šåœ¨ç»ˆç«¯é‡Œæ¢è¡Œæ‰“å°æ—¶ä½¿ç”¨çš„æ˜¯line bufferï¼Œæ­¤æ—¶æ‰“å°6ä¸ªï¼›é‡å®šå‘åˆ°æ–‡ä»¶æˆ–ä½¿ç”¨ç®¡é“æ—¶ä½¿ç”¨çš„æ˜¯full bufferï¼Œæ­¤æ—¶ä¼šæ‰“å°8ä¸ªï¼Œæ²¡æœ‰åˆ·æ–°bufferï¼Œå¯¼è‡´æ‰€æœ‰å¸¦æœ‰å€¼çš„bufferä¹Ÿè¢«forkäº†ã€‚`man setbuf`å¯ä»¥çœ‹åˆ°æœ‰ä¸‰ç§æ¨¡å¼`_IONBF unbuffered`/`_IOLBF line buffered`/`_IOFBF fully buffered`ã€‚
    æ­¤æ—¶ç¨‹åºç­‰ä»·äºï¼š
    ```C
    fork();
    buf += "Hello";
    fork();
    buf += "Hello";
    flush(buf);
    ```
    ![alt text](../img/image-13.png)

3. execveï¼šé‡ç½®çŠ¶æ€æœºã€‚å°†å½“å‰è¿›ç¨‹é‡ç½®æˆä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶æè¿°çŠ¶æ€æœºçš„åˆå§‹çŠ¶æ€ã€‚

    ```C
    int execve(const char *filename,
               char * const argv[], char * const envp[]);
    // ä¸‰ä¸ªå‚æ•°ï¼šå¯æ‰§è¡Œæ–‡ä»¶çš„è·¯å¾„ã€ä¼ é€’ç»™ main å‡½æ•°çš„å‚æ•°å’Œç¯å¢ƒå˜é‡ã€‚
    ```
    execve è¡Œä¸º

    * æ‰§è¡Œåä¸º `filename` çš„ç¨‹åº
    * å…è®¸å¯¹æ–°çŠ¶æ€æœºè®¾ç½®å‚æ•° `argv` (v) å’Œç¯å¢ƒå˜é‡ `envp` (e)
        - åˆšå¥½å¯¹åº”äº† `main()` çš„å‚æ•°ï¼
    * execve æ˜¯å”¯ä¸€èƒ½å¤Ÿ â€œæ‰§è¡Œç¨‹åºâ€ çš„ç³»ç»Ÿè°ƒç”¨
        - å› æ­¤ä¹Ÿæ˜¯ä¸€åˆ‡è¿›ç¨‹ strace çš„ç¬¬ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨

4. UNIX ä¸­å®ç° â€œåˆ›å»ºæ–°çŠ¶æ€æœºâ€ çš„æ–¹å¼ï¼šfork + execve ï¼ˆç›¸å½“äºspawnï¼‰
    ```C
    int pid = fork();
    if (pid == -1) {
        // forkå¤±è´¥
        perror("fork"); goto fail;
    } else if (pid == 0) {
        // Child
        execve(...);
        // å¦‚æœ execve æˆåŠŸæ‰§è¡Œï¼Œå®ƒå°†æ›¿æ¢å½“å‰è¿›ç¨‹çš„å†…å­˜ç©ºé—´å¹¶å¼€å§‹æ‰§è¡Œæ–°çš„ç¨‹åºï¼Œ
        // å› æ­¤ perror("execve") ä¸ä¼šè¢«æ‰§è¡Œã€‚perror("execve") åªä¼šåœ¨ execve
        // è°ƒç”¨å¤±è´¥æ—¶æ‰§è¡Œ
        perror("execve"); goto fail;
    } else {
        // Parent
        ...
    }
    ```

    demo:
    ```C
    #include <unistd.h>
    #include <stdio.h>

    int main() {
        char *const argv[] = {
            "/bin/bash",
            "-c",
            "env",
            NULL,
        };

        char *const envp[] = {
            "HELLO=WORLD",
            NULL,
        };

        // Reset the state machine to "/bin/bash"
        execve(argv[0], argv, envp);

        // We are here only on error.
        printf("Hello, World!\n");
    }
    ```
    è¾“å‡ºï¼š
    ```bash
    PWD=/home/user/jyy_os_2024/lecture/lect14/execve-demo
    HELLO=WORLD
    SHLVL=0
    _=/usr/bin/env
    ```
    è¿™æ¯”ç›´æ¥åœ¨bashé‡Œæ‰§è¡Œ`/bin/bash -c env`å¾—åˆ°çš„ä¸€å¤§å †è¾“å‡ºæ›´åŠ ç®€å•ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬åœ¨ä»£ç é‡Œçš„ç¯å¢ƒå˜é‡evnpåªä¿ç•™äº†`HELLO=WORLD`ï¼ˆå½“ç„¶å®é™…ä¸Šæ‰§è¡Œexecveè¿˜æ˜¯æœ‰PWD/SHLVLç­‰è¢«åŠ ä¸Šçš„ç¯å¢ƒå˜é‡ï¼‰ã€‚

5. _exit()ï¼šé”€æ¯çŠ¶æ€æœºã€‚ç«‹å³æ‘§æ¯çŠ¶æ€æœºï¼Œå…è®¸æœ‰ä¸€ä¸ªè¿”å›å€¼ã€‚å­è¿›ç¨‹ç»ˆæ­¢ä¼šé€šçŸ¥çˆ¶è¿›ç¨‹ã€‚
    ```C
    void _exit(int status);
    ```

    ç»“æŸç¨‹åºæ‰§è¡Œçš„ä¸‰ç§æ–¹æ³•

    * exit(0)
        - provided by libc
        - ä¼šè°ƒç”¨ atexit
    * _exit(0)
        - æ‰§è¡Œ â€œexit_groupâ€ ç³»ç»Ÿè°ƒç”¨ç»ˆæ­¢æ•´ä¸ªè¿›ç¨‹ (æ‰€æœ‰çº¿ç¨‹)
        - ä¸ä¼šè°ƒç”¨ atexit 
    * syscall(SYS_exit, 0)
        - æ‰§è¡Œ â€œexitâ€ ç³»ç»Ÿè°ƒç”¨ç»ˆæ­¢å½“å‰çº¿ç¨‹
        - ä¸ä¼šè°ƒç”¨ atexitï¼ˆlibcå½“ç„¶ä¸äº†è§£ç³»ç»Ÿè°ƒç”¨ï¼Œä¹Ÿå°±æ— æ³•åœ¨é€€å‡ºæ—¶è°ƒç”¨libcçš„atexitå‡½æ•°ï¼‰

## Lecture 15 è¿›ç¨‹çš„åœ°å€ç©ºé—´
!!! abstract "Take-away Messages"

    çŠ¶æ€æœºçš„è§†è§’è‡ªç„¶åœ°å°†æˆ‘ä»¬å¼•å…¥ â€œå†…å­˜åˆ°åº•æ˜¯ä»€ä¹ˆâ€ çš„é—®é¢˜â€”â€”å®ƒçš„ç­”æ¡ˆåŒæ ·ä¹Ÿå¾ˆè‡ªç„¶ï¼šå¸¦æœ‰è®¿é—®æƒé™æ§åˆ¶çš„è¿ç»­å†…å­˜æ®µã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ <span style="color:blue;">mmapã€munmapã€mprotect</span> ä¸‰ä¸ªç³»ç»Ÿè°ƒç”¨è°ƒæ•´çŠ¶æ€æœºçš„åœ°å€ç©ºé—´ï¼ŒåŒ…æ‹¬åˆ†é…åŒ¿åçš„å†…å­˜ã€æ˜ å°„æ–‡ä»¶å†…å®¹åˆ°å†…å­˜ã€ä¿®æ”¹è®¿é—®æƒé™ç­‰ï¼ˆå¢/åˆ /æ”¹ï¼‰ã€‚æ›´æœ‰è¶£çš„æ˜¯æ“ä½œç³»ç»Ÿæœ‰ â€œèƒ½å¤Ÿå®ç°ä¸€åˆ‡åº”ç”¨ç¨‹åºâ€ çš„éœ€æ±‚ï¼Œè°ƒè¯•å™¨ä¹Ÿä¸åœ¨è¯ä¸‹â€”â€”è¿™ä¹Ÿç»™äº†æˆ‘ä»¬å…¥ä¾µå…¶ä»–è¿›ç¨‹åœ°å€ç©ºé—´çš„æœºåˆ¶ã€‚

1. ä»¥ä¸‹ç¨‹åºçš„ (å¯èƒ½) è¾“å‡ºæ˜¯ä»€ä¹ˆï¼Ÿ
    ```C
    int main()
    {
        int x = *(int *)main;
        printf("%x\n", x);    // fa1e0ff3ï¼ˆå°ç«¯ï¼‰
        printf("%p\n", main); //0x556b3315c149ï¼Œæ¯æ¬¡ä¸ä¸€æ ·
    }
    ```

    ```bash
    objdump -d a.out
    0000000000001149 <main>:
    1149:       f3 0f 1e fa             endbr64 
    114d:       55                      push   %rbp
    114e:       48 89 e5                mov    %rsp,%rbp
    1151:       48 83 ec 10             sub    $0x10,%rsp
    ...
    ```
2. æŸ¥çœ‹è¿›ç¨‹çš„åœ°å€ç©ºé—´ï¼š

    * /proc/[pid]/maps

        ```bash
        linux$ ps
        PID TTY          TIME CMD
        18222 pts/3    00:00:00 dbus-launch
        22713 pts/3    00:00:01 bash
        29368 pts/3    00:00:00 ps
        linux$ vi /proc/22713/maps
        55e7a0632000-55e7a0711000 r-xp 0002f000 08:20 1241                       /usr/bin/bash
        55e7a0711000-55e7a074b000 r--p 0010e000 08:20 1241                       /usr/bin/bash
        55e7a074c000-55e7a0750000 r--p 00148000 08:20 1241                       /usr/bin/bash
        55e7a0750000-55e7a0759000 rw-p 0014c000 08:20 1241                       /usr/bin/bash
        ...
        7ffdf9eb0000-7ffdf9ed2000 rw-p 00000000 00:00 0                          [stack]
        7ffdf9f79000-7ffdf9f7d000 r--p 00000000 00:00 0                          [vvar]
        7ffdf9f7d000-7ffdf9f7f000 r-xp 00000000 00:00 0                          [vdso]
        ```

        æ— éœ€é™·å…¥å†…æ ¸çš„ç³»ç»Ÿè°ƒç”¨: vvar (data)/vdso (code)ã€‚ä¾‹å¦‚æ—¶é—´è¿™æ ·çš„æ•°æ®ï¼Œåªæœ‰æ“ä½œç³»ç»Ÿæœ‰ï¼Œè€Œåº”ç”¨ç¨‹åºåªæ˜¯è¯»æ—¶é—´æˆ³ï¼Œä¸ä¼šæ”¹å®ƒï¼Œå¯¹äºè¿™æ ·åªè¯»çš„æ•°æ®ï¼Œæ— éœ€è¿›å…¥æ“ä½œç³»ç»Ÿå†…æ ¸ã€‚å› æ­¤ï¼Œ**æ“ä½œç³»ç»Ÿé‡Œåªè¯»çš„æ•°æ®å¯ä»¥é€šè¿‡å†…å­˜çš„æ–¹å¼å…±äº«ç»™è¿›ç¨‹**ã€‚

    * pmap [pid]

        ```bash
        linux$ pmap 22713
        22713:   /bin/bash
        000055e7a0603000    188K r---- bash
        000055e7a0632000    892K r-x-- bash
        000055e7a0711000    232K r---- bash
        000055e7a074c000     16K r---- bash
        000055e7a0750000     36K rw--- bash
        000055e7a0759000     44K rw---   [ anon ]
        000055e7a1dbc000   1832K rw---   [ anon ]
        ...
        ```

    * gdb cmd: `info proc mappings`

3. ç®¡ç†è¿›ç¨‹åœ°å€ç©ºé—´ï¼šåœ¨çŠ¶æ€æœºçŠ¶æ€ä¸Šå¢åŠ /åˆ é™¤/ä¿®æ”¹ä¸€æ®µå¯è®¿é—®çš„å†…å­˜

    ```C
    // æ˜ å°„
    void *mmap(void *addr, size_t length, int prot, int flags,
               int fd, off_t offset);
    int munmap(void *addr, size_t length);

    // ä¿®æ”¹æ˜ å°„æƒé™
    int mprotect(void *addr, size_t length, int prot);
    ```

    ä¾‹å­ï¼š

    ```C
    #include <unistd.h>
    #include <stdint.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <sys/mman.h>

    #define GiB * (1024LL * 1024 * 1024)

    int main() {
        volatile uint8_t *p = mmap(
            NULL,
            8 GiB,
            PROT_READ | PROT_WRITE,
            MAP_ANONYMOUS | MAP_PRIVATE,
            -1, 0
        );

        printf("mmap: %lx\n", (uintptr_t)p);

        if ((intptr_t)p == -1) {
            perror("cannot map");
            exit(1);
        }

        *(p + 2 GiB) = 1;
        *(p + 4 GiB) = 2;
        *(p + 7 GiB) = 3;
        printf("Read get: %d\n", *(p + 4 GiB));
        printf("Read get: %d\n", *(p + 6 GiB));
        printf("Read get: %d\n", *(p + 7 GiB));
    }
    ```

    ```python
    import hexdump
    import mmap

    with open('/dev/sda', 'rb') as fp:
        mm = mmap.mmap(fp.fileno(),
                    prot=mmap.PROT_READ, length=128 << 30)
        hexdump.hexdump(mm[:512]) # å°†ç£ç›˜sdaçš„128GiBæ˜ å°„åˆ°å†…å­˜ï¼Œå¹¶æŸ¥çœ‹å‰512å­—èŠ‚
    ```
4. å…¥ä¾µè¿›ç¨‹åœ°å€ç©ºé—´

    * è°ƒè¯•å™¨ (gdb)
        - gdb å¯ä»¥ä»»æ„è§‚æµ‹å’Œä¿®æ”¹ç¨‹åºçš„çŠ¶æ€
    * Profiler (perf)
        - M3 ä¸­å€ŸåŠ©å®ƒç†è§£ç¨‹åºçš„æ€§èƒ½ç“¶é¢ˆ

    ä¾‹å­ï¼šé‡‘å±±æ¸¸ä¾ 

    * åœ°å€ç©ºé—´é‚£ä¹ˆå¤§ï¼Œå“ªä¸ªæ‰æ˜¯ â€œé‡‘é’±â€ï¼Ÿ
        - åŒ…å«åŠ¨æ€åˆ†é…çš„å†…å­˜ï¼Œæ¯æ¬¡åœ°å€éƒ½ä¸ä¸€æ ·
        - æ€è·¯ï¼šEverything is a state machine
            + è§‚å¯ŸçŠ¶æ€æœºçš„ traceï¼Œå°±çŸ¥é“å“ªä¸ªæ˜¯é‡‘é’±äº†

    * æŸ¥æ‰¾ + Filter
        - è¿›å…¥æ¸¸æˆæ—¶ exp = 4950
        - æ‰“äº†ä¸ªæ€ª exp = 5100
        - ç¬¦åˆ 4950 â†’ 5100 å˜åŒ–çš„å†…å­˜åœ°å€æ˜¯å¾ˆå°‘çš„
            + å¥½äº†ï¼Œå‡ºé—¨å°±æ˜¯æ»¡çº§äº†

    knight.c: `sudo ./knight VirtualBoxVM` -> `s 5000` -> spend 800 -> `s 4200` -> `w 1000000`
    ```C
    #include <string>
    #include <vector>
    #include <algorithm>
    #include <iostream>
    #include <regex>
    #include <cstdio>
    #include <unistd.h>
    #include <fcntl.h>
    using std::string, std::to_string;

    struct Game {
        string name; // Name of the traced process
        int pid;     // Pid of the traced process
        int fd;      // Memory file of the traced process
        
        std::vector<uintptr_t> remain; // Watched addresses

    public:
        Game(string proc_name):
            name(proc_name),
            pid(stoi(run("pidof " + proc_name))) {

            // See: proc(5)
            string memfile = "/proc/" + to_string(pid) + "/mem";

            // We need root permission to open this file;
            // otherwise it would be too dangerous.
            fd = open(memfile.c_str(), O_RDWR);
            if (fd < 0) {
                perror(memfile.c_str());
                exit(1);
            }
        }

        ~Game() {
            close(fd);
        }

        void search_for(uint32_t val) {
            if (remain.size() == 0) {
                // No match. Start a new round of search.

                string maps = run("pmap -x " + to_string(pid));

                std::regex r(
                    R"(^([0-9a-f]+)\s+(\d+)\s+(\d+)\s+(\d+)\s+rw.*)"
                );

                std::istringstream iss(maps);
                for (string line; std::getline(iss, line); ) {
                    std::smatch match;
                    if (std::regex_search(line, match, r)) {
                        uintptr_t start = stoll(match[1].str(), nullptr, 16);
                        uintptr_t size = stoll(match[2], nullptr, 10) * 1024;
                        printf("Scanning %lx--%lx\n", start, start + size);

                        // Copy process memory to local
                        std::unique_ptr<uint32_t[]> mem(new uint32_t [size / 4]);
                        lseek(fd, start, SEEK_SET);
                        size = read(fd, mem.get(), size);

                        for (uintptr_t off = 0; off < size; off += 4) {
                            if (mem[off / 4] == val) {
                                // Found a match!
                                remain.push_back(start + off);
                            }
                        }
                    }
                }
            } else {
                // Search in the watched values.

                std::erase_if(remain, [this, val](uintptr_t addr) {
                    return load(addr) != val;
                });
            }
            printf("There are %ld match(es).\n", remain.size());
        }

        void reset() {
            remain.clear();
        }

        void overwrite(uint32_t val) {
            int nwrite = 0;
            for (uintptr_t addr : remain) {
                store(addr, val);
                nwrite++;
            }
            printf("%d value(s) written.\n", nwrite);
        }

    private:
        uint32_t load(uintptr_t addr) {
            // Load 32-bit value from another address space
            uint32_t val;
            lseek(fd, addr, SEEK_SET);
            read(fd, &val, sizeof(val));
            return val;
        }

        void store(uintptr_t addr, uint32_t val) {
            // Store 32-bit value to another address space
            lseek(fd, addr, SEEK_SET);
            write(fd, &val, sizeof(val));
        }

        static string run(const string &cmd) {
            std::array<char,128> buf;
            string result;

            FILE *pipe = popen(cmd.c_str(), "r");
            if (!pipe) {
                perror(cmd.c_str());
                exit(1);
            }

            while (fgets(buf.data(), buf.size(), pipe) != nullptr) {
                result += buf.data();
            }

            pclose(pipe);
            return result;
        }
    };


    int main(int argc, char *argv[]) {
        Game g(argv[1]);
        uint32_t val;
        char buf[64];

        printf(
            "Usage:\n"
            "  - s 100: search for value\n"
            "  - w 99999: overwrite value (for search matches)\n"
            "  - r: reset search\n\n"
        );

        while (!feof(stdin)) {
            printf("(%s %d) ", g.name.c_str(), g.pid);
            scanf("%s", buf);

            switch (buf[0]) {
                case 'q': return 0;
                case 's': scanf("%d", &val); g.search_for(val); break;
                case 'w': scanf("%d", &val); g.overwrite(val); break;
                case 'r': g.reset(); break;
            }
        }
    }
    ```

5. ç»™è¿›ç¨‹å‘é€ GUI (é”®ç›˜/é¼ æ ‡)äº‹ä»¶

    * åšä¸ªé©±åŠ¨ (å¯ç¼–ç¨‹é”®ç›˜/é¼ æ ‡)
    * åˆ©ç”¨æ“ä½œç³»ç»Ÿ/çª—å£ç®¡ç†å™¨æä¾›çš„ API
        - xdotool
        - ydotool
        - evdev (æŒ‰é”®æ˜¾ç¤ºè„šæœ¬ï¼›ä¸»æ’­å¸¸ç”¨)
    
    ä¾‹å­ï¼šå®ç°æŒ‰é”®ç²¾çµï¼Œå®ç°æŒ‰é”®ç²¾çµä¸å¿…å…¥ä¾µè¿›ç¨‹çš„åœ°å€ç©ºé—´ã€‚æ“ä½œç³»ç»Ÿç®¡ç†äº† I/O è®¾å¤‡ï¼Œæˆ‘ä»¬ç›¸åº”æ¨¡æ‹Ÿå‡ºæŒ‰é”®çš„äº‹ä»¶å³å¯ã€‚å½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ä¸ºè¿›ç¨‹åƒæ¸¸æˆä¿®æ”¹å™¨é‚£æ ·æ³¨å…¥æŒ‰é”®äº‹ä»¶ã€‚

    `sudo ./anjian`ï¼Œthen open https://js13kgames.com/games/spacebar-clicker/index.html
    ```bash
    #!/bin/bash

    # Needs sudo. Try:
    # https://js13kgames.com/games/spacebar-clicker/index.html

    echo 'Start in 5 seconds...'
    ydotoold &> /dev/null &
    sleep 5

    for _ in $(seq 1 200)
    do
        ydotool type ' '
        sleep 0.01
    done
    ```

6. æ”¹å˜è¿›ç¨‹å¯¹æ—¶é—´çš„æ„ŸçŸ¥

    ç¨‹åº = çŠ¶æ€æœº
    
    * â€œè®¡ç®—æŒ‡ä»¤â€ æ˜¯ä¸èƒ½æ„ŸçŸ¥æ—¶é—´çš„
        - spin count è®¡æ—¶ä¼šå‡ºç° â€œæœºå™¨å˜å¿«ï¼Œæ¸¸æˆæ²¡æ³•ç©â€ çš„æƒ…å†µ
        - syscall æ˜¯æ„ŸçŸ¥æ—¶é—´çš„å”¯ä¸€æ–¹æ³•
    
    * â€œåŠ«æŒâ€ å’Œæ—¶é—´ç›¸å…³çš„ syscall/åº“å‡½æ•°
        - æ”¹å˜ç¨‹åºå¯¹æ—¶é—´çš„è®¤çŸ¥
        - å°±åƒæ‰‹è¡¨è°ƒå¿«/æ…¢äº†ä¸€æ ·

    ä¾‹å­ï¼šå˜é€Ÿé½¿è½® `./gear 10 tetris`

    gearï¼šå®é™…ä¸Šå°±æ˜¯ä¸ªpythonè„šæœ¬ï¼Œè°ƒç”¨ gdb è°ƒè¯• tetris æ¸¸æˆï¼ŒåŠ«æŒ gettimeofday ç³»ç»Ÿè°ƒç”¨ï¼Œå®ç°å˜é€Ÿé½¿è½®ã€‚
    ```python
    #!/usr/bin/env python3

    import subprocess
    import sys

    try:
        ratio, exe = sys.argv[1:]
    except:
        print(f'Example: {sys.argv[0]} 10 tetris  # 10X speedup')
        exit(1)

    subprocess.run(
        [
            'gdb',
            '-ex', f'set $gear_ratio = {ratio}',
            '-x', 'gear-gdb.py',
            exe,
        ]
    )
    ```

    ```python
    import gdb
    import datetime

    ratio = float(gdb.parse_and_eval('$gear_ratio'))

    # Get the current time
    start = datetime.datetime.now()

    def hacked_time():
        now = datetime.datetime.now()
        
        # The speed of the clock is adjusted
        t = start + (now - start) * ratio

        tv_sec = int(t.timestamp())
        tv_usec = t.microsecond
        return (tv_sec, tv_usec)

    class SetTimevalBreakpoint(gdb.Breakpoint):
        def __init__(self):
            super(SetTimevalBreakpoint, self).__init__(
                'gettimeofday',
                gdb.BP_BREAKPOINT,
                internal=False
            )

        def stop(self):
            tv_sec, tv_usec = hacked_time()

            # Replace the function body
            gdb.execute(
                'set *(struct timeval *)($rdi) = {{ {}, {} }}'
                    .format(tv_sec, tv_usec)
            )
            gdb.execute('set $rax = 0')
            gdb.execute('return')

            return False  # Continue execution

    SetTimevalBreakpoint()
    gdb.execute('run')
    ```

7. è½¯ä»¶åŠ¨æ€æ›´æ–°ï¼šæˆ‘ä»¬å¯ä»¥é€šè¿‡ patch å‡½æ•°çš„å¤´éƒ¨ä¸ºä¸€ä¸ªè·³è½¬å®ç°å¯¹ä¸€ä¸ªå‡½æ•°çš„ â€œè¿è¡Œæ—¶çƒ­æ›´æ–°â€ã€‚

    ```C
    #include <stdio.h>
    #include <string.h>
    #include <sys/mman.h>
    #include <stdint.h>
    #include <assert.h>

    __attribute__((noinline)) void foo() {
        printf("In old function %s\n", __func__);
    }

    __attribute__((noinline)) void foo_new() {
        printf("In new function %s\n", __func__);
    }

    // 48 b8 (64-bit imm)   movabs $imm,%rax
    // ff e0                jmpq   *%rax
    const char PATCH[] = "\x48\xb8--------\xff\xe0";

    void DSU(void *func, void *func_new) {
        int flag = PROT_WRITE | PROT_READ | PROT_EXEC, rc, np;

        // Grant write permission to the memory
        // We must handle boundary cases
        uintptr_t fn = (uintptr_t)func;
        uintptr_t base = fn & ~0xfff;
        if (fn + sizeof(PATCH) > base + 4096) {
            np = 2;  // Cross page boundary
        } else {
            np = 1;
        }
        printf("np = %d\n", np);

        rc = mprotect((void *)base, np * 4096, flag);
        assert(rc == 0);  // Not expecting a failure
    
        // Patch the first instruction (this is UB in C spec)
        memcpy(func, PATCH, sizeof(PATCH));
        memcpy((char *)func + 2, &func_new, sizeof(func_new));

        // Revoke the write permission
        rc = mprotect((void *)base, np * 4096, PROT_READ | PROT_EXEC);
        assert(rc == 0);  // Not expecting a failure
    }

    int main() {
        setbuf(stdout, NULL);
        foo();
        DSU(foo, foo_new);  // Dynamic software update
        foo();
    }
    ```

## Lecture 16 ç³»ç»Ÿè°ƒç”¨å’ŒUNIX Shell
!!! abstract "Take-away Messages"

    é€šè¿‡ freestanding çš„ shellï¼Œæˆ‘ä»¬é˜é‡Šäº† â€œå¯ä»¥åœ¨ç³»ç»Ÿè°ƒç”¨ä¸Šåˆ›å»ºæ•´ä¸ªæ“ä½œç³»ç»Ÿåº”ç”¨ä¸–ç•Œâ€ çš„çœŸæ­£å«ä¹‰ï¼šæ“ä½œç³»ç»Ÿçš„ API å’Œåº”ç”¨ç¨‹åºæ˜¯äº’ç›¸æˆå°±ã€èºæ—‹ç”Ÿé•¿çš„ï¼šæœ‰äº†æ–°çš„åº”ç”¨éœ€æ±‚ï¼Œå°±æœ‰äº†æ–°çš„æ“ä½œç³»ç»ŸåŠŸèƒ½ã€‚è€Œ UNIX ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªéå¸¸ç²¾ç®€ã€ç¨³å®šçš„æ¥å£ (fork, execve, exit, pipe ,...)ï¼Œçºµç„¶æœ‰æ²‰é‡çš„å†å²è´Ÿæ‹…ï¼Œå®ƒåœ¨ä»Šå¤©ä¾ç„¶å·¥ä½œå¾—å¾ˆå¥½ã€‚

1. æ“ä½œç³»ç»Ÿå¯¹è±¡ï¼š

    * è¿›ç¨‹å’Œåœ°å€ç©ºé—´
        - è¿›ç¨‹ç®¡ç†ï¼šfork, execve, exit
        - å†…å­˜ç®¡ç†ï¼šmmap, munmap, mprotect
    * æ–‡ä»¶å’Œè®¾å¤‡
        - æ–‡ä»¶ï¼šæœ‰ â€œåå­—â€ çš„å¯¹è±¡ï¼Œä¾‹å¦‚å­—èŠ‚æµ (ç»ˆç«¯) æˆ–å­—èŠ‚åºåˆ— (æ™®é€šæ–‡ä»¶ï¼›åŒ…æ‹¬ /proc/*)
        - æ–‡ä»¶æè¿°ç¬¦ (file descriptorï¼ŒWindowsä¸­å«handleå¥æŸ„)ï¼š<span style="color:blue;">æŒ‡å‘æ“ä½œç³»ç»Ÿå¯¹è±¡çš„ â€œæŒ‡é’ˆâ€</span>
        - Everything is a fileï¼Œé€šè¿‡æŒ‡é’ˆå¯ä»¥è®¿é—® â€œä¸€åˆ‡â€
        - å¯¹è±¡çš„è®¿é—®éƒ½éœ€è¦æŒ‡é’ˆï¼šopen, close, read/write (è§£å¼•ç”¨), lseek (æŒ‡é’ˆå†…èµ‹å€¼/è¿ç®—), dup (æŒ‡é’ˆé—´èµ‹å€¼)
    * IPC Endpoints (Inter-Process Communicationï¼Œè¿›ç¨‹é—´é€šä¿¡)
        - ç®¡é“ï¼šä¸€ä¸ªç‰¹æ®Šçš„ â€œæ–‡ä»¶â€ (æµ)
            + ç”±è¯»è€…/å†™è€…å…±äº«
            + è¯»å£ï¼šæ”¯æŒ read `fd[0]`
            + å†™å£ï¼šæ”¯æŒ write `fd[1]`
        - åŒ¿åç®¡é“
            + è¿”å›ä¸¤ä¸ªæ–‡ä»¶æè¿°ç¬¦
            + è¿›ç¨‹åŒæ—¶æ‹¥æœ‰è¯»å£å’Œå†™å£
        ```C
        int pipe(int pipefd[2]);
        ```

2. æ–‡ä»¶æè¿°ç¬¦æ˜¯ä¸€ä¸ªç”¨äºè®¿é—®æ–‡ä»¶æˆ–å…¶ä»–è¾“å…¥/è¾“å‡ºèµ„æºçš„ â€œæŒ‡é’ˆâ€ã€‚åœ¨ Unix å’Œç±» Unix æ“ä½œç³»ç»Ÿä¸­ï¼Œæ–‡ä»¶æè¿°ç¬¦æ˜¯ä¸€ä¸ªéè´Ÿæ•´æ•°ï¼Œç”¨äºè¡¨ç¤ºä¸€ä¸ªæ‰“å¼€çš„æ–‡ä»¶ã€ç®¡é“ã€ç½‘ç»œè¿æ¥æˆ–å…¶ä»–ç±»ä¼¼çš„èµ„æºã€‚å½“ä¸€ä¸ªç¨‹åºæ‰“å¼€ä¸€ä¸ªæ–‡ä»¶æˆ–åˆ›å»ºä¸€ä¸ªæ•°æ®æµæ—¶ï¼Œæ“ä½œç³»ç»Ÿä¼šè¿”å›ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œç¨‹åºå¯ä»¥é€šè¿‡è¿™ä¸ªæè¿°ç¬¦æ¥è¯»å–ã€å†™å…¥æˆ–æ“ä½œå¯¹åº”çš„æ–‡ä»¶æˆ–èµ„æºã€‚

    ```C
    #include <stdio.h>
    #include <fcntl.h>
    #include <unistd.h>

    void try_open(const char *fname) {
        int fd = open(fname, O_RDWR);
        // fd is a "pointer" to a kernel object.

        printf("open(\"%s\") = %d\n", fname, fd);

        if (fd < 0) {
            perror(fname);
            goto release;
        } else {
            // ...
        }

    release:
        if (fd >= 0) {
            close(fd);
        }
    }

    int main() {
        try_open("/something/not/exist");
        try_open("/dev/sda"); // hard drive
    }
    ```

3. UNIX ç®¡é“ (pipe) æ˜¯ä¸€ç§å…¸å‹çš„è¿›ç¨‹é—´é€šä¿¡æœºåˆ¶ï¼Œå…è®¸æ•°æ®åœ¨ä¸åŒçš„è¿›ç¨‹ä¹‹é—´å•å‘æµåŠ¨ã€‚ç®¡é“å¯ä»¥è¢«è§†ä¸ºä¸€ç§ç‰¹æ®Šçš„æ–‡ä»¶ï¼Œå…¶ä¸­ä¸€ä¸ªè¿›ç¨‹å°†æ•°æ®å†™å…¥ç®¡é“çš„ä¸€ç«¯ï¼Œè€Œå¦ä¸€ä¸ªè¿›ç¨‹ä»å¦ä¸€ç«¯è¯»å–æ•°æ®ã€‚

    * pipe read åœ¨æ²¡æœ‰æ•°æ®æ—¶ä¼šç­‰å¾…
    * pipe write åœ¨æœ‰è¯»è€…æ‰“å¼€æ—¶ï¼Œä¼šå†™å…¥æ“ä½œç³»ç»Ÿçš„ç¼“å†²åŒºå¹¶è¿”å›
    * write å¦‚æœ â€œä¸å¤ªå¤šâ€ï¼Œä¸€å¯¹ write-read æ˜¯åŸå­çš„
    * write å¦‚æœè¶…è¿‡ PIPE_BUFï¼Œå¯èƒ½ä¼šè¢«æ‹†æˆå¤šä»½
    * å¦‚æœè¯»è€…å…³é—­ï¼Œä¼šæ”¶åˆ° SIGPIPE ä¿¡å·
        - ç»å¸¸çœ‹åˆ°çš„ â€œBroken Pipeâ€
    * â€œçœ‹ä¸åˆ°â€ çš„ SIGPIPE
        - `yes | head -n 1`
        - `(yes; echo $? > /dev/stderr) | head -n 1` (è¿”å›141è€Œé0ï¼Œæ‰€ä»¥å®é™…ä¸Šè¿˜æ˜¯æœ‰SIGPIPEå‘ç”Ÿ)
    * â€œçœ‹å¾—åˆ°â€ çš„ SIGPIPE
        - `python3 -c 'while True: print(1)' | head -n 1`

    ![alt text](../img/image-14.png)

    named_pipe.c:
    ```C
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <fcntl.h>
    #include <sys/stat.h>
    #include <unistd.h>
    #include <errno.h>

    // We also have UNIX domain sockets for local inter-process
    // communication--they also have a name in the file system
    // like "/var/run/docker.sock". This is similar to a named
    // pipe.
    #define PIPE_NAME "/tmp/my_pipe"

    void pipe_read() {
        int fd = open(PIPE_NAME, O_RDONLY);
        char buffer[1024];

        if (fd == -1) {
            perror("open");
            exit(1);
        }

        // Read from the pipe
        int num_read = read(fd, buffer, sizeof(buffer));
        if (num_read > 0) {
            printf("Received: %s\n", buffer);
        } else {
            printf("No data received.\n");
        }
        close(fd);
    }

    void pipe_write(const char *content) {
        // Open the pipe for writing
        int fd = open(PIPE_NAME, O_WRONLY);

        if (fd == -1) {
            perror("open");
            exit(1);
        }

        // Write the message to the pipe
        write(fd, content, strlen(content) + 1);
        close(fd);
    }

    int main(int argc, char *argv[]) {
        if (argc < 2) {
            fprintf(stderr, "Usage: %s read|write [message]\n", argv[0]);
            return 1;
        }

        // Create the named pipe if it does not exist
        if (mkfifo(PIPE_NAME, 0666) == -1) {
            if (errno != EEXIST) {
                perror("mkfifo");
                return 1;
            }
        } else {
            printf("Created " PIPE_NAME "\n");
        }

        if (strcmp(argv[1], "read") == 0) {
            pipe_read();
        } else if (strcmp(argv[1], "write") == 0) {
            pipe_write(argv[2]);
        } else {
            fprintf(stderr, "Invalid command. Use 'read' or 'write'.\n");
            return 1;
        }

        return 0;
    }
    ```

    anonymous-pipe.cï¼šçˆ¶è¿›ç¨‹æŒæœ‰å†™å£ï¼Œå­è¿›ç¨‹æŒæœ‰è¯»å£ã€‚
    ```C
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <string.h>
    #include <sys/wait.h>

    void do_parent(int fd) {
        const char *msg = "Hello, world!";

        printf("[%d] Write: '%s'\n", getpid(), msg);
        write(fd, msg, strlen(msg) + 1);

        close(fd);

        // Wait for the child to finish
        wait(NULL);

        printf("[%d] Done.\n", getpid());
    }

    void do_child(int fd) {
        static char buf[1024];

        ssize_t num_read = read(fd, buf, sizeof(buf));
        if (num_read == -1) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        printf("[%d] Got: '%s'\n", getpid(), buf);

        // Close the read end of the pipe
        close(fd);
    }

    int main() {
        int pipefd[2];

        // Create a pipe
        if (pipe(pipefd) == -1) {
            perror("pipe");
            exit(EXIT_FAILURE);
        }

        // Fork the current process
        pid_t pid = fork();
        if (pid == -1) {
            perror("fork");
            exit(EXIT_FAILURE);
        }

        if (pid == 0) {
            // Child
            close(pipefd[1]); // Close unused write end
            do_child(pipefd[0]);
        } else {
            // Parent
            close(pipefd[0]); // Close unused read end
            do_parent(pipefd[1]);
        }

        return 0;
    }
    ```

4. sh.c debugï¼šå¯ä»¥æ¸…æ¥šåœ°çœ‹åˆ°ï¼Œè¿›ç¨‹3çš„æ ‡å‡†è¾“å‡º`1`å‘ç®¡é“é‡Œå†™æ•°æ®ï¼Œç„¶åæ‰§è¡Œ`runcmd(pcmd->left);`è¿›ç¨‹4çš„æ ‡å‡†è¾“å…¥`0`ä»ç®¡é“é‡Œè¯»æ•°æ®ï¼Œç„¶åæ‰§è¡Œ`runcmd(pcmd->right);`


    ```bash
    Process 3 (11026)
    0 <-> /dev/pts/7
    1 --> [=== 2123156 ===]
    2 <-> /dev/pts/7

    Process 4 (11699)*
        0 <-- [=== 2123156 ===]
        1 <-> /dev/pts/7
        2 <-> /dev/pts/7

    112                 runcmd(pcmd->right);
    ```

5. ä»¥ä¸‹æŠ¥é”™çš„åŸå› ï¼š`>`å’Œ`|`ä¸€æ ·ï¼Œéƒ½æ˜¯å…ˆæŠŠä¸¤è¾¹çš„æ–‡ä»¶æè¿°ç¬¦å‡†å¤‡å¥½ï¼Œä¹Ÿå°±æ˜¯è¯´`sudo echo hello`å’Œæ‰“å¼€`/etc/a.txt`æ˜¯åˆ†å¼€æ‰§è¡Œçš„ï¼Œå› æ­¤æ— æƒé™æ‰“å¼€`/etc/a.txt`

    ```bash
    $ echo hello > /etc/a.txt
    bash: /etc/a.txt: Permission denied

    $ sudo echo hello > /etc/a.txt
    bash: /etc/a.txt: Permission denied
    ```

## Lecture 17 C æ ‡å‡†åº“å’Œå®ç°
!!! abstract "Take-away Messages"

    åœ¨ç³»ç»Ÿè°ƒç”¨å’Œè¯­è¨€æœºåˆ¶çš„åŸºç¡€ä¸Šï¼Œlibc ä¸ºæˆ‘ä»¬æä¾›äº†å¼€å‘è·¨å¹³å°åº”ç”¨ç¨‹åºçš„ â€œç¬¬ä¸€çº§æŠ½è±¡â€ã€‚åœ¨æ­¤åŸºç¡€ä¸Šæ„å»ºèµ·äº†ä¸‡åƒä¸–ç•Œï¼šC++ (æ‰©å……äº† C æ ‡å‡†åº“)ã€Javaã€æµè§ˆå™¨ä¸–ç•Œâ€¦â€¦ä»Šå¤©ï¼ŒC è¯­è¨€åœ¨åº”ç”¨å¼€å‘æ–¹é¢æœ‰å¾ˆå¤šç¼ºé™·ï¼Œä½†ä»ç„¶ä¸º â€œç¬¬ä¸€çº§æŠ½è±¡â€ æä¾›äº†ä¸€ä¸ªæœ‰è¶£çš„èŒƒæœ¬ã€‚

1. Cé‡Œçš„ `_start` å‡½æ•°æ˜¯ç¨‹åºæ‰§è¡Œçš„èµ·ç‚¹ã€‚å½“ä¸€ä¸ªCç¨‹åºè¢«ç¼–è¯‘å’Œé“¾æ¥æˆå¯æ‰§è¡Œæ–‡ä»¶åï¼Œæ“ä½œç³»ç»Ÿä¼šå°†ç¨‹åºåŠ è½½åˆ°å†…å­˜ä¸­ï¼Œå¹¶è·³è½¬åˆ° `_start` å‡½æ•°å¼€å§‹æ‰§è¡Œã€‚`_start` å‡½æ•°é€šå¸¸æ˜¯ç”±ç¼–è¯‘å™¨å’Œé“¾æ¥å™¨è‡ªåŠ¨ç”Ÿæˆçš„ï¼Œå®ƒè´Ÿè´£åˆå§‹åŒ–ç¨‹åºè¿è¡Œæ‰€éœ€çš„ç¯å¢ƒï¼Œç„¶åè°ƒç”¨ `main` å‡½æ•°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ`_start`å‡½æ•°æ˜¯æ“ä½œç³»ç»Ÿå’ŒäºŒè¿›åˆ¶æ–‡ä»¶ä¹‹é—´çš„çº¦å®šï¼ˆåœ¨libcé‡Œçš„Scrt1.oä¼šå¸®å¿™å®šä¹‰å¥½ï¼‰ã€‚ä»¥ä¸‹å¯ä»¥çœ‹åˆ°Entry point addressæ˜¯0x4019f5ï¼Œæ­£æ˜¯`_start`çš„åœ°å€ã€‚

    ```bash
    linux$ readelf -h sh
    ELF Header:
    Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
    Class:                             ELF64
    Data:                              2's complement, little endian
    Version:                           1 (current)
    OS/ABI:                            UNIX - System V
    ABI Version:                       0
    Type:                              EXEC (Executable file)
    Machine:                           Advanced Micro Devices X86-64
    Version:                           0x1
    Entry point address:               0x4019f5
    Start of program headers:          64 (bytes into file)
    Start of section headers:          23696 (bytes into file)
    Flags:                             0x0
    Size of this header:               64 (bytes)
    Size of program headers:           56 (bytes)
    Number of program headers:         8
    Size of section headers:           64 (bytes)
    Number of section headers:         19
    Section header string table index: 18

    linux$ objdump -d sh | less
    00000000004019f5 <_start>:
    4019f5:       f3 0f 1e fa             endbr64 
    4019f9:       55                      push   %rbp
    4019fa:       48 89 e5                mov    %rsp,%rbp
    4019fd:       b8 00 00 00 00          mov    $0x0,%eax
    401a02:       e8 e9 fe ff ff          call   4018f0 <main>
    401a07:       be 00 00 00 00          mov    $0x0,%esi
    401a0c:       bf 3c 00 00 00          mov    $0x3c,%edi
    401a11:       b8 00 00 00 00          mov    $0x0,%eax
    401a16:       e8 e5 f5 ff ff          call   401000 <syscall>
    401a1b:       90                      nop
    401a1c:       5d                      pop    %rbp
    401a1d:       c3                      ret
    ```

2. <span style="color:blue;">ç³»ç»Ÿè°ƒç”¨æ˜¯åœ°åŸºï¼ŒC è¯­è¨€æ˜¯æ¡†æ¶ã€‚</span>glibc çš„ä»£ç æœ‰éå¸¸æ²‰é‡çš„å†å²åŒ…è¢±ï¼Œæ›´é€‚åˆå­¦ä¹ çš„ libc å®ç°ï¼š[musl libc](https://musl.libc.org/)

    ä½¿ç”¨musl-gccæ¥ç¼–è¯‘ï¼Œè€Œä¸æ˜¯gccï¼Œçœ‹ä¸‹musl-gccçš„çœŸé¢ç›®ï¼šmusl-gccé€šè¿‡.specsè„šæœ¬æ¥æ§åˆ¶ç¼–è¯‘å™¨ä¸è¦é“¾æ¥glibcè€Œæ˜¯é“¾æ¥è‡ªå·±çš„libcã€‚
    
    ```bash
    linux$ cat (which musl-gcc)
    #!/bin/sh
    exec "${REALGCC:-x86_64-linux-gnu-gcc}" "$@" -specs "/usr/lib/x86_64-linux-musl/musl-gcc.specs"
    ```

3. debug dummy.c

    ```C
    int main() {
        return 1;
    }
    ```

    <figure markdown> 
        ![Image title](../img/image-15.png){ width="300" }
        <figcaption>æ“ä½œç³»ç»Ÿå°†è¿™äº›å†…å®¹æ”¾å…¥æ ˆä¸­</figcaption>
    </figure>

    env.cï¼š

    ```C
    #include <stdio.h>

    // A mysteriously defined symbol.
    // Someone must defined it elsewhere.
    extern char **environ;

    // Like this even more mysterious one.
    // "end" can be of any type.
    extern void ******************************end;

    int main(int argc, char *argv[], char *envp[]) {
        printf("environ: %p\n", environ);
        printf("envp:    %p\n", envp);

        for (char **env = environ; *env; env++) {
            // key=value
            printf("%s\n", *env);
        }

        end = NULL; // ???
    }
    ```

    è¾“å‡º:

    ```bash
    environ: 0x7ffdb556d2d8
    envp:    0x7ffdb556d2d8
    SHELL=/bin/bash
    COLORTERM=truecolor
    ...
    ```

    <a id="system-v-abi"></a>
    [System V ABI](https://jyywiki.cn/OS/manuals/sysv-abi.pdf)é‡Œå®šä¹‰äº†è§„èŒƒï¼š

    ![alt text](../img/image-16.png){ width="500" }

    å…¶ä»–çŠ¶æ€ (ä¸»è¦æ˜¯å†…å­˜) åˆ™æ˜¯ç”±å¯æ‰§è¡Œæ–‡ä»¶æŒ‡å®šï¼Œè¯¦æƒ…çœ‹[Lecture 19](#minimal-loader)ã€‚

4. libcå¯¹ç³»ç»Ÿè°ƒç”¨ä¸ç¯å¢ƒçš„æŠ½è±¡

    ä»€ä¹ˆæ˜¯stdoutï¼Ÿ

    ```C
    static unsigned char buf[BUFSIZ+UNGET];
    hidden FILE __stdout_FILE = {
        .buf = buf+UNGET,
        .buf_size = sizeof buf-UNGET,
        .fd = 1,
        .flags = F_PERM | F_NORD,
        .lbf = '\n',
        .write = __stdout_write,
        .seek = __stdio_seek,
        .close = __stdio_close,
        .lock = -1,
    };
    FILE *const stdout = &__stdout_FILE;
    ```

5. æ‰€æœ‰ API éƒ½å¯èƒ½å¤±è´¥ï¼Œerrno æ˜¯è¿›ç¨‹å…±äº«è¿˜æ˜¯çº¿ç¨‹ç‹¬äº«ï¼Ÿâ¡ï¸ çº¿ç¨‹ç‹¬äº«ï¼Œgdbè°ƒè¯•å¯ä»¥çœ‹åˆ°errnoæ˜¯tls (Thread Local Storage)çš„ã€‚

6. malloc() çš„è§‚å¯Ÿï¼šæˆ‘ä»¬éœ€è¦ç®¡ç†çš„å¯¹è±¡
    * å°å¯¹è±¡ï¼šå­—ç¬¦ä¸²ã€ä¸´æ—¶å¯¹è±¡ç­‰ï¼›ç”Ÿå­˜å‘¨æœŸå¯é•¿å¯çŸ­
    * ä¸­å¯¹è±¡ï¼šå®¹å™¨ã€å¤æ‚çš„å¯¹è±¡ï¼›æ›´é•¿çš„ç”Ÿå­˜å‘¨æœŸ
    * å¤§å¯¹è±¡ï¼šå·¨å¤§çš„å®¹å™¨ã€åˆ†é…å™¨ï¼›å¾ˆé•¿çš„ç”Ÿå­˜å‘¨æœŸ

    è®¾ç½®ä¸¤å¥—ç³»ç»Ÿï¼š

    * Fast path (System I)
        - æ€§èƒ½æå¥½ã€å¹¶è¡Œåº¦æé«˜ã€è¦†ç›–å¤§éƒ¨åˆ†æƒ…å†µ
        - ä½†æœ‰å°æ¦‚ç‡ä¼šå¤±è´¥ (fall back to slow path)
    * Slow path (System II)
        - ä¸åœ¨ä¹é‚£ä¹ˆå¿«
        - ä½†æŠŠå›°éš¾çš„äº‹æƒ…åšå¥½
    * è®¡ç®—æœºç³»ç»Ÿé‡Œæœ‰å¾ˆå¤šè¿™æ ·çš„ä¾‹å­ (æ¯”å¦‚ cache)

    malloc: Fast Path è®¾è®¡ â¡ï¸ ç«‹å³åœ¨çº¿ç¨‹æœ¬åœ°åˆ†é…å®Œæˆã€‚æµªè´¹ä¸€ç‚¹ç©ºé—´ï¼Œä½†ä½¿æ‰€æœ‰ CPU éƒ½èƒ½å¹¶è¡Œåœ°ç”³è¯·å†…å­˜
    
    * çº¿ç¨‹éƒ½äº‹å…ˆç“œåˆ†ä¸€äº› â€œé¢†åœ°â€ (thread-local allocation buffer)
    * é»˜è®¤ä»è‡ªå·±çš„é¢†åœ°é‡Œåˆ†é…
        - é™¤äº†åœ¨å¦ä¸€ä¸ª CPU é‡Šæ”¾ï¼Œacquire lock å‡ ä¹æ€»æ˜¯æˆåŠŸ
    * å¦‚æœè‡ªå·±çš„é¢†åœ°ä¸è¶³ï¼Œå°±ä»å…¨å±€çš„æ± å­é‡Œå€Ÿä¸€ç‚¹

    malloc: Slow Path è®¾è®¡ â¡ï¸ pgalloc()

7. å¦‚ä½•è°ƒè¯•è¿›å…¥ musl libc

    ```bash
    tar -xzf musl-1.2.5.tar.gz  # è§£å‹åè¿›å…¥
    cd musl-1.2.5
    ./configure --enable-debug  # è¿™æ­¥æ˜¯å…³é”®!
    make && make install        # ç¼–è¯‘å¹¶å®‰è£…åˆ° /usr/local/musl
    echo 'export PATH="/usr/local/musl/bin:$PATH"' >>  ~/.bashrc
    source ~/.bashrc            # ä¿®æ”¹ç¯å¢ƒå˜é‡ path å¹¶ç”Ÿæ•ˆ
    ```

## Lecture 18 Linux æ“ä½œç³»ç»Ÿ
!!! abstract "Take-away Messages"

    æˆ‘ä»¬ä» CPU Reset åçš„ â€œç¡¬ä»¶åˆå§‹çŠ¶æ€â€ åˆ°æ“ä½œç³»ç»ŸåŠ è½½å®Œ init è¿›ç¨‹åçš„ â€œè½¯ä»¶åˆå§‹çŠ¶æ€â€ï¼Œä»æ­¤ä»¥åï¼Œè®¡ç®—æœºç³»ç»Ÿä¸­çš„ä¸€åˆ‡éƒ½æ˜¯ç”±åº”ç”¨ç¨‹åºä¸»å¯¼çš„ï¼Œæ“ä½œç³»ç»Ÿåªæ˜¯æä¾›ç³»ç»Ÿè°ƒç”¨è¿™ä¸€æœåŠ¡æ¥å£ã€‚æ­£æ˜¯ç³»ç»Ÿè°ƒç”¨ (åŒ…æ‹¬æ“ä½œç³»ç»Ÿä¸­çš„å¯¹è±¡) è¿™ä¸ªç¨³å®šçš„ã€å‘åå…¼å®¹çš„æ¥å£éšç€å†å²æ¼”åŒ–å’Œç§¯ç´¯ï¼Œå½¢æˆäº†éš¾ä»¥é€¾è¶Šçš„æŠ€æœ¯å±éšœï¼Œåœ¨é¢ è¦†æ€§çš„æŠ€æœ¯é©æ–°åˆ°æ¥ä¹‹å‰ï¼Œå¦èµ·ç‚‰ç¶éƒ½æ˜¯éå¸¸å›°éš¾çš„ã€‚

1. å¯åŠ¨ Linux - Initial RAM FS

    ç¡¬ä»¶ (ISA) â†’ æ“ä½œç³»ç»Ÿå¯¹è±¡/ç³»ç»Ÿè°ƒç”¨ â†’ libc â†’ ç³»ç»Ÿå·¥å…· (coretuils, busybox, ...) â†’ åº”ç”¨ç¨‹åº (xfce, vscode)

    ```bash
    make initramfs # éœ€è¦/boot/vmlinuzï¼Œwslé‡Œæ²¡æœ‰ï¼Œå°±æ²¡æœ‰åšä¸‹å»äº†
    make
    make run
    /bin/busybox ls
    ```

    ```bash
    exec switch_root /newroot/ /init
    # switch_root ç¨‹åºé¦–å…ˆå°†å½“å‰çš„æ ¹æ–‡ä»¶ç³»ç»Ÿï¼ˆinitramfsï¼‰å¸è½½ã€‚
    # ç„¶åï¼Œå®ƒå°†æ–°æ ¹æ–‡ä»¶ç³»ç»Ÿï¼ˆ/newroot/ï¼‰æŒ‚è½½åˆ° / ç›®å½•ã€‚
    # æ¥ä¸‹æ¥ï¼Œå®ƒæ‰§è¡Œæ–°æ ¹æ–‡ä»¶ç³»ç»Ÿä¸­çš„åˆå§‹åŒ–ç¨‹åº /initï¼Œä»¥å¯åŠ¨ç³»ç»Ÿçš„åˆå§‹åŒ–è¿›ç¨‹ã€‚
    # æœ€åï¼Œå½“å‰çš„ shell è¿›ç¨‹è¢«æ›¿æ¢ä¸ºæ–°çš„åˆå§‹åŒ–è¿›ç¨‹ï¼Œç³»ç»Ÿç»§ç»­å¯åŠ¨ã€‚
    # (execï¼šè¿™æ˜¯ä¸€ä¸ª shell å†…ç½®å‘½ä»¤ï¼Œç”¨äºæ‰§è¡ŒæŒ‡å®šçš„å‘½ä»¤å¹¶æ›¿æ¢å½“å‰çš„ shell è¿›ç¨‹ã€‚)
    ```

    æœ€å° Linux: æˆ‘ä»¬å¯ä»¥åœ¨ initramfs ä¸­æ”¾ç½®ä»»æ„çš„æ•°æ®â€”â€”åŒ…æ‹¬åº”ç”¨ç¨‹åºã€å†…æ ¸æ¨¡å— (é©±åŠ¨)ã€æ•°æ®ã€è„šæœ¬â€¦â€¦æ“ä½œç³»ç»Ÿä¸–ç•Œå·²ç»å¼€å§‹è¿è½¬ï¼›ä½†ç›´åˆ°æ‰§è¡Œ switch_root (pivot_root) (æ³¨æ„è°ƒç”¨switch_rootçš„pidå¿…é¡»æ˜¯1)ï¼Œæ‰çœŸæ­£å¼€å§‹ ä»Šå¤© Linux åº”ç”¨ä¸–ç•Œ (systemd) çš„å¯åŠ¨ã€‚

    ```bash
    linux$ ls /sbin/init # ç°ä»£çš„Linuxå¯åŠ¨ç”¨çš„æ˜¯/sbin/init
    lrwxrwxrwx /sbin/init -> /lib/systemd/systemd
    ```

2. Initramfs: å¹¶ä¸æ˜¯æˆ‘ä»¬å®é™…çœ‹åˆ°çš„ Linux

    å¯åŠ¨çš„åˆçº§é˜¶æ®µ

    * åŠ è½½å‰©ä½™å¿…è¦çš„é©±åŠ¨ç¨‹åºï¼Œä¾‹å¦‚ç£ç›˜/ç½‘å¡
    * æŒ‚è½½å¿…è¦çš„æ–‡ä»¶ç³»ç»Ÿ
    * å°†æ ¹æ–‡ä»¶ç³»ç»Ÿå’Œæ§åˆ¶æƒç§»äº¤ç»™å¦ä¸€ä¸ªç¨‹åºï¼Œä¾‹å¦‚ systemd (system and service manager)

    å¯åŠ¨çš„ç¬¬äºŒçº§é˜¶æ®µ

    * çœ‹ä¸€çœ‹ç³»ç»Ÿé‡Œçš„ /sbin/init æ˜¯ä»€ä¹ˆï¼Ÿ
    * è®¡ç®—æœºç³»ç»Ÿæ²¡æœ‰é­”æ³• (ä¸€åˆ‡éƒ½æœ‰åˆé€‚çš„è§£é‡Š)
        - pstree åŸ‹ä¸‹çš„ä¼ç¬”å¾—åˆ°è§£ç­”ï¼špstreeè¾“å‡ºçš„æ ¹æ˜¯systemd

    ```bash
    linux$ pstree
    systemdâ”€â”¬â”€.vasdâ”€â”€â”€.vasdâ”€â”€â”€4*[.vasd]
            â”œâ”€ModemManagerâ”€â”€â”€2*[{ModemManager}]
            â”œâ”€NetworkManagerâ”€â”€â”€2*[{NetworkManager}]
            â”œâ”€accounts-daemonâ”€â”€â”€2*[{accounts-daemon}]
            â”œâ”€acpid
            â”œâ”€at-spi-bus-launâ”€â”¬â”€dbus-daemon
            â”‚                 â””â”€3*[{at-spi-bus-laun}]
            â”œâ”€at-spi2-registrâ”€â”€â”€2*[{at-spi2-registr}]
            â”œâ”€avahi-daemonâ”€â”€â”€avahi-daemon
            â”œâ”€colordâ”€â”€â”€2*[{colord}]
            â”œâ”€containerdâ”€â”€â”€11*[{containerd}]
            â”œâ”€containerd-shimâ”€â”¬â”€dumb-initâ”€â”¬â”€bashâ”€â”€â”€Xvfb
            â”‚                 â”‚           â”œâ”€2*[conhost.exe]
            â”‚                 â”‚           â”œâ”€...
            â”‚                 â”‚           â””â”€wineserver
            â”‚                 â””â”€12*[{containerd-shim}]
            â”œâ”€containerd-shimâ”€â”¬â”€dumb-initâ”€â”¬â”€bashâ”€â”€â”€Xvfb
            â”‚                 â”‚           â””â”€mount.ntfs
            â”‚                 â””â”€12*[{containerd-shim}]
            â”œâ”€3*[containerd-shimâ”€â”¬â”€dumb-initâ”€â”¬â”€bashâ”€â”€â”€Xvfb]
            â”‚                    â”‚           â””â”€mount.ntfs]
            â”‚                    â””â”€11*[{containerd-shim}]]
            â”œâ”€cron
            â”œ...
            â””â”€xrdp-sesman
    ```


## Lecture 19 å¯æ‰§è¡Œæ–‡ä»¶å’ŒåŠ è½½
!!! abstract "Take-away Messages"

    å¯æ‰§è¡Œæ–‡ä»¶æ˜¯ä¸€ä¸ªæè¿°çŠ¶æ€æœºåˆå§‹çŠ¶æ€çš„æ•°æ®ç»“æ„ (å­—èŠ‚åºåˆ—)ï¼›åŠ è½½å™¨å°±æ˜¯æŠŠè¿™ä¸ª â€œåˆå§‹çŠ¶æ€â€ æ¬è¿åˆ°æ“ä½œç³»ç»Ÿä¸­çš„ç¨‹åºã€‚ç”¨æ•°æ®ç»“æ„çš„çœ¼å…‰çœ‹å¯æ‰§è¡Œæ–‡ä»¶ï¼Œå°±ä¸éš¾å‘ç°å®ƒä¸å¥½é˜…è¯»çš„åŸå› ï¼šå®ƒçš„è®¾è®¡è€…å¹¶æ²¡æœ‰æ‰“ç®—è®©ä½ é˜…è¯»å®ƒã€‚è¿™æ ·çš„éš¾é¢˜åœ¨ã€Šæ“ä½œç³»ç»Ÿã€‹è¯¾ç¨‹ä¸­ç»å¸¸å‡ºç°ï¼›è€Œæˆ‘ä»¬çš„åº”å¯¹æ–¹æ³•æ˜¯å…ˆç†è§£ä¸€ä¸ªç²—ç³™ä½†é‡è¦çš„æ¨¡å‹ï¼Œç„¶ååœ¨æ­¤åŸºç¡€ä¸Šç†è§£å·¥ä¸šçº§å®ç°é¢ä¸´çš„æŒ‘æˆ˜å’Œé—®é¢˜ã€‚

1. ä»€ä¹ˆæ˜¯å¯æ‰§è¡Œæ–‡ä»¶ï¼Ÿâ¡ï¸ è¿›ç¨‹åˆå§‹çŠ¶æ€çš„æè¿°

    * ä¸€ä¸ªæ“ä½œç³»ç»Ÿä¸­çš„å¯¹è±¡ (æ–‡ä»¶)
    * ä¸€ä¸ªå­—èŠ‚åºåˆ— (æˆ‘ä»¬å¯ä»¥æŠŠå®ƒå½“å­—ç¬¦ä¸²ç¼–è¾‘)
    * ä¸€ä¸ªæè¿°äº†çŠ¶æ€æœºåˆå§‹çŠ¶æ€çš„æ•°æ®ç»“æ„

    ELF: Executable and Linkable Formatï¼Œ[binutils](https://www.gnu.org/software/binutils/) ä¸­çš„å·¥å…·å¯ä»¥è®©æˆ‘ä»¬æŸ¥çœ‹å…¶ä¸­çš„é‡è¦ä¿¡æ¯

2. UNIX a.out â¡ï¸ â€œassembler outputâ€
    
    ä»¥å‰çš„ç‰ˆæœ¬ï¼šä¸€ä¸ªç›¸å¯¹å¹³å¦çš„æ•°æ®ç»“æ„

    ```C
    struct exec {
        uint32_t  a_midmag;  // Machine ID & Magic
        uint32_t  a_text;    // Text segment size
        uint32_t  a_data;    // Data segment size
        uint32_t  a_bss;     // BSS segment size (å­˜å‚¨æœªåˆå§‹åŒ–çš„å…¨å±€å˜é‡å’Œé™æ€å˜é‡)
        uint32_t  a_syms;    // Symbol table size
        uint32_t  a_entry;   // Entry point
        uint32_t  a_trsize;  // Text reloc table size
        uint32_t  a_drsize;  // Data reloc table size
    };
    ```

3. Funny Linkable Executable

    æ ¸å¿ƒè®¾è®¡æ€è·¯

    * ä¸€åˆ‡éƒ½å¯¹äººç±»ç›´æ¥å¯è¯» (æ‰€æœ‰ä¿¡æ¯éƒ½åœ¨å±€éƒ¨)
    * å›å½’é“¾æ¥å’ŒåŠ è½½ä¸­çš„æ ¸å¿ƒæ¦‚å¿µï¼š<span style="color:blue;">ä»£ç ã€ç¬¦å·ã€é‡å®šä½</span> (å¤šä¸ªæ–‡ä»¶é“¾æ¥èµ·æ¥å¿…éœ€ç¬¦å·ã€é‡å®šä½ã€‚ç¬¦å·ï¼šmainå‡½æ•°é‡Œä¸€ä¸ªglobalçš„å˜é‡xï¼Œåˆ«äººå¯ä»¥ç”¨å®ƒï¼›é‡å®šä½ï¼šæˆ‘ç”¨äº†ä¸€ä¸ªå˜é‡xï¼Œæ˜¯åˆ«äººå®šä¹‰çš„)

    ä»£ç  (ğŸ”¢)ã€ç¬¦å· (ğŸ“¤)ã€é‡å®šä½ (â“)ï¼šå‡‘é½è¿™ä¸‰è¦ç´ ï¼Œæˆ‘ä»¬å°±å¯ä»¥åšå¯æ‰§è¡Œæ–‡ä»¶äº†ï¼

    ```C
    ğŸ”¢: ff ff ff ff ff ff ff
    ğŸ”¢: ff ff ff ff ff ff ff
    ğŸ“¤: _start
    ğŸ”¢: 48 c7 c0 3c 00 00 00
    ğŸ”¢: 48 c7 c7 2a 00 00 00
                  ^
                  |
            This byte is return code (42).
    ğŸ”¢: 0f 05 ff ff ff ff ff
    ğŸ”¢: ff ff ff ff ff ff ff
    â“: i32(unresolved_symbol - 0x4 - ğŸ“)
    ```

    ```bash
    linux$ ./minimal.fle ; echo $?
    42    # å¯¹åº”äºminimal.fleé‡Œçš„ 2a (return code)
    ```

    å¼€å¤´çš„`48 c7`æ˜¯moveæŒ‡ä»¤ï¼Œç»“å°¾çš„`0f 05`æ˜¯syscallæŒ‡ä»¤ã€‚

4. foo.c

    ```C
    #include "minilib.h"

    // Global data
    extern int n;
    char msg[] = "Hello World!\n";

    int foo() {
        return n;
    }
    ```

    ```bash
    linux$ make
    ./cc -Wall -g -Os foo.c -o foo.o
    ./cc -Wall -g -Os libc.c -o libc.o
    ./cc -Wall -g -Os main.c -o main.o
    ./ld foo.fle libc.fle main.fle -o hello
    ```

    foo.fle

    ```C
    {
        "type": ".obj",
        ".text": [
            "ğŸ·ï¸: _text",
            "ğŸ“¤: foo",
            "ğŸ”¢: f3 0f 1e fa 8b 05",
            "â“: i32(n - 0x4 - ğŸ“)",
            "ğŸ”¢: c3"
        ],
        ".data": [
            "ğŸ“¤: msg",
            "ğŸ”¢: 48 65 6c 6c 6f 20 57 6f 72 6c 64 21 0a 00"
        ],
        ".bss": []
    }
    ```
5. ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶: .c â†’ é¢„å¤„ç†(-E) â†’ .i â†’ ç¼–è¯‘(-S) â†’ .s â†’ æ±‡ç¼–(-c) â†’ .o â†’ é“¾æ¥ â†’ .out

    (1) é¢„å¤„ç†

    * æºä»£ç  (.c) â†’ æºä»£ç  (.i)          â¡ï¸ `gcc -E foo.c -o foo.i`
    * Ctrl-C & Ctrl-V (#include)
    * å­—ç¬¦ä¸²æ›¿æ¢
    * ä»Šå¤©ï¼šæˆ‘ä»¬æœ‰[è¿‡ç¨‹å®](https://doc.rust-lang.org/reference/procedural-macros.html)

    (2) ç¼–è¯‘ (cc)

    * æºä»£ç  (.i) â†’ æ±‡ç¼–ä»£ç  (.s)         â¡ï¸ `gcc -S foo.i -o foo.s`
    * â€œé«˜çº§çŠ¶æ€æœºâ€ åˆ° â€œä½çº§çŠ¶æ€æœºâ€ çš„ç¿»è¯‘
    * æœ€ç»ˆç”Ÿæˆå¸¦æ ‡æ³¨çš„æŒ‡ä»¤åºåˆ—

    (3) æ±‡ç¼– (as)

    * æ±‡ç¼–ä»£ç  (.s) â†’ ç›®æ ‡æ–‡ä»¶ (.o)       â¡ï¸ `gcc -c foo.s -o foo.o`
    * æ–‡ä»¶ = sections (.text, .data, .rodata.str.1, ...)
        - å¯¹äº ELFï¼Œæ¯ä¸ª section æœ‰å®ƒçš„æƒé™ã€å†…å­˜å¯¹é½ç­‰ä¿¡æ¯
    * section ä¸­çš„ä¸‰è¦ç´ 
        - ä»£ç  (å­—èŠ‚åºåˆ—)
        - ç¬¦å·ï¼šæ ‡è®° â€œå½“å‰â€ çš„ä½ç½®
        - é‡å®šä½ï¼šæš‚æ—¶ä¸èƒ½ç¡®å®šçš„æ•°å€¼ (é“¾æ¥æ—¶ç¡®å®š)

    (4) é“¾æ¥ (ld)                         â¡ï¸ `gcc foo.o -o foo`

    * å¤šä¸ªç›®æ ‡æ–‡ä»¶ (.o) â†’ å¯æ‰§è¡Œæ–‡ä»¶ (a.out)
    * åˆå¹¶æ‰€æœ‰çš„ sections
        - åˆ†åˆ«åˆå¹¶ .text, .data, .bss ä¸­çš„ä»£ç 
        - æŠŠ sections â€œå¹³é“ºâ€ æˆå­—èŠ‚åºåˆ—
        - ç¡®å®šæ‰€æœ‰ç¬¦å·çš„ä½ç½®
        - è§£æå…¨éƒ¨é‡å®šä½
    * å¾—åˆ°ä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶
        - (ç¨‹åºåˆå§‹å†…å­˜çŠ¶æ€çš„æè¿°)

6. ç¨‹åºçš„åŠ è½½ï¼šæŠŠ â€œå­—èŠ‚åºåˆ—â€ æ¬åˆ°å†…å­˜

    * æ²¡é”™ï¼Œå°±åªåšè¿™ä¸€ä»¶äº‹
    * ç„¶åè®¾ç½®æ­£ç¡®çš„ PCï¼Œå¼€å§‹è¿è¡Œ

    ```python
    mem = mmap.mmap(
        fileno=-1, length=len(bs),
        prot=mmap.PROT_READ | mmap.PROT_WRITE | mmap.PROT_EXEC,
        flags=mmap.MAP_PRIVATE | mmap.MAP_ANONYMOUS,
    )
    mem.write(bs)
    mem.flush()
    call_pointer(mem, fle['symbols']['_start'])
    ```

7. `#!` - Shebang

    UNIX å¯¹ # æ³¨é‡Šçš„ â€œå¦™ç”¨â€ï¼šåœ¨ UNIX çš„æ—©æœŸï¼Œä¸ºäº†èƒ½æ›´æ–¹ä¾¿åœ°å°†è„šæœ¬ä½œä¸ºå¯æ‰§è¡Œæ–‡ä»¶ï¼Œå®ç°äº† #! å¼€å¤´çš„ â€œå¯æ‰§è¡Œæ–‡ä»¶â€ï¼Œå¹¶æ²¿ç”¨è‡³ä»Šã€‚Shebang ä¼šè°ƒç”¨ç¬¬ä¸€è¡Œä¸­æ‰§è¡Œçš„å‘½ä»¤å’Œå‚æ•°ï¼Œå¹¶æŠŠè¿™ä¸ªè„šæœ¬æ–‡ä»¶ä½œä¸ºå‘½ä»¤è¡Œå‚æ•°ä¼ å…¥ã€‚

    file.bin:
    ```C
    #!A B C
    // æ“ä½œç³»ç»Ÿä¼šæ‰§è¡Œ execve(A, ["A", "B C", "file.bin"], envp)
    ```

    example1:

    A.cå¦‚ä¸‹ï¼Œç¼–è¯‘åå¾—åˆ°å¯æ‰§è¡Œæ–‡ä»¶A
    
    ```C
    #include <stdio.h>

    int main(int argc, char *argv[]) {
        for (int i = 0; i < argc; i++) {
            printf("argv[%d] = %s\n", i, argv[i]);
        }
    }
    ```

    goodè„šæœ¬å†…å®¹å¦‚ä¸‹ï¼š

    ```bash
    #!A B C

    This can be any script.
    ```

    æ‰§è¡Œç»“æœï¼š
    ```bash
    linux$ ./good 1 2
    argv[0] = A
    argv[1] = B C
    argv[2] = ./good
    argv[3] = 1
    argv[4] = 2
    ```

    example2:

    bæ–‡ä»¶å†…å®¹å¦‚ä¸‹ï¼š
    ```bash
    #! /usr/bin/env python3

    print("Hello World");
    ```

    æ‰§è¡Œç»“æœï¼š
    ```bash
    linux$ ./b
    Hello World
    ```

8. ELFä¾‹å­ï¼ša.c

    ```C
    int n;
    __thread int x;         // in tbss, t means thread local
    __thread int x1 = 100;  // in tdata, å·²åˆå§‹åŒ–çš„æ•°æ®åœ¨dataèŠ‚
    static __thread int y;

    extern __thread int z;

    int foo()
    {
        return z; // å¯ä»¥çœ‹åˆ°R_X86_64_GOTTPOFF z - 4
    }
    ```

    ```bash
    linux$ gcc -c fPIE a.c
    gcc: warning: fPIE: linker input file unused because linking not done
    gcc: error: fPIE: linker input file not found: No such file or directory
    linux$ ls
    total 8.0K
    -rw-r--r-- 1 chaofu chaofu 1.7K Nov  8 19:26 a.o
    -rw-r--r-- 1 chaofu chaofu  122 Nov  8 19:26 a.c
    linux$ readelf -a a.o
    ELF Header:
    Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
    Class:                             ELF64
    Data:                              2's complement, little endian
    Version:                           1 (current)
    OS/ABI:                            UNIX - System V
    ABI Version:                       0
    Type:                              REL (Relocatable file)
    Machine:                           Advanced Micro Devices X86-64
    Version:                           0x1
    Entry point address:               0x0
    Start of program headers:          0 (bytes into file)
    Start of section headers:          688 (bytes into file)
    Flags:                             0x0
    Size of this header:               64 (bytes)
    Size of program headers:           0 (bytes)
    Number of program headers:         0
    Size of section headers:           64 (bytes)
    Number of section headers:         15
    Section header string table index: 14

    Section Headers:
    [Nr] Name              Type             Address           Offset
        Size              EntSize          Flags  Link  Info  Align
    [ 0]                   NULL             0000000000000000  00000000
        0000000000000000  0000000000000000           0     0     0
    [ 1] .text             PROGBITS         0000000000000000  00000040
        0000000000000014  0000000000000000  AX       0     0     1
    [ 2] .rela.text        RELA             0000000000000000  00000200
        0000000000000018  0000000000000018   I      12     1     8
    [ 3] .data             PROGBITS         0000000000000000  00000054
        0000000000000000  0000000000000000  WA       0     0     1
    [ 4] .bss              NOBITS           0000000000000000  00000054
        0000000000000004  0000000000000000  WA       0     0     4
    [ 5] .tbss             NOBITS           0000000000000000  00000054
        0000000000000008  0000000000000000 WAT       0     0     4
    [ 6] .tdata            PROGBITS         0000000000000000  00000054
        0000000000000004  0000000000000000 WAT       0     0     4
    [ 7] .comment          PROGBITS         0000000000000000  00000058
        000000000000002c  0000000000000001  MS       0     0     1
    [ 8] .note.GNU-stack   PROGBITS         0000000000000000  00000084
        0000000000000000  0000000000000000           0     0     1
    [ 9] .note.gnu.pr[...] NOTE             0000000000000000  00000088
        0000000000000020  0000000000000000   A       0     0     8
    [10] .eh_frame         PROGBITS         0000000000000000  000000a8
        0000000000000038  0000000000000000   A       0     0     8
    [11] .rela.eh_frame    RELA             0000000000000000  00000218
        0000000000000018  0000000000000018   I      12    10     8
    [12] .symtab           SYMTAB           0000000000000000  000000e0
        00000000000000f0  0000000000000018          13     4     8
    [13] .strtab           STRTAB           0000000000000000  000001d0
        000000000000002a  0000000000000000           0     0     1
    [14] .shstrtab         STRTAB           0000000000000000  00000230
        0000000000000079  0000000000000000           0     0     1
    Key to Flags:
    W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
    L (link order), O (extra OS processing required), G (group), T (TLS),
    C (compressed), x (unknown), o (OS specific), E (exclude),
    D (mbind), l (large), p (processor specific)

    There are no section groups in this file.

    There are no program headers in this file.

    There is no dynamic section in this file.

    Relocation section '.rela.text' at offset 0x200 contains 1 entry:
    Offset          Info           Type           Sym. Value    Sym. Name + Addend
    00000000000b  000900000016 R_X86_64_GOTTPOFF 0000000000000000 z - 4

    Relocation section '.rela.eh_frame' at offset 0x218 contains 1 entry:
    Offset          Info           Type           Sym. Value    Sym. Name + Addend
    000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0
    No processor specific unwind information to decode

    Symbol table '.symtab' contains 10 entries:
    Num:    Value          Size Type    Bind   Vis      Ndx Name
        0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
        1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS a.c
        2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text
        3: 0000000000000004     4 TLS     LOCAL  DEFAULT    5 y
        4: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 n
        5: 0000000000000000     4 TLS     GLOBAL DEFAULT    5 x
        6: 0000000000000000     4 TLS     GLOBAL DEFAULT    6 x1
        7: 0000000000000000    20 FUNC    GLOBAL DEFAULT    1 foo
        8: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_
        9: 0000000000000000     0 TLS     GLOBAL DEFAULT  UND z

    No version information found in this file.

    Displaying notes found in: .note.gnu.property
    Owner                Data size        Description
    GNU                  0x00000010       NT_GNU_PROPERTY_TYPE_0
        Properties: x86 feature: IBT, SHSTK
    ```

9. åŠ è½½ ELF æ–‡ä»¶

    * å°†å¤šæ®µå­—èŠ‚åºåˆ—å¤åˆ¶åˆ°åœ°å€ç©ºé—´ä¸­
        - åˆ†åˆ«èµ‹äºˆå¯è¯»/å¯å†™/å¯æ‰§è¡Œæƒé™
    * ç„¶åè·³è½¬åˆ°æŒ‡å®šçš„ entry (é»˜è®¤ä¸º _start) æ‰§è¡Œ
    * ELF æ˜¯ â€œäºŒè¿›åˆ¶æ•°æ®ç»“æ„â€ï¼Œ`readelf -l` æè¿°äº†å¦‚ä½•åŠ è½½å®ƒ
        - Offset: segment åœ¨æ–‡ä»¶ä¸­çš„åç§»é‡
        - VirtAddr: æ®µåœ¨å†…å­˜ä¸­åº”å½“è¢«åŠ è½½åˆ°çš„èµ·å§‹åœ°å€
        - PhysAddr (ä¸€èˆ¬ä¸ç”¨)
        - FileSiz: æ®µåœ¨æ–‡ä»¶ä¸­çš„å­—èŠ‚æ•°
        - MemSiz: æ®µåœ¨å†…å­˜ä¸­çš„å­—èŠ‚æ•° (å¯èƒ½å¤§äºæ–‡ä»¶å¤§å°)
        - Flags: æƒé™ï¼Œä¾‹å¦‚ RWE
        - Align: è™šæ‹Ÿåœ°å€çš„å¯¹é½

    ```bash
    linux$ ./loader minimal 
    Hello, OS World
    linux$ ./minimal 
    Hello, OS World
    linux$ readelf -l minimal 

    Elf file type is EXEC (Executable file)
    Entry point 0x401000
    There are 2 program headers, starting at offset 64

    Program Headers:
    Type           Offset             VirtAddr           PhysAddr
                    FileSiz            MemSiz              Flags  Align
    LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                    0x00000000000000b0 0x00000000000000b0  R      0x1000
    LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000
                    0x0000000000000058 0x0000000000000058  R E    0x1000

    Section to Segment mapping:
    Segment Sections...
    00     
    01     .text 
    ```

    <a id="minimal-loader"></a>
    æ„æ€æ˜¯ï¼Œloaderåº”å½“å°†minimalè¿™ä¸ªæ–‡ä»¶çš„offsetä¸º0çš„åœ°æ–¹ï¼Œå¤§å°ä¸º0xb0çš„ä¸€æ®µåŒºåŸŸæ¬åˆ°æ“ä½œç³»ç»Ÿä¸­è™šæ‹Ÿå†…å­˜çš„0x400000ä½ç½®å¤„ï¼›å°†offsetä¸º0x1000ï¼Œå¤§å°ä¸º0x58çš„ä¸€æ®µåŒºåŸŸæ¬åˆ°æ“ä½œç³»ç»Ÿä¸­è™šæ‹Ÿå†…å­˜çš„0x401000ä½ç½®å¤„ã€‚ç„¶åå‡†å¤‡å¥½[initial process stack](#system-v-abi)é‡Œçš„argc/argv/envpç­‰ï¼Œå†è·³è½¬åˆ°Entry point 0x401000ï¼Œå³å¯å¼€å§‹æ‰§è¡Œminimalã€‚

    (é™æ€ ELF åŠ è½½å™¨: Linux æ“ä½œç³»ç»Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨ execve ç³»ç»Ÿè°ƒç”¨åŠ è½½ä¸€ä¸ªç¨‹åºï¼Œå®ç°çŠ¶æ€æœºçš„ â€œé‡ç½®â€ï¼›åŒæ—¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è‡ªå·±åŠ¨æ‰‹æ¨¡æ‹Ÿ execve ç³»ç»Ÿè°ƒç”¨çš„è¡Œä¸ºï¼šå°† ELF æ–‡ä»¶ä¸­éœ€è¦åŠ è½½çš„éƒ¨åˆ†æ˜ å°„åˆ°å†…å­˜ï¼Œå¹¶æ ¹æ® [ABI](https://jyywiki.cn/OS/manuals/sysv-abi.pdf) æ„å»ºæ­£ç¡®çš„è¿›ç¨‹åˆå§‹æ ˆå’Œå¯„å­˜å™¨ï¼Œæˆ‘ä»¬å°±èƒ½å®ç°äºŒè¿›åˆ¶æ–‡ä»¶çš„ â€œåŠ è½½â€ã€‚)

    loader.c:

    ```C
    #include <stdint.h>
    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <assert.h>
    #include <elf.h>
    #include <fcntl.h>
    #include <sys/mman.h>

    void my_execve(const char *file, char *argv[], char *envp[]);
    void *init_proc_stack(char *argv[], char *envp[]);

    int main(int argc, char *argv[], char *envp[]) {
        if (argc < 2) {
            fprintf(stderr, "Usage: %s file [args...]\n", argv[0]);
            exit(1);
        }

        my_execve(argv[1], argv + 1, envp);
    }

    void my_execve(const char *file, char *argv[], char *envp[]) {
        // WARNING: This execve leaks memory and ignores
        // error checing for brevity.

        int fd = open(file, O_RDONLY);
        assert(fd > 0);

        // Map ELF header to memory
        Elf64_Ehdr *h = mmap(NULL, 4096, PROT_READ, MAP_PRIVATE, fd, 0);

        #define ROUND(x, align) (((uintptr_t)x) & ~(align - 1))

        Elf64_Phdr *pht = (Elf64_Phdr *)((char *)h + h->e_phoff);
        for (int i = 0; i < h->e_phnum; i++) {
            Elf64_Phdr *p = &pht[i];

            if (p->p_type == PT_LOAD) {
                // Memory map region
                uintptr_t align = p->p_align;
                uintptr_t map_beg = ROUND(p->p_vaddr, align);

                // Memory map flags
                int prot = 0;
                if (p->p_flags & PF_R) prot |= PROT_READ;
                if (p->p_flags & PF_W) prot |= PROT_WRITE;
                if (p->p_flags & PF_X) prot |= PROT_EXEC;

                // Memory map size
                uintptr_t map_sz = ROUND(p->p_filesz + align - 1, align);
                uintptr_t alloc_sz = p->p_memsz - p->p_filesz;

                // Map file contents
                mmap(
                    (void *)map_beg,               // addr, rounded to ALIGN
                    map_sz,                        // length
                    prot,                          // protection
                    MAP_PRIVATE | MAP_FIXED,       // flags, private & strict
                    fd, ROUND(p->p_offset, align)  // file and offset
                );

                // Map anonymous memory (bss)
                if (alloc_sz > 0) {
                    mmap(
                        (void *)(map_beg + map_sz),// addr
                        alloc_sz,                  // length,
                        prot,                      // protection
                        MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED, // flags
                        -1, 0                      // no file and offset
                    );
                }

                // (Should check for return values.)
            }
        }
        close(fd);

        void *rsp = init_proc_stack(argv, envp);
        asm volatile(
            "mov $0, %%rdx;" // required by System-V ABI
            "mov %0, %%rsp;" // loader allocated
            "jmp *%1" : : "a"(rsp), "b"(h->e_entry)
        );
    }

    void *init_proc_stack(char *argv[], char *envp[]) {
        _Alignas(16) static char stack[1 << 20];
        static char rnd[16];

        void *sp = (void *)(stack + sizeof(stack) - 8192);
        #define push(sp, T, ...) ({ \
            *((T*)sp) = (T)__VA_ARGS__; \
            sp = (void *)((uintptr_t)(sp) + sizeof(T)); \
        })

        void *rsp = sp;

        // Calculate argc
        int argc = 0;
        while (argv[argc])
            argc++;

        // Create initial process stack
        push(sp, intptr_t, argc);

        // argv[], NULL-terminate
        for (int i = 0; i < argc; i++) {
            push(sp, intptr_t, argv[i]);
        }
        push(sp, intptr_t, 0);

        // envp[], NULL-terminate
        for (; *envp; envp++) {
            if (!strchr(*envp, '_')) {
                // remove some verbose ones
                push(sp, intptr_t, *envp);
            }
        }
        push(sp, intptr_t, 0);

        // auxv[], AT_NULL-terminate
        push(sp, Elf64_auxv_t,
            {.a_type = AT_RANDOM, .a_un.a_val = (uintptr_t)rnd}
        );
        push(sp, Elf64_auxv_t,
            {.a_type = AT_NULL}
        );

        // This stack layout is defined by System-V ABI.
        return rsp;
    }
    ```

## Lecture 20 åŠ¨æ€é“¾æ¥å’ŒåŠ è½½
!!! abstract "Take-away Messages"

    æ‰¾åˆ°æ­£ç¡®çš„æ€è·¯ï¼Œæˆ‘ä»¬å°±èƒ½åœ¨å¤æ‚çš„æœºåˆ¶ä¸­æ‰¾åˆ°ä¸»å¹²ï¼šåœ¨åŠ¨æ€é“¾æ¥çš„ä¾‹å­é‡Œï¼Œæˆ‘ä»¬è¯•ç€è‡ªå·±å®ç°åŠ¨æ€é“¾æ¥å’ŒåŠ è½½â€”â€”åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ â€œå‘æ˜â€ äº† ELF ä¸­çš„é‡è¦æ¦‚å¿µï¼Œä¾‹å¦‚ Global Offset Table, Procedure Linkage Table ç­‰ã€‚

1. â€œæ‹†è§£åº”ç”¨ç¨‹åºâ€ çš„éœ€æ±‚:

    å®ç°è¿è¡Œåº“å’Œåº”ç”¨ä»£ç åˆ†ç¦»
    
    * åº”ç”¨ä¹‹é—´çš„åº“å…±äº«
        - æ¯ä¸ªç¨‹åºéƒ½éœ€è¦ glibc
        - ä½†ç³»ç»Ÿé‡Œåªéœ€è¦ä¸€ä¸ªå‰¯æœ¬å°±å¯ä»¥äº†
            + æ˜¯çš„ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ ldd å‘½ä»¤æŸ¥çœ‹ï¼ˆprint shared object dependenciesï¼‰
    * å¤§å‹é¡¹ç›®çš„åˆ†è§£
        - æ”¹ä¸€è¡Œä»£ç ä¸ç”¨é‡æ–°é“¾æ¥ 2GB çš„æ–‡ä»¶
        - libjvm.so, libart.so, libcpu.so, ...
            + NEMU: è¿™å°±å¥½åƒ â€œæŠŠ CPU æ’ä¸Šä¸»æ¿â€ï¼Œåˆ†ç¦»libcpu.so å’Œuncoreçš„å®ç°ï¼Œéœ€è¦çš„æ—¶å€™å†é“¾æ¥èµ·æ¥
    * å¦‚æœ Linux åº”ç”¨ä¸–ç•Œæ˜¯é™æ€é“¾æ¥çš„â€¦â€¦
        - libc ç´§æ€¥å‘å¸ƒå®‰å…¨è¡¥ä¸ â†’ é‡æ–°é“¾æ¥æ‰€æœ‰åº”ç”¨ ğŸ˜‚

    a.c:

    ```C
    #include <stdio.h>

    int main()
    {
        printf("Hello!\n");
    }
    ```

    ```bash
    linux$ gcc a.c
    linux$ ls
    total 20K
    -rwxr-xr-x 1 chaofu chaofu 16K Nov  9 10:24 a.out # åŠ¨æ€é“¾æ¥çš„a.outå¤§å°ä¸º16KB
    -rw-r--r-- 1 chaofu chaofu  58 Nov  9 10:24 a.c
    linux$ file a.out
    a.out: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=521bcd29744268056ffbe7b2672bb94545d04d22, for GNU/Linux 3.2.0, not stripped
    linux$ ldd a.out
            linux-vdso.so.1 (0x00007ffeb4864000)
            libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fda081b9000)
            /lib64/ld-linux-x86-64.so.2 (0x00007fda083f5000)
    ```

    å¦‚ä½•å®ç°åˆ†ç¦»ï¼Ÿ

    æ–¹æ¡ˆ 1: libc.o âŒ

    * åœ¨åŠ è½½æ—¶å®Œæˆé‡å®šä½
        - åŠ è½½ = é™æ€é“¾æ¥
        - çœäº†ç£ç›˜ç©ºé—´ï¼Œä½†æ²¡çœå†…å­˜
        - è‡´å‘½ç¼ºç‚¹ï¼šæ—¶é—´ (é“¾æ¥éœ€è¦è§£æå¾ˆå¤šä¸ä¼šç”¨åˆ°çš„ç¬¦å·)
    * æ–¹æ¡ˆ 2: libc.so (shared object) âœ…
        - ç¼–è¯‘å™¨ç”Ÿæˆä½ç½®æ— å…³ä»£ç  (ç¨‹åºå¯ä»¥åœ¨åŠ è½½è¿è¡Œæ—¶åŠ¨æ€åœ°æ‰¾åˆ°å¹¶è°ƒç”¨æ‰€éœ€çš„å‡½æ•°ï¼Œè€Œä¸éœ€è¦åœ¨ç¼–è¯‘æ—¶å°±çŸ¥é“è¿™äº›å‡½æ•°çš„ç¡®åˆ‡åœ°å€ã€‚)
            + åŠ è½½ = mmap
            + ä½†å‡½æ•°è°ƒç”¨æ—¶éœ€è¦é¢å¤–ä¸€æ¬¡æŸ¥è¡¨
        - å¥½å¤„ï¼šå¤šä¸ªè¿›ç¨‹æ˜ å°„åŒä¸€ä¸ª libc.soï¼Œå†…å­˜ä¸­åªéœ€è¦ä¸€ä¸ªå‰¯æœ¬

    å…±äº«åº“æµ‹è¯•ï¼šå¯åŠ¨ 100 ä¸ªä»£ç ä¸º 100M çš„å‡½æ•°ï¼Œé€šè¿‡è§‚å¯Ÿç³»ç»Ÿä¸­çš„å†…å­˜å ç”¨æ¥æµ‹è¯•å¤šä¸ªç‹¬ç«‹å¯åŠ¨çš„è¿›ç¨‹æ˜¯å¦åªä¿ç•™ä¸€ä»½å…±äº«åº“çš„ä»£ç å‰¯æœ¬ã€‚

    bloat.c

    ```C
    void bloat() {
        // 100M of nops
        asm volatile(
            ".fill 104857600, 1, 0x90"
        );
    }
    ```

    main.c

    ```C
    #include <stdio.h>
    #include <unistd.h>

    // Dynamically linked.
    void bloat();

    int main() {
        bloat();
        printf("bloat() called; sleeping...\n");
        while (1) {
            sleep(1);
        }
    }
    ```

    ```bash
    linux$ make
    gcc -shared -o libbloat.so bloat.c
    cc    -c -o main.o main.c
    gcc -o bloat main.o -L. -lbloat
    linux$ LD_LIBRARY_PATH=. ./bloat
    bloat() called; sleeping...
    linux$ ./run
    linux$ ps -ax
    PID TTY      STAT   TIME COMMAND
        1 hvc0     Sl+    0:00 /init
        5 hvc0     Sl+    0:00 plan9
        8 ?        Ss     0:00 /init
        9 ?        S      0:00 /init
    ...
    30797 pts/6    S      0:00 ./bloat
    30798 pts/6    S      0:00 ./bloat
    30799 pts/6    S      0:00 ./bloat
    30800 pts/6    S      0:00 ./bloat
    ...
    linux$ pmap 30797 | grep libbloat.so
    00007f4af8c33000      4K r---- libbloat.so
    00007f4af8c34000 102404K r-x-- libbloat.so
    00007f4aff035000      4K r---- libbloat.so
    00007f4aff036000      4K r---- libbloat.so
    00007f4aff037000      4K rw--- libbloat.so
    linux$ pmap 30798 | grep libbloat.so
    00007f83552c4000      4K r---- libbloat.so
    00007f83552c5000 102404K r-x-- libbloat.so
    00007f835b6c6000      4K r---- libbloat.so
    00007f835b6c7000      4K r---- libbloat.so
    00007f835b6c8000      4K rw--- libbloat.so
    ```

    è¿›ç¨‹ 30797 çœ‹åˆ°æœ‰è¿ç»­ 100MB çš„ libbloat.so åœ¨åœ°å€ 00007f4af8c34000 å¤„ï¼Œå®é™…ä¸Šè¿™æ˜¯æ“ä½œç³»ç»Ÿå¡‘é€ çš„å‡è±¡ï¼Œåœ¨çœŸå®çš„å†…å­˜æ¡é‡Œå®ƒå¯èƒ½æ˜¯è¿™æ ·åˆ†å¸ƒçš„ï¼š(ä¸åŒéƒ¨åˆ†åˆ†å¸ƒåœ¨ä¸åŒçš„å†…å­˜é¡µä¸Š)

    ![alt text](../img/image-17.png)

    åœ¨ x86 æ¶æ„ä¸­ï¼ŒCPU é‡Œæœ‰ä¸€ä¸ªç‰¹æ®Šå¯„å­˜å™¨ CR3ï¼Œç”¨äºå­˜å‚¨å½“å‰è¿è¡Œè¿›ç¨‹çš„é¡µç›®å½•åŸºåœ°å€ï¼ˆPage Directory Base Addressï¼‰ã€‚é¡µç›®å½•æ˜¯å†…å­˜ç®¡ç†ä¸­çš„ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œç”¨äºå°†è™šæ‹Ÿåœ°å€è½¬æ¢ä¸ºç‰©ç†åœ°å€ã€‚å½“ CPU è¦è®¿é—® libbloat.so çš„æ—¶å€™ï¼Œé€šè¿‡ CR3 å¯„å­˜å™¨æ­£ç¡®æ‰¾åˆ°ç‰©ç†å†…å­˜æ¡ä¸Šçš„ libbloat.soï¼Œå¡‘é€ å‡º libbloat.so æ˜¯è¿ç»­çš„ 100MB çš„å‡è±¡ã€‚

2. å®ç°åŠ¨æ€åŠ è½½ï¼šA Layer of Indirection

    ç¼–è¯‘æ—¶ï¼ŒåŠ¨æ€é“¾æ¥åº“è°ƒç”¨ = æŸ¥è¡¨

    ```C
    call  *TABLE[printf@symtab]
    ```

    é“¾æ¥æ—¶ï¼Œæ”¶é›†æ‰€æœ‰ç¬¦å·ï¼Œâ€œç”Ÿæˆâ€ ç¬¦å·ä¿¡æ¯å’Œç›¸å…³ä»£ç ï¼š

    ```C
    #define foo@symtab     1
    #define printf@symtab  2
    ...

    void *TABLE[N_SYMBOLS];

    void load(struct loader *ld) {
        TABLE[foo@symtab] = ld->resolve("foo");
        TABLE[foo@printf] = ld->resolve("printf");
        ...
    }
    ```

    ä¾‹å­ï¼š

    main.S:

    ```asm
    #include "dl.h"

    DL_HEAD

    LOAD("libc.dl")
    LOAD("libhello.dl")
    IMPORT(hello)
    IMPORT(exit)
    EXPORT(_start)

    DL_CODE

    main:
        call DSYM(hello)
        call DSYM(hello)
        call DSYM(hello)
        call DSYM(hello)
        movq $0, %rax
        ret

    _start:
        call main
        jmp DSYM(exit)

    DL_END
    ```

    libhello.S:

    ```asm
    #include "dl.h"

    DL_HEAD

    LOAD("libc.dl")
    IMPORT(putchar)
    EXPORT(hello)

    DL_CODE

    hello:
        lea str(%rip), %rdi
        mov count(%rip), %eax
        push %rbx
        mov %rdi, %rbx
        inc %eax
        mov %eax, count(%rip)
        add $0x30, %eax
        movb %al, 0x6(%rdi)
    loop:
        movsbl (%rbx),%edi
        test %dil,%dil
        je out
        call DSYM(putchar)
        inc  %rbx
        jmp loop
    out:
        pop %rbx
        ret

    str:
        .asciz "Hello X\n"

    count:
        .int 0

    DL_END
    ```

    libc.S:

    ```asm
    #include "dl.h"
    #include <sys/syscall.h>

    DL_HEAD

    EXPORT(putchar)
    EXPORT(exit)

    DL_CODE

    putchar:
        mov %dil, buf(%rip)
        mov $SYS_write, %rax
        mov $1, %rdi
        lea buf(%rip), %rsi
        mov $1, %rdx
        syscall
        ret
    buf:
        .byte 0

    exit:
        movq $SYS_exit, %rax
        syscall

    DL_END
    ```

    ```bash
    linux$ make
    gcc  dlbox.c -o dlbox
    ./dlbox gcc libhello.S
    ./dlbox gcc libc.S
    ./dlbox gcc main.S
    ./dlbox objdump libhello.dl > libhello.txt
    ./dlbox objdump libc.dl > libc.txt
    ./dlbox objdump main.dl > main.txt
    rm -f *.o
    linux$ ./dlbox interp main.dl
    Hello 1
    Hello 2
    Hello 3
    Hello 4
    ```

    dl.h

    ```C
    #define REC_SZ 32
    #define DL_MAGIC "\x01\x14\x05\x14"

    #ifdef __ASSEMBLER__
        #define DL_HEAD     __hdr: \
                            /* magic */    .ascii DL_MAGIC; \
                            /* file_sz */  .4byte (__end - __hdr); \
                            /* code_off */ .4byte (__code - __hdr)
        #define DL_CODE     .fill REC_SZ - 1, 1, 0; \
                            .align REC_SZ, 0; \
                            __code:
        #define DL_END      __end:

        #define RECORD(sym, off, name) \
        .align REC_SZ, 0; \
        sym .8byte (off); .ascii name

        #define IMPORT(sym) RECORD(sym:,           0, "?" #sym "\0")
        #define EXPORT(sym) RECORD(    , sym - __hdr, "#" #sym "\0")
        #define LOAD(lib)   RECORD(    ,           0, "+" lib  "\0")
        #define DSYM(sym)   *sym(%rip)
    #else
        #include <stdint.h>

        struct dl_hdr {
            char magic[4];
            uint32_t file_sz, code_off;
        };

        struct symbol {
            int64_t offset;
            char type, name[REC_SZ - sizeof(int64_t) - 1];
        };
    #endif
    ```

    ```bash
    linux$ gcc -E main.S  # æˆ‘ä»¬å¯ä»¥é€šè¿‡ -E é€‰é¡¹æ¥æŸ¥çœ‹é¢„å¤„ç†åçš„ç»“æœ
    # 0 "main.S"
    # 0 "<built-in>"
    # 0 "<command-line>"
    # 1 "/usr/include/stdc-predef.h" 1 3 4
    # 0 "<command-line>" 2
    # 1 "main.S"
    # 1 "dl.h" 1
    # 2 "main.S" 2

    __hdr: .ascii "\x01\x14\x05\x14"; .4byte (__end - __hdr); .4byte (__code - __hdr)

    .align 32, 0; .8byte (0); .ascii "+" "libc.dl" "\0"
    .align 32, 0; .8byte (0); .ascii "+" "libhello.dl" "\0"
    .align 32, 0; hello: .8byte (0); .ascii "?" "hello" "\0"
    .align 32, 0; exit: .8byte (0); .ascii "?" "exit" "\0"
    .align 32, 0; .8byte (_start - __hdr); .ascii "#" "_start" "\0"

    .fill 32 - 1, 1, 0; .align 32, 0; __code:

    main:
        call *hello(%rip)
        call *hello(%rip)
        call *hello(%rip)
        call *hello(%rip)
        movq $0, %rax
        ret

    _start:
        call main
        jmp *exit(%rip)

    __end:
    ```

    ![alt text](../img/image-18.png){ width="480" }

    æˆ‘ä»¬ â€œå‘æ˜â€ äº† GOT (Global Offset Table)ï¼

    * å¯¹äºæ¯ä¸ªéœ€è¦åŠ¨æ€è§£æçš„ç¬¦å·ï¼ŒGOT ä¸­éƒ½æœ‰ä¸€ä¸ªä½ç½®
    * ELF: Relocation section â€œ.rela.dynâ€

    ```C
    #include <stdio.h>

    int main()
    {
        exit(0);
    }
    ```

    ```bash
    linux$ file a.out
    a.out: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=4f42832abaead61246b7dd248749f056c3e2c373, for GNU/Linux 3.2.0, not stripped
    linux$ readelf -a a.out
    Relocation section '.rela.plt' at offset 0x610 contains 1 entry:
    Offset          Info           Type           Sym. Value      Sym. Name + Addend
    000000003fd0  000400000007 R_X86_64_JUMP_SLO 0000000000000000 exit@GLIBC_2.2.5 + 0
    linux$ pmap 15539
    15539:   /home/chaofu/jyy_os_2024/lecture/lect20/my/a.out
    0000555555554000      4K r---- a.out
    0000555555555000      4K r-x-- a.out
    ...
    total             2644K
    linux$ python
    Python 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] on linux
    Type "help", "copyright", "credits" or "license" for more information.
    >>> hex(0x000000003fd0 + 0x0000555555554000)
    '0x555555557fd0'
    >>> 
    ```

    è¿™æ„å‘³ç€ 0x3fd0 + ELF headeråœ°å€å°±æ˜¯è¿™ä¸ª GOT è¡¨é¡¹çš„åœ°å€ï¼Œè¿™ä¸ªè¡¨é¡¹é‡Œå­˜æ”¾çš„æ˜¯ exit çœŸæ­£çš„åœ°å€ã€‚åœ¨ gdb è°ƒè¯•çš„æ—¶å€™æˆ‘ä»¬å¯ä»¥çœ‹åˆ° a.out åœ¨è¿è¡Œæ—¶çš„åœ°å€ç©ºé—´ä» 0x0000555555554000 å¼€å§‹ï¼Œæˆ‘ä»¬è®¡ç®—å¾—çŸ¥ 0x555555557fd0 æ˜¯ exit çš„åœ°å€ï¼Œå¯ä»¥åœ¨è¿™ä¸ªåœ°å€ä¸Šæ‰“`rwatch *0x555555557fd0`çœ‹åˆ°ï¼Œç¡®å®æœ‰äººè¯»äº†è¿™ä¸ªåœ°æ–¹çš„ä»£ç ï¼Œä¸”è¿™ä¸ªåœ°æ–¹çš„ç¡®æ˜¯ exit çš„ä»£ç ã€‚

    ```C
    #include <stdio.h>

    int main() {
        printf("printf: %p\n", main);
        printf("main: %p\n", printf);
    }
    ```

    ```bash
    linux$ readelf -a a.out
    Relocation section '.rela.dyn' at offset 0x550 contains 9 entries:
    Offset          Info           Type           Sym. Value    Sym. Name + Addend
    000000003fe0  000500000006 R_X86_64_GLOB_DAT 0000000000000000 printf@GLIBC_2.2.5 + 0
    ```

3. åŠ¨æ€é“¾æ¥çš„ä¸»è¦åŠŸèƒ½ï¼šå®ç°ä»£ç çš„åŠ¨æ€é“¾æ¥å’ŒåŠ è½½

    * main (.o) è°ƒç”¨ printf (.so)
    * main (.o) è°ƒç”¨ foo (.o)

    éš¾é¢˜ï¼šæ€ä¹ˆå†³å®šåˆ°åº•è¦ä¸è¦æŸ¥è¡¨ï¼Ÿè°ƒç”¨è‡ªå·±å†™çš„ foo å’Œè°ƒç”¨åº“å‡½æ•°é‡Œçš„ printf ä¸€æ ·éƒ½è¦æŸ¥è¡¨å—ï¼Ÿ

    è¿™æ˜¯ä¸ªå†å²é—ç•™é—®é¢˜ï¼šå…ˆç¼–è¯‘ã€åé“¾æ¥

    ç¼–è¯‘å™¨çš„é€‰æ‹© 1: å…¨éƒ¨æŸ¥è¡¨è·³è½¬ (è°ƒç”¨ä¸ª foo éƒ½å¤šæŸ¥ä¸€æ¬¡è¡¨ï¼Œæ€§èƒ½ä¸èƒ½å¿âŒ)
    
    ```C
    ff 25 00 00 00 00   call *FOO_OFFSET(%rip)
    ```

    ç¼–è¯‘å™¨çš„é€‰æ‹© 2: å…¨éƒ¨ç›´æ¥è·³è½¬ (è·³ä¸è¿‡å»âŒ)

    ```C
    e8 00 00 00 00      call <reloc>
    ```

    * %rip: 00005559892b7000
    * libc.so.6: 00007fdcdf800000
        - ç›¸å·®äº† 2a8356549000
        - 4-byte ç«‹å³æ•°æ”¾ä¸ä¸‹ï¼Œæ— è®ºå¦‚ä½•ä¹Ÿè·³ä¸è¿‡å»

    ç¼–è¯‘å™¨çš„é€‰æ‹© 3: PLT (Procedure Linkage Table) âœ…

    * ä¸ºäº†æ€§èƒ½ï¼Œâ€œå…¨éƒ¨ç›´æ¥è·³è½¬â€ æ˜¯å”¯ä¸€é€‰æ‹©
    * å¦‚æœè¿™ä¸ªç¬¦å·åœ¨é“¾æ¥æ—¶å‘ç°æ˜¯ printf (æ¥è‡ªåŠ¨æ€åŠ è½½)ï¼Œå°±åœ¨ a.out é‡Œ â€œåˆæˆâ€ ä¸€æ®µå°ä»£ç ï¼š
        - i.e. åº“å‡½æ•°çš„æ‰éœ€è¦ pltï¼Œéœ€è¦æŸ¥è¡¨ GOTã€‚ï¼ˆå…ˆè·³ä¸€å°æ­¥åˆ° pltï¼Œå†é€šè¿‡ plt æŸ¥åˆ°çš„ GOT è¡¨é¡¹è·³ä¸€å¤§æ­¥ï¼‰è‡ªå·±å†™çš„ foo.c ä¸éœ€è¦ï¼Œç›´æ¥è·³è½¬

    ```C
    printf@plt:
        jmp *PRINTF_OFFSET(%rip)
    ```

3. ä¸Šé¢åªæ˜¯è§£å†³äº†ä»£ç çš„åŠ¨æ€åŠ è½½åŠ è½½å’Œé“¾æ¥ï¼Œå¦‚ä½•å®ç°æ•°æ®çš„åŠ¨æ€åŠ è½½å’Œé“¾æ¥ï¼Ÿ

    * main (.o) è®¿é—® stderr (libc.so)
    * libjvm (.so) è®¿é—® stderr (libc.so)
    * libjvm (.so) è®¿é—® heap (libjvm.so)
        - ç¼–è¯‘æ—¶åŒæ ·ä¸çŸ¥é“æ•°æ®åœ¨å“ªé‡Œ

    å¯¹äºæ•°æ®ï¼Œæˆ‘ä»¬ä¸èƒ½ â€œé—´æ¥è·³è½¬â€ï¼

    * x = 1, åŒä¸€ä¸ª .so (æˆ– executable)

    ```asm
    mov $1, offset_of_x(%rip) # ç›´æ¥çŸ¥é“åœ°å€
    ```

    * x = 1, å¦ä¸€ä¸ª .so

    ```asm
    mov GOT[x], %rdi          # éœ€è¦æŸ¥ GOT è¡¨æ‰çŸ¥é“åœ°å€
    mov $1, (%rdi)
    ```

    `__attribute__((visibility("hidden")))` æ„æ€æ˜¯æ˜ç¡®çŸ¥é“è¿™ä¸ªå˜é‡å±äºæœ¬ soï¼Œä¸æ˜¯å¤–éƒ¨åº“é‡Œçš„ã€‚

    main.c

    ```C
    #include <stdio.h>

    void A();
    void B();

    extern int x;

    int main() {
        A();

        printf("main: &stderr = %p\n", &stderr);
        printf("main: &x      = %p\n", &x);

        B();
    }
    ```

    liba-1.c

    ```C
    int x = 1;
    ```

    liba-2.c

    ```C
    #include <stdio.h>

    extern int x;

    void A() {
        printf("liba: x = %d\n", x++);
    }
    ```

    libb-1.c

    ```C
    #include <stdio.h>

    // This x is from liba.
    extern int x;

    // This y is from libb.
    extern int __attribute__((visibility("hidden"))) y;

    void *get_x_addr() {
        return &x;
    }

    void *get_y_addr() {
        return &y;
    }

    void set_x() {
        x = 1;
    }

    void set_y() {
        y = 1;
    }

    void *get_stderr() {
        return &stderr;
    }

    void B() {
        printf("B   : &stderr = %p\n", &stderr);
        printf("B   : &x      = %p\n", &x);
    }
    ```

    libb-2.c

    ```C
    int y = 0;
    ```

    ```bash
    linux$ make
    gcc -Wall -fPIC -Os -c main.c -o main.o
    gcc -Wall -fPIC -Os -c liba-1.c -o liba-1.o
    gcc -Wall -fPIC -Os -c liba-2.c -o liba-2.o
    gcc -shared -o liba.so liba-1.o liba-2.o
    gcc -Wall -fPIC -Os -c libb-1.c -o libb-1.o
    gcc -Wall -fPIC -Os -c libb-2.c -o libb-2.o
    gcc -shared -o libb.so libb-1.o libb-2.o -L. -la
    gcc -o main main.o -L. -la -lb
    linux$ LD_LIBRARY_PATH=. ./main 
    liba: x = 1
    main: &stderr = 0x7f5b3bad6860
    main: &x      = 0x7f5b3bafa028
    B   : &stderr = 0x7f5b3bad6860
    B   : &x      = 0x7f5b3bafa028
    ```

    ```bash
    linux$ objdump -d libb.so
    0000000000001119 <get_x_addr>:
        1119:       f3 0f 1e fa             endbr64 
        111d:       48 8b 05 b4 2e 00 00    mov    0x2eb4(%rip),%rax        # 3fd8 <x@Base>
        1124:       c3                      ret    

    0000000000001125 <get_y_addr>:
        1125:       f3 0f 1e fa             endbr64 
        1129:       48 8d 05 fc 2e 00 00    lea    0x2efc(%rip),%rax        # 402c <y>
        1130:       c3                      ret    
    linux$ readelf -a libb.so # çœ‹çœ‹ x åœ¨å“ªé‡Œï¼Œæ˜¯åœ¨ GOT è¡¨é¡¹
    Relocation section '.rela.dyn' at offset 0x588 contains 9 entries:
    Offset          Info           Type           Sym. Value    Sym. Name + Addend
    ...
    000000003fd8  000200000006 R_X86_64_GLOB_DAT 0000000000000000 x + 0
    ```

    å¯ä»¥çœ‹åˆ°ç”±äº x æ˜¯å¦å¤–ä¸€ä¸ªåº“ liba.so é‡Œçš„ï¼Œæ‰€ä»¥éœ€è¦ mov æŒ‡ä»¤å¦å¤–æŸ¥è¡¨ï¼Œè€Œ y æ˜¯æœ¬åº“ libb.so é‡Œçš„ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥ç”¨ lea æŒ‡ä»¤å» load åœ°å€ã€‚

4. å¯¹äºä¸€ä¸ªåŠ¨æ€é“¾æ¥çš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œexecveåçš„ç¬¬ä¸€æ¡æŒ‡ä»¤åœ¨å“ªé‡Œï¼Ÿ

    åœ¨ç°ä»£æ“ä½œç³»ç»Ÿä¸­ï¼Œå½“ä¸€ä¸ªåŠ¨æ€é“¾æ¥çš„äºŒè¿›åˆ¶æ–‡ä»¶é€šè¿‡execveç³»ç»Ÿè°ƒç”¨è¢«åŠ è½½å’Œæ‰§è¡Œæ—¶ï¼Œç¬¬ä¸€æ¡æŒ‡ä»¤çš„æ‰§è¡Œä½ç½®é€šå¸¸ä¸æ˜¯ç›´æ¥åœ¨åº”ç”¨ç¨‹åºçš„ä»£ç ä¸­ï¼Œè€Œæ˜¯åœ¨åŠ¨æ€é“¾æ¥å™¨ï¼ˆä¹Ÿç§°ä¸ºåŠ¨æ€åŠ è½½å™¨ï¼‰ä¸­ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€è¦çš„è¿‡ç¨‹æè¿°ï¼š

    1. **åŠ è½½äºŒè¿›åˆ¶æ–‡ä»¶**ï¼šæ“ä½œç³»ç»Ÿå†…æ ¸ä¼šåŠ è½½äºŒè¿›åˆ¶æ–‡ä»¶çš„å¤´éƒ¨ä¿¡æ¯ï¼ˆä¾‹å¦‚ELFå¤´éƒ¨ï¼‰ä»¥ç¡®å®šæ–‡ä»¶ç±»å‹å’Œæ‰€éœ€çš„åŠ¨æ€é“¾æ¥å™¨ã€‚

    2. **åŠ è½½åŠ¨æ€é“¾æ¥å™¨**ï¼šæ ¹æ®äºŒè¿›åˆ¶æ–‡ä»¶çš„å¤´éƒ¨ä¿¡æ¯ï¼Œå†…æ ¸ä¼šåŠ è½½æŒ‡å®šçš„åŠ¨æ€é“¾æ¥å™¨ (ä¾‹å¦‚ï¼Œåœ¨Linuxç³»ç»Ÿä¸Šï¼Œé€šå¸¸æ˜¯/lib/ld-linux.soæˆ–ç±»ä¼¼è·¯å¾„çš„æ–‡ä»¶)ã€‚

    3. **è·³è½¬åˆ°åŠ¨æ€é“¾æ¥å™¨**ï¼šå†…æ ¸å°†æ§åˆ¶æƒäº¤ç»™åŠ¨æ€é“¾æ¥å™¨ã€‚æ­¤æ—¶ï¼ŒåŠ¨æ€é“¾æ¥å™¨æˆä¸ºç¬¬ä¸€ä¸ªæ‰§è¡Œçš„ä»£ç ã€‚

    4. **åŠ¨æ€é“¾æ¥å’ŒåŠ è½½**ï¼šåŠ¨æ€é“¾æ¥å™¨è´Ÿè´£è§£æå’ŒåŠ è½½æ‰€æœ‰éœ€è¦çš„å…±äº«åº“ï¼Œè¿›è¡Œç¬¦å·è§£æå’Œé‡å®šä½ç­‰å·¥ä½œã€‚

    5. **è·³è½¬åˆ°ç¨‹åºå…¥å£ç‚¹**ï¼šä¸€æ—¦æ‰€æœ‰çš„åŠ¨æ€é“¾æ¥å’ŒåŠ è½½å·¥ä½œå®Œæˆï¼ŒåŠ¨æ€é“¾æ¥å™¨ä¼šè·³è½¬åˆ°åº”ç”¨ç¨‹åºçš„å…¥å£ç‚¹ï¼ˆé€šå¸¸æ˜¯_startå‡½æ•°ï¼‰ï¼Œä»è€Œå¼€å§‹æ‰§è¡Œåº”ç”¨ç¨‹åºçš„ä»£ç ã€‚

    å› æ­¤ï¼Œexecveåçš„ç¬¬ä¸€æ¡æŒ‡ä»¤é€šå¸¸æ˜¯åœ¨åŠ¨æ€é“¾æ¥å™¨ä¸­ï¼Œè€Œä¸æ˜¯ç›´æ¥åœ¨åº”ç”¨ç¨‹åºçš„ä»£ç ä¸­ã€‚åŠ¨æ€é“¾æ¥å™¨å®Œæˆå…¶å·¥ä½œåï¼Œæ‰ä¼šå°†æ§åˆ¶æƒäº¤ç»™åº”ç”¨ç¨‹åºçš„å…¥å£ç‚¹ã€‚

    è¿™ä¸ªè¿‡ç¨‹ç¡®ä¿äº†æ‰€æœ‰åŠ¨æ€åº“å’Œä¾èµ–é¡¹åœ¨åº”ç”¨ç¨‹åºå¼€å§‹æ‰§è¡Œä¹‹å‰éƒ½å·²ç»æ­£ç¡®åŠ è½½å’Œé“¾æ¥ã€‚

5. å¦‚ä½•ç¼–è¯‘å‡ºä¸€ä¸ªä¸ä½¿ç”¨é»˜è®¤ld.soä½œä¸ºinterpreterçš„ELFåŠ¨æ€é“¾æ¥å¯æ‰§è¡Œæ–‡ä»¶?

    è¦ç¼–è¯‘ä¸€ä¸ªä¸ä½¿ç”¨é»˜è®¤ld.soä½œä¸ºè§£é‡Šå™¨(interpreter)çš„ ELFåŠ¨æ€é“¾æ¥å¯æ‰§è¡Œæ–‡ä»¶ï¼Œä½ å¯ä»¥ä½¿ç”¨`gcc`æˆ–`ld`å¹¶æŒ‡å®šè‡ªå®šä¹‰çš„è§£é‡Šå™¨è·¯å¾„ã€‚ä»¥ä¸‹æ˜¯å…·ä½“æ­¥éª¤ï¼š

    1. **ç¼–å†™ä¸€ä¸ªç®€å•çš„Cç¨‹åº** (ä¾‹å¦‚hello.c)

    ```C
    #include <stdio.h> 
    
    int main()
    {
        printf("Hello, World!\n"); 
        return 0;
    }
    ```

    2. **ç¼–è¯‘å¹¶é“¾æ¥ç¨‹åº**ï¼ŒæŒ‡å®šè‡ªå®šä¹‰çš„è§£é‡Šå™¨è·¯å¾„ã€‚ä½ å¯ä»¥ä½¿ç”¨`-Wl,--dynamic-linker`é€‰é¡¹æ¥æŒ‡å®šè§£é‡Šå™¨è·¯å¾„ã€‚ä¾‹å¦‚ï¼Œå‡è®¾ä½ æƒ³ä½¿ç”¨/path/to/custom/ld.soä½œä¸ºè§£é‡Šå™¨ï¼š

    ```sh
    gcc -o hello hello.c -Wl,--dynamic-linker /path/to/custom/ld.so
    ```

    3. **éªŒè¯ELFæ–‡ä»¶çš„è§£é‡Šå™¨**ã€‚ä½ å¯ä»¥ä½¿ç”¨`readelf`å·¥å…·æ¥æ£€æŸ¥ç”Ÿæˆçš„LFæ–‡ä»¶çš„è§£é‡Šå™¨è·¯å¾„ï¼š

    ```sh
    readelf -a hello | grep "program interpreter" 
    ```
    
    è¾“å‡ºåº”è¯¥ç±»ä¼¼äºï¼š

    ```sh
    [Requesting program interpreter: /path/to/custom/ld.so] 
    ```

6. LD_PRELOAD: åœ¨åŠ è½½ä¹‹å‰ preload
    
    * å¦‚æœèƒ½é“¾æ¥æˆ‘ä»¬ â€œä¿®æ”¹â€ è¿‡çš„ libc å°±å¥½äº† â†’ ç”šè‡³æˆ‘ä»¬éƒ½ä¸éœ€è¦ä¿®æ”¹ libc
    * åŠ¨æ€åŠ è½½çš„å…¨å±€ç¬¦å·ï¼šå…ˆåˆ°å…ˆå¾—ï¼Œæ‰€ä»¥ç”¨ LD_PRELOAD å…ˆå æ®ä½ æƒ³è¦å æ®çš„ä¸œè¥¿å³å¯

## Lecture 21 ç³»ç»Ÿè°ƒç”¨ã€ä¸­æ–­å’Œä¸Šä¸‹æ–‡åˆ‡æ¢
!!! abstract "Take-away Messages"

    ç³»ç»Ÿè°ƒç”¨æŒ‡ä»¤æ˜¯ä¸€ç§ç‰¹æ®Šçš„ â€œé•¿è·³è½¬â€â€”â€”è€Œè·³è½¬çš„ç›®æ ‡æ˜¯ç”±æ“ä½œç³»ç»Ÿé…ç½®å¥½ã€åº”ç”¨ç¨‹åºä¸èƒ½å†³å®šçš„ã€‚ç±»ä¼¼åœ°ï¼Œå¤„ç†å™¨ä¸­æ–­ä¹Ÿä¼šè¢«åŠ¨è°ƒç”¨é•¿è·³è½¬åˆ°æ“ä½œç³»ç»Ÿå†…æ ¸ã€‚æ“ä½œç³»ç»Ÿå†…æ ¸ä»£ç ä¼š â€œå°å­˜â€ è¿›ç¨‹çš„çŠ¶æ€æœºï¼š

    1. å¯¹äºå†…å­˜ä¸­çš„é¡µé¢ï¼Œä¿æŒåŸå°ä¸åŠ¨ï¼›
    2. ä½¿ç”¨ç²¾å¿ƒæ„é€ çš„ä»£ç ï¼Œå°å¿ƒåœ°å°†æ‰€æœ‰å¯„å­˜å™¨ä¿å­˜åˆ°å†…å­˜ä¸­ã€‚

    æ­¤æ—¶ï¼Œè®¡ç®—æœºç³»ç»Ÿå°±å¤„äºæ‰€æœ‰ç¨‹åºéƒ½è¢«å°å­˜ã€æ“ä½œç³»ç»Ÿä»£ç æ­£åœ¨æ‰§è¡Œçš„çŠ¶æ€ã€‚æ“ä½œç³»ç»Ÿä¼šé€‰æ‹©æ€§åœ°è°ƒåº¦ä¸‹ä¸€ä¸ªå¯„å­˜å™¨ç°åœºåˆ° CPU ä¸Šï¼Œå®ç°ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚

1. ç³»ç»Ÿè°ƒç”¨ï¼šå‘æ“ä½œç³»ç»Ÿçš„ â€œå‡½æ•°è°ƒç”¨â€

    [syscall](https://www.felixcloutier.com/x86/syscall): â€œè·³è½¬å¹¶è·å¾—æ— é™çš„æƒåŠ›â€

    ```asm
    call  printf@plt        // PLT; dynamic linked
    call  pmm_alloc         // locally linked

    // syscallçš„è¡Œä¸ºå¦‚ä¸‹ï¼š
    syscall = â€œjalâ€:        // jump and link, syscallçš„é€†æ“ä½œæ˜¯sysret
        mov %rip, %rcx      // æŠŠä¸‹ä¸€æ¡è¦æ‰§è¡Œçš„æŒ‡ä»¤ç»™rcx
        mov %rflags, %r11   // æŠŠrflagsç»™r11ï¼Œä¿å­˜å¥½ç°åœº
        set CS = kernel, SS = kernel, CPL = 0 // è¿›å…¥é«˜æƒé™çš„å†…æ ¸
        jmp IA32_LSTAR      // è·³è½¬åˆ° Long System Target Address Register
    ```

    * æ­¤æ—¶ RIP = IA32_LSTAR, CPL = 0
    * æ“ä½œç³»ç»Ÿå¯ä»¥é…ç½® IA32_LSTAR
        - setjmp() â†’ åœ¨å¦ä¸€ä¸ªæ ˆä¸­æ‰§è¡Œ â†’ longjmp() â†’ sysret
        - æ‰§è¡Œæ—¶å¯ä»¥ç›´æ¥è®¿é—® I/O è®¾å¤‡å’Œå†…æ ¸æ•°æ®ç»“æ„
        - æ“ä½œç³»ç»Ÿ = C ç¨‹åº
    * è¿›ç¨‹çš„å†…å­˜è¢« â€œæ‹†æ•£â€ï¼Œå¹¶ä¸”è¢« Page Table é‡ç»„äº†
        - ä» M[LSTAR] çš„è™šæ‹Ÿåœ°å€å¤„å–æŒ‡ä»¤
        - [Complete kernel virtual memory map](https://www.kernel.org/doc/html/v6.3/x86/x86_64/mm.html)

    æˆ‘ä»¬æ€ä¹ˆåœ¨ä¸€ä¸ª syscall æŒ‡ä»¤ä¸Šæ‰“æ–­ç‚¹ï¼Ÿâ¡ï¸ å€ŸåŠ© minimal.S é™æ€é“¾æ¥çš„ç³»ç»Ÿè°ƒç”¨å’Œ QEMU çš„æ–­ç‚¹æœºåˆ¶ï¼Œæˆ‘ä»¬å°±èƒ½ â€œæŠ“ä½â€ ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œå¹¶ä¸”æŸ¥çœ‹å‰åå¯„å­˜å™¨æ•°å€¼çš„å˜åŒ–ã€‚init.py ä¸­çš„ä»£ç å¯¹å¤§å®¶ç†è§£ç³»ç»Ÿè½¯ä»¶ (å°¤å…¶æ˜¯å’Œå¯„å­˜å™¨ä¿å­˜/æ¢å¤ç›¸å…³çš„æ±‡ç¼–ä»£ç ) çš„æŒ‡ä»¤çº§è¡Œä¸ºï¼Œæ˜¯éå¸¸æœ‰ç”¨çš„

    ```bash
    0xffffffff8dc00040 in ?? ()
    rcx 0x0 -> 0x40101e
    r11 0x0 -> 0x202 
    rip 0x40101c -> 0xffffffff8dc00040 
    eflags [ IOPL=0 IF ] -> [ IOPL=0 ]
    cs 0x33 -> 0x10
    ss 0x2b -> 0x18 
    (gdb)
    ```

    init.py

    ```python
    import gdb
    import re

    R = {}

    def stop_handler(event):
        if isinstance(event, gdb.StopEvent):
            regs = [
                line for line in 
                    gdb.execute('info registers',
                                to_string=True).
                                strip().split('\n')
                        if not line.startswith('xmm')
            ]
            for line in regs:
                parts = line.split()
                key = parts[0]

                if m := re.search(r'(\[.*?\])', line):
                    val = m.group(1)
                else:
                    val = parts[1]

                if key in R and R[key] != val:
                    print(key, R[key], '->', val)
                R[key] = val

    gdb.events.stop.connect(stop_handler)

    gdb.execute('target remote localhost:1234')
    gdb.execute('hb *0x401000')
    gdb.execute('continue')
    ```

2. ä¸­æ–­ = ä¸€æ ¹çº¿ã€‚â€œå‘Šè¯‰å¤„ç†å™¨ï¼šåœåœï¼Œæœ‰äº‹æ¥äº†â€ï¼Œå‰©ä¸‹å…¨æ˜¯å¤„ç†å™¨çš„äº‹ã€‚å¦ä¸€ç§ç†è§£ä¸­æ–­çš„æ–¹å¼ï¼š<span style="color:blue;">è¢«å¼ºåˆ¶ â€œæ’å…¥â€ çš„ syscall</span>

    ![alt text](../img/6502-pinout.webp){ width="270" }

    å¤„ç†å™¨çš„ä¸­æ–­è¡Œä¸ºï¼Œå¦‚æœå¤„ç†å™¨ä¸­æ–­æ‰“å¼€ï¼š
    
    * x86 Family (CISC çš„å†å²é—è¿¹ï¼›å¤„ç†å™¨å®ç°çš„å™©æ¢¦)
        - è¯¢é—®ä¸­æ–­æ§åˆ¶å™¨è·å¾—ä¸­æ–­å· `n`
        - ä¿å­˜ `CS`, `EIP`, `EFLAGS`, `SS`, `ESP` åˆ°å †æ ˆ
        - è·³è½¬åˆ° `IDT[n]` ä¸­çš„ â€œGateâ€
            + ä¸€ä¸ªæè¿°å¸¦æƒé™åˆ‡æ¢é•¿è·³è½¬çš„æ•°æ®ç»“æ„
    * RISC-V (M-Mode, Direct Exception Mode)
        - æ£€æŸ¥ `mie` æ˜¯å¦å±è”½æ­¤æ¬¡ä¸­æ–­
        - è·³è½¬ `PC = (mtvec & ~0xf)`
        - æ›´æ–° `mcause.Interrupt = 1`

    ä»¥ RISC-V ä¸ºä¾‹ï¼Œä¸­æ–­å…¶å®æ˜¯ä¸€ç§è¢«å¼ºåˆ¶ â€œæ’å…¥â€ çš„ syscall: (â€œæ— è®ºä½ ç°åœ¨åœ¨åšä»€ä¹ˆï¼Œéƒ½å»æ‰§è¡Œä¸€ä¸‹æ“ä½œç³»ç»Ÿå†…æ ¸çš„ä»£ç å§â€)

    <table>
    <tr>
    <td>ä¸­æ–­</td>
    <td>ç³»ç»Ÿè°ƒç”¨ (ecall)</td>
    </tr>
    <tr>
    <td><ul>
    <li>ä¿å­˜ <code>mepc = PC</code></li>
    <li>è·³è½¬ <code>PC = (mtvec & ~0xf)</code></li>
    <li>æ›´æ–° <code>mcause.Interrupt = 1</code></li>
    </ul></td>
    <td><ul>
    <li>ä¿å­˜ <code>mepc = PC</code></li>
    <li>è·³è½¬ <code>PC = (mtvec & ~0xf)</code></li>
    <li>æ›´æ–° <code>mcause.Ecall = 1</code></li>
    </ul></td>
    </tr>
    </table>

    ä¸­æ–­æ¥äº†ï¼Œæ“ä½œç³»ç»Ÿä»£ç åº”è¯¥åšä»€ä¹ˆï¼Ÿ

    * mov (kernel_rsp), %rsp
        - è¿™å°†æ˜¯è‡´å‘½çš„
        - è¿›ç¨‹ (çŠ¶æ€æœº) çš„çŠ¶æ€å°±æ°¸è¿œä¸¢å¤±äº†
    * é¦–å…ˆï¼šå°å­˜çŠ¶æ€æœº (å¯„å­˜å™¨) åˆ°å†…å­˜ä¸Š
        - å†…å­˜ç”±æ•°æ®ç»“æ„æ§åˆ¶
    * ç„¶åï¼šæ‰§è¡Œæ“ä½œç³»ç»Ÿä»£ç 
        - C ä»£ç å¯ä»¥ä»»æ„ä½¿ç”¨å¯„å­˜å™¨
        - æ“ä½œç³»ç»Ÿä»£ç é€‰æ‹©ä¸€ä¸ªè¿”å›çš„çŠ¶æ€æœº
        - æ¢å¤å¯„å­˜å™¨çŠ¶æ€ï¼Œæ‰§è¡Œ sysret (iret)

    thread-os.c

    ```C
    #include <am.h>
    #include <klib.h>
    #include <klib-macros.h>

    typedef union thread {
        struct {
            const char    *name;
            void          (*entry)(void *);
            Context       context;
            union thread  *next;
            char          end[0];
        };
        uint8_t stack[8192];
    } Thread;

    void T1(void *);
    void T2(void *);
    void T3(void *);

    Thread threads[] = {
        // Context for the bootstrap code:
        { .name = "_", .entry = NULL, .next = &threads[1] },

        // Thread contests:
        { .name = "1", .entry = T1, .next = &threads[2] },
        { .name = "2", .entry = T2, .next = &threads[3] },
        { .name = "3", .entry = T3, .next = &threads[1] },
    };
    Thread *current = &threads[0];

    Context *on_interrupt(Event ev, Context *ctx) {
        // Save context.
        current->context = *ctx;

        // Thread schedule.
        current = current->next;

        // Restore current thread's context.
        return &current->context;
    }

    int main() {
        cte_init(on_interrupt);

        for (int i = 1; i < LENGTH(threads); i++) {
            Thread *t = &threads[i];
            t->context = *kcontext(
                // a Thread object:
                // +--------------------------------------------+
                // | name, ... end[0] | Kernel stack ...        |
                // +------------------+-------------------------+
                // ^                  ^                         ^     
                // t                  &t->end                   t + 1
                (Area) { .start = &t->end, .end = t + 1, },
                t->entry, NULL
            );
        }

        yield();    // æ‰§è¡Œ yield() åå†ä¹Ÿä¸å›æ¥äº†
        assert(0);  // Never returns. æ°¸è¿œä¸å¯èƒ½èµ°åˆ°è¿™ä¸€è¡Œ
        // æ“ä½œç³»ç»Ÿï¼šåŠ è½½ç¬¬ä¸€ä¸ªç¨‹åºï¼Œç„¶åå˜æˆåå°çš„ä¸€ä¸ªä¸­æ–­å¤„ç†ç¨‹åº
    }


    void delay() {
        for (int volatile i = 0;
            i < 10000000; i++);
    }

    void T1(void *arg) { while (1) { putch('A'); delay(); } }
    void T2(void *arg) { while (1) { putch('B'); delay(); } }
    void T3(void *arg) { while (1) { putch('C'); delay(); } }
    ```

    ```bash
    linux$ make
    # Building kernel-image [x86_64-qemu]
    + CC thread-os.c
    # Building am-archive [x86_64-qemu]
    # Building klib-archive [x86_64-qemu]
    + LD -> build/kernel-x86_64-qemu.elf
    # Creating image [x86_64-qemu]
    + CREATE -> build/kernel-x86_64-qemu
    linux$ make run
    # Building kernel-run [x86_64-qemu]
    # Building am-archive [x86_64-qemu]
    # Building klib-archive [x86_64-qemu]
    + LD -> build/kernel-x86_64-qemu.elf
    # Creating image [x86_64-qemu]
    + CREATE -> build/kernel-x86_64-qemu
    ABCACBABCABCABCABCBACABCABCBACBACABCBCABCABACBCABCABCABCABCABCABCABCABACBCABCABCABCABACBCABCABACBACBCABACABCBACABCABCAB
    linux$ make debug # ç„¶åå¦å¤–å¼€ä¸€ä¸ªçª—å£ gdb -x init.gdb, å†layout asm/siå•æ­¥æ‰§è¡Œ
    ```

## Lecture 22 è¿›ç¨‹çš„å®ç°
!!! abstract "Take-away Messages"

    Everything is a state machine; è€Œæ“ä½œç³»ç»Ÿåœ¨ä¸­æ–­/ç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œâ€œå°å­˜â€ äº†æ‰€æœ‰è¿›ç¨‹çš„çŠ¶æ€æœºï¼Œå¹¶ä¸”å¯ä»¥å°†å®ƒä»¬é‡æ–°åŠ è½½åˆ° CPU ä¸Šæ‰§è¡Œã€‚é¡ºç€è¿™ä¸ªæ€è·¯ï¼Œæˆ‘ä»¬ä¸éš¾çœ‹åˆ° UNIX æ“ä½œç³»ç»Ÿå’Œç³»ç»Ÿè°ƒç”¨çš„ â€œç›´æ¥â€ å®ç°ã€‚è€Œè¿›ç¨‹ä¸è¿‡æ˜¯ â€œçº¿ç¨‹â€ åŠ ä¸Šäº†ä¸€ä¸ªåœ°å€ç¿»è¯‘å‡½æ•° (åªè¦åŠ ä¸Šè™šæ‹Ÿå†…å­˜ (VR çœ¼é•œ))ã€‚

1. è¿›ç¨‹ = æˆ´ä¸Š VR çœ¼é•œçš„çº¿ç¨‹ã€‚ä¸€ä¸ªå‡½æ•° fï¼Œä½¿æ‰€æœ‰å¯¹å†…å­˜åœ°å€ x çš„è®¿é—®éƒ½è½¬æ¢ä¸º f(x)ã€‚

    ![alt text](../img/page-table.webp){ width="270" }

2. Demand Paging

    è¿›ç¨‹èƒ½åšçš„
    
    * æ‰§è¡Œä¸€æ¡ load/store è®¿é—®ä¸€ä¸ªåœ°å€
    
    æ“ä½œç³»ç»Ÿçœ‹åˆ°çš„
    
    * æ•°æ®ç»“æ„ç»´æŠ¤çš„åŒºé—´åˆ—è¡¨ (pmap)
        - æœ‰äº›éƒ¨åˆ†åˆ†é…äº†ï¼Œæœ‰äº›éƒ¨åˆ†æ²¡åˆ†é…
        - å“ªäº›é¡µé¢è¦ä¿ç•™åœ¨å†…å­˜ï¼Œæ“ä½œç³»ç»Ÿè¯´äº†ç®—
    * å¦‚æœå‘ç”Ÿ Page Fault
        - åˆæ³•ï¼Œæœªåˆ†é…ï¼šæ”¹å˜ f (æ•°æ®ç»“æ„)ï¼Œæ˜ å°„ä¸€é¡µ
        - éæ³•ï¼šSIGSEGV

3. Copy-on-write fork()ï¼šå‡½æ•° f çš„å¦™ç”¨

    * fork() åç›´æ¥æŠŠçˆ¶å­è¿›ç¨‹åœ°å€ç©ºé—´æ ‡è®°æˆåªè¯»
        - åœ¨æœ€é¡¶å±‚é¡µè¡¨æ ‡è®°å³å¯
    * ä»»ä½•åˆæ³•çš„ store Page Fault æ—¶å°±ä¼šåˆ†æˆä¸¤ç§æƒ…å†µ
        - æœªåˆ†é…ï¼šç›´æ¥åˆ†é…
        - å·²åˆ†é… (read-only)ï¼šå¤åˆ¶ä¸€ä»½
            + share_count--
            + share_count == 1 æœ€åä¸€ä»½åªè¯»å‰¯æœ¬ä¹Ÿå˜æˆå¯å†™

    fork() åœ¨è¿›è¡ŒçŠ¶æ€æœºå¤åˆ¶æ—¶ï¼Œè™½ç„¶ç†è®ºä¸Šéœ€è¦åšå‡ºå®Œæ•´çš„çŠ¶æ€å¤åˆ¶ï¼Œä½†æœ¬ç€ â€œå¤åˆ¶çš„æ•°æ®å¯èƒ½ç«‹å³è¢«æµªè´¹æ‰â€ çš„è§‚å¯Ÿï¼Œæ“ä½œç³»ç»Ÿå¸Œæœ›åªåœ¨ â€œä¸å¾—ä¸å¤åˆ¶â€ æ—¶æ‰å¤åˆ¶ã€‚

    ç°ä»£æ“ä½œç³»ç»Ÿä¼šç»´æŠ¤é¡µé¢çš„å…±äº«æƒ…å†µï¼Œå¹¶åœ¨ fork åå°†çˆ¶å­è¿›ç¨‹çš„åœ°å€ç©ºé—´éƒ½æ ‡è®°ä¸º read-onlyï¼Œè€Œå½“åŒæ–¹ä¸­çš„ä»»ä½•ä¸€ä¸ªè¿›ç¨‹å†™å…¥å‘ç”Ÿ page fault æ—¶ï¼Œæ‰å¤åˆ¶ä¸€é¡µã€‚å¯¹äºè¿ç»­çš„ fork()ï¼Œåˆ™ä¼šäº§ç”Ÿå¤šä¸ªè¿›ç¨‹å…±äº«é¡µé¢çš„æƒ…å†µã€‚

4. [xv6: a simple, Unix-like teaching operating system](https://jyywiki.cn/OS/manuals/book-riscv-rev3.pdf)

## Lecture 23 å¤„ç†å™¨è°ƒåº¦
!!! abstract "Take-away Messages"

    è®¡ç®—æœºç³»ç»Ÿè®¾è®¡ä¸­çš„ä¸€ä¸ªé‡è¦ä¸»é¢˜å°±æ˜¯æœºåˆ¶å’Œç­–ç•¥çš„åˆ†ç¦»â€”â€”å®ƒå¸®åŠ©æˆ‘ä»¬åˆ†ç¦»è®¡ç®—æœºç³»ç»Ÿä¸­çš„å¤æ‚æ€§ï¼Œä½¿æˆ‘ä»¬èƒ½åœ¨ä¸€ä¸ªå¹²å‡€çš„æ¦‚å¿µä½“ç³»ä¸Šå¤„ç†å¤æ‚çš„ç³»ç»Ÿã€‚æˆ‘ä»¬çœ‹åˆ°è®¸å¤šè¿™æ ·çš„ä¾‹å­ï¼šåˆ†é¡µæœºåˆ¶å’Œ demand-paging ç­–ç•¥ï¼›ä¸Šä¸‹æ–‡åˆ‡æ¢æœºåˆ¶å’Œè°ƒåº¦ç­–ç•¥ï¼›å®‰å…¨æœºåˆ¶å’Œè®¿é—®æ§åˆ¶ç­–ç•¥ç­‰ç­‰ã€‚é€šè¿‡å°†æœºåˆ¶å’Œç­–ç•¥åˆ†ç¦»ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä¸æ”¹å˜åº•å±‚æœºåˆ¶çš„æƒ…å†µä¸‹è°ƒæ•´ç­–ç•¥ï¼Œä»è€Œæ›´çµæ´»åœ°é€‚åº”ä¸åŒçš„éœ€æ±‚å’Œç¯å¢ƒã€‚è¿™ç§åˆ†ç¦»è¿˜ä½¿å¾—ç³»ç»Ÿçš„è®¾è®¡å’Œå®ç°æ›´åŠ æ¨¡å—åŒ–å’Œå¯ç»´æŠ¤ï¼Œä¾¿äºè°ƒè¯•å’Œä¼˜åŒ–ã€‚

1. å¤„ç†å™¨è°ƒåº¦

    UNIX Nicenessï¼š-20 ... 19 çš„æ•´æ•°ï¼Œè¶Š nice è¶Šè®©åˆ«äººå¾—åˆ° CPU
    
    * -20: æå; most favorable to the process
    * 19: æå¥½; least favorable to the process

    ```bash
    linux$ # å°†è¿›ç¨‹ç»‘å®šåˆ° cpu 3ä¸Šæ‰§è¡Œï¼Œè®¾ç½®niceå€¼ä¸º19å’Œ9ï¼Œçœ‹åˆ°CPUåˆ©ç”¨ç‡æœ‰10å€ä¹‹å·®
    taskset -c 3 nice -n 19 yes > /dev/null &
    taskset -c 3 nice -n  9 yes > /dev/null &
    linux$ top
    PID  USER     PR  NI   VIRT   RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    1539 linux    29   9   3208   1004   908 R  90.4   0.0   0:16.90 yes
    1538 linux    39  19   3208   1032   940 R   9.6   0.0   0:01.84 yes
    ```

2. ç­–ç•¥ï¼šåŠ¨æ€ä¼˜å…ˆçº§ (MLFQ)ã€‚ç³»ç»Ÿè‡ªåŠ¨è®¾å®šä¼˜å…ˆçº§ï¼š
    
    * ç”¨å®Œæ—¶é—´ç‰‡ â†’ åäºº (è¯·è®©å®ƒå˜å¾— â€œæ›´å¥½â€ï¼Œä¼˜å…ˆçº§å˜ä½ â†“)
    * è®©å‡º CPU (I/O) â†’ å¥½äºº (å¯ä»¥å˜å¾—æ›´åï¼Œä¼˜å…ˆçº§å˜é«˜ â†‘)

    ![alt text](../img/MLFQ.webp){ width="210" }

    ç­–ç•¥ï¼šComplete Fair Scheduling (CFS)ã€‚â€œè®©ç³»ç»Ÿé‡Œçš„æ‰€æœ‰è¿›ç¨‹å°½å¯èƒ½å…¬å¹³åœ°å…±äº«å¤„ç†å™¨â€ï¼š

    * ä¸ºæ¯ä¸ªè¿›ç¨‹è®°å½•ç²¾ç¡®çš„è¿è¡Œæ—¶é—´
    * ä¸­æ–­/å¼‚å¸¸å‘ç”Ÿåï¼Œåˆ‡æ¢åˆ°è¿è¡Œæ—¶é—´æœ€å°‘çš„è¿›ç¨‹æ‰§è¡Œ

3. `lstopo`: ç”¨äºæ˜¾ç¤ºç³»ç»Ÿç¡¬ä»¶æ‹“æ‰‘ç»“æ„çš„å‘½ä»¤è¡Œå·¥å…·ï¼Œå®ƒå¯ä»¥å¸®åŠ©ç”¨æˆ·äº†è§£ç³»ç»Ÿä¸­å„ä¸ªç¡¬ä»¶ç»„ä»¶ä¹‹é—´çš„è¿æ¥å…³ç³»å’Œå±‚æ¬¡ç»“æ„ã€‚

    ![alt text](../img/image-19.png)

4. çœŸå®çš„å¤„ç†å™¨è°ƒåº¦

    * ä¼˜å…ˆçº§åè½¬ï¼šåªæœ‰ä¸€ä¸ªå¤„ç†å™¨æ—¶ï¼Œjyy åœ¨æŒæœ‰äº’æ–¥é”çš„æ—¶å€™è¢«ä¸­ä¼˜å…ˆçº§è¿›ç¨‹ changxu èµ¶ä¸‹äº†å¤„ç†å™¨ï¼ˆæ²¡åšå®Œå·¥ä½œï¼Œé”è¿˜æ²¡é‡Šæ”¾ï¼‰ï¼Œç„¶è€Œæ›´é«˜ä¼˜å…ˆçº§çš„xxm æ¥äº†åå› ä¸ºæ²¡æœ‰è·å¾—é”ï¼Œåªèƒ½æœ€åè¢«æ’åˆ°ã€‚
    
    ```C
    void jyy@nju.edu.cn() {
        nice(10);
        mutex_lock(&restroom_lock);
    }

    void changxu@nju.edu.cn() {
        nice(0);
        while (1) ;
    }

    void xxm@nju.edu.cn() {
        nice(-10);
        mutex_lock(&restroom_lock);
    }
    ```

    * ä»Šå¤©çš„è®¡ç®—æœºç³»ç»Ÿï¼šSMP (Symmetric Multi-processing)
        - æ—¢ä¸èƒ½ç®€å•åœ° â€œåˆ†é…çº¿ç¨‹åˆ°å¤„ç†å™¨â€
            + çº¿ç¨‹é€€å‡ºï¼Œç¬é—´å¤„ç†å™¨å¼€å§‹å›´è§‚
        - ä¹Ÿä¸èƒ½ç®€å•åœ° â€œè°ç©ºä¸¢ç»™è°â€
            + åœ¨å¤„ç†å™¨ä¹‹é—´è¿ç§»ä¼šå¯¼è‡´ cache/TLB å…¨éƒ½ç™½ç»™
            + mmap/munmap/mprotect ä¼šè§¦å‘ TLB Shootdown

    * è€Œä¸”è¿˜æœ‰å¾ˆå¤šä¸åŒçš„å®é™…æƒ…å†µ
        - NUMA (Non-uniform memory access): å…±äº«å†…å­˜å¯†é›†å‹ç¨‹åºåœ¨è¿œ/è¿‘ CPU ä¸Šæ€§èƒ½å·®è¾¾åˆ°æ•°å€
        - å¤šç”¨æˆ·: å•çº¿ç¨‹çš„ A å’Œ 10,000 çº¿ç¨‹çš„ B åœ¨ CFS ä¸Šå…±äº« CPU...ï¼Ÿ
        - å¼‚æ„å¤„ç†å™¨: Intel Core Ultra 7: 6P (Ã— 2T) + 8E + 2LPEï¼Œå¤§å°æ ¸...
        - æ›´å°‘çš„å¤„ç†å™¨ï¼Œåè€Œæ›´å¿«...

        ```bash
        linux$ time ./sum 
        sum = 200000000
        2*n = 200000000

        ________________________________________________________
        Executed in 2.37 secs    fish           external
        usr time    4.70 secs  224.00 micros    4.70 secs
        sys time    0.01 secs  168.00 micros    0.01 secs

        linux$ time taskset -c 0 ./sum
        sum = 200000000
        2*n = 200000000

        ________________________________________________________
        Executed in 1.12 secs    fish           external
        usr time    1.12 secs  421.00 micros    1.12 secs
        sys time    0.00 secs  252.00 micros    0.00 secs

        linux$ time taskset -c 0,1,2,3 ./sum
        sum = 200000000
        2*n = 200000000

        ________________________________________________________
        Executed in 2.13 secs    fish           external
        usr time    4.24 secs  323.00 micros    4.24 secs
        sys time    0.01 secs  194.00 micros    0.01 secs

        linux$ 
        ```

## Lecture 24 çŠ¶æ€æœºæ¨¡å‹çš„åº”ç”¨
!!! abstract "Take-away Messages"

    åœ¨è¿™é—¨è¯¾ä¸­ï¼Œæˆ‘ä»¬ä» â€œæ•°å­¦â€ çš„è§†è§’å»ç†è§£è®¡ç®—æœºç³»ç»Ÿä¸­çš„ä¸€åˆ‡â€”â€”å½“æˆ‘ä»¬æŠŠç¨‹åºã€ç¨‹åºçš„æ‰§è¡Œã€è®¡ç®—æœºç³»ç»Ÿçš„æ‰§è¡Œã€ç³»ç»Ÿè°ƒç”¨â€¦â€¦è¿™äº›çœ‹èµ·æ¥åŒ…ç½—ä¸‡è±¡çš„å¤æ‚æ¦‚å¿µéƒ½æŠ•å°„åˆ°ä¸€ä¸ªç®€å•çš„æ¨¡å‹ä¸Šï¼Œç”¨ â€œå¹²å‡€â€ çš„æ€ç»ªå»å¯»æ‰¾é—®é¢˜çš„æœ¬è´¨ã€‚æ— è®ºæ˜¯ä½ å¸Œæœ›å®ç°ä¸€ä¸ªæœºåˆ¶ (ä¾‹å¦‚ä»Šå¤©çš„ä¿¡å·)ï¼Œè¿˜æ˜¯å¸Œæœ›è¯Šæ–­ä¸€ä¸ªå¤æ‚çš„é—®é¢˜ï¼ŒçŠ¶æ€æœºçš„è§†è§’éƒ½å¸®åŠ©ä½ æ’é™¤å¹²æ‰°ã€æ‰¾åˆ°å…³é”®ã€‚

1. Profiler: å®ç° - éš”ä¸€æ®µæ—¶é—´ â€œæš‚åœâ€ ç¨‹åºã€è§‚å¯ŸçŠ¶æ€æœºçš„æ‰§è¡Œ

    * ä¸­æ–­å°±å¯ä»¥åšåˆ° (ä¾‹å¦‚ä¸­æ–­å¤„ç†çš„æ—¶å€™ printf current pc...)
    * ç»™ s â†’ sâ€² çš„æŒ‡ä»¤ â€œè®°è´¦â€
        - å¯¹åº”çš„è¯­å¥
        - å‡½æ•°è°ƒç”¨æ ˆ
    * å¾—åˆ°ç»Ÿè®¡æ„ä¹‰çš„æ€§èƒ½æ‘˜è¦

2. ä¸ºä»€ä¹ˆ Ctrl-C å¯ä»¥ç»ˆæ­¢ç¨‹åº? â¡ï¸ Ctrl-C æ˜¯ä¸€ä¸ªä¿¡å·ï¼Œç§°ä¸º SIGINTï¼ˆInterrupt Signalï¼‰ã€‚å½“ç”¨æˆ·åœ¨ç»ˆç«¯ä¸­æŒ‰ä¸‹ Ctrl-C æ—¶ï¼Œæ“ä½œç³»ç»Ÿä¼šå‘å½“å‰æ­£åœ¨è¿è¡Œçš„å‰å°è¿›ç¨‹å‘é€ SIGINT ä¿¡å·ï¼Œè¿™ä¸ªä¿¡å·çš„ç›®çš„æ˜¯è¯·æ±‚è¿›ç¨‹ç»ˆæ­¢æ‰§è¡Œã€‚

    kill ç³»ç»Ÿè°ƒç”¨: å‘é€ä¿¡å· (ä¸æ˜¯ â€œæ€æ­»â€)

    * UNIX: æˆ‘ä»¬å°±è¿™ä¹ˆéšæ‰‹ä¸€å‘½å ğŸ˜‚
    * å‘½ä»¤è¡Œï¼š`kill -SIGNAME pid`
        - å¯ä»¥ `SIGINT`, `SIGQUIT`, ...
            + `SIGKILL` (9) æ˜¯ä¸å¯å¿½ç•¥çš„ä¿¡å·
            + å¼ºè¡Œç»ˆæ­¢ï¼Œå› æ­¤ä¸æ¨è

    ```C
    #include <stdio.h>
    #include <stdlib.h>
    #include <signal.h>
    #include <unistd.h>

    void handler(int signum) {
        switch (signum) {
            case SIGINT:
                printf("Received SIGINT!\n");
                break;   // ctrl+c æ— æ³•é€€å‡º
            case SIGQUIT:
                printf("Received SIGQUIT!\n");
                exit(0); // å› æ­¤åªæœ‰ ctrl+\ æ‰èƒ½é€€å‡º
                break;
        }
    }

    void cleanup() {
        printf("atexit() cleanup\n");
    }

    int main() {
        signal(SIGINT,  handler);
        signal(SIGQUIT, handler);
        atexit(cleanup);

        while (1) {
            char buf[4096];
            int nread = read(STDIN_FILENO, buf, sizeof(buf));
            buf[nread - 1] = '\0';
            printf("[%d] Got: %s\n", getpid(), buf);
            if (nread < 0) {
                perror("read");
                exit(1);
            }
            sleep(1);
        }
    }
    ```

    ```bash
    linux$ ./signal 
    ^CReceived SIGINT!
    ^\Received SIGQUIT!
    atexit() cleanup
    ```