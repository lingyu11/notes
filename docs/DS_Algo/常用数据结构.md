# 常用数据结构

## 资料
* [常用数据结构](https://leetcode.cn/discuss/post/3583665/fen-xiang-gun-ti-dan-cha)

## 一、常用枚举技巧

### §1.1 枚举右，维护左
1. [两数之和](https://leetcode.cn/problems/two-sum/description/)：<a id="two-sum"></a>

    **关键思路：nums[j] = target - nums[i]。问题变成在一些数中找一个数，哈希表非常适合做这件事**

    ```python
    class Solution:
        def twoSum(self, nums: List[int], target: int) -> List[int]:
            idx = {} # 创建一个空哈希表（字典）, key: num; value: 下标
            for j, x in enumerate(nums):
                if target - x in idx: # python 的 in 比较的是key
                    return [j, idx[target - x]]
                idx[x] = j
    ```

    复杂度分析:

    - 时间复杂度：O(n)，其中 n 为 nums 的长度。
    - 空间复杂度：O(n)，哈希表需要 O(n) 的空间。

    ```python
    d = {'a': 1, 'b': 2}
    print('a' in d)         # True，判断key
    print(1 in d)           # False，1不是key
    print(2 in d.values())  # True，判断值要用d.values()
    ```

2. [与对应负数同时存在的最大正整数](https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/description/)：

    **关键思路：用一个哈希表 set 记录出现过的数字。一边遍历，一边看 −nums[i] 是否在哈希表中，如果在，就更新答案的最大值为 ∣nums[i]∣**

    ```python
    class Solution:
        def findMaxK(self, nums: List[int]) -> int:
            ans = -1
            s = set()
            for x in nums:
                if -x in s:
                    ans = max(ans, abs(x))
                s.add(x)
            return ans
    ```

    复杂度分析：

    - 时间复杂度：O(n)，其中 n 为 nums 的长度。
    - 空间复杂度：O(n)。

    > Python 里的 set（集合）底层实现就是哈希表。它用于存储唯一的、无序的元素，查找、插入和删除操作的平均时间复杂度都是 O(1)。和字典（dict）类似，只不过 set 只存 key，不存 value。

3. [好数对的数目](https://leetcode.cn/problems/number-of-good-pairs/description/)：

    **关键思路：遍历到元素 x 时，把答案增加之前遍历过的 x 的个数。**

    ```python
    class Solution:
        def numIdenticalPairs(self, nums: List[int]) -> int:
            ans = 0
            cnt = defaultdict(int)
            for x in nums:
                ans += cnt[x]
                cnt[x] += 1
            return ans
    ```

    复杂度分析：

    - 时间复杂度：O(n)，其中 n 为 nums 的长度。
    - 空间复杂度：O(n)。

4. [可互换矩形的组数](https://leetcode.cn/problems/number-of-pairs-of-interchangeable-rectangles/description/)：

    **关键思路：同上题，枚举右，维护左。**

    ```python
    class Solution:
        def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:
            ans = 0
            cnt = defaultdict(int)
            for x, y in rectangles:
                ans += cnt[x/y]
                cnt[x/y] += 1
            return ans
    ```

    复杂度分析：

    - 时间复杂度：O(n)，其中 n 为 rectangles 的长度。
    - 空间复杂度：O(n)。

    > defaultdict(int) 是 Python collections 模块中的一个特殊字典类型。它的特点是：当访问一个不存在的键时，会自动创建该键，并赋值为 int() 的默认值（即 0），这样可以直接对计数进行加减操作，无需判断键是否存在。defaultdict(int) 的键可以是任意可哈希类型，包括整数、浮点数、字符串、元组等。如果 x/y 是 0.5（即浮点数），也可以作为字典的 key 使用，没有问题。

5. [等价多米诺骨牌对的数量](https://leetcode.cn/problems/number-of-equivalent-domino-pairs/description/)：

    **关键思路：同上题，枚举右，维护左。可以用 tuple(sorted(x)) 把每个多米诺骨牌排序，这样就可以把等价的多米诺骨牌都映射到同一个 key 了。**

    ```python
    class Solution:
        def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
            ans = 0
            cnt = defaultdict(int)
            for x in dominoes:
                x = tuple(sorted(x)) # 只有两个数，排序是 O(1) 的
                ans += cnt[x]
                cnt[x] += 1
            return ans
    ```

    复杂度分析：

    - 时间复杂度：O(n)，其中 n 为 dominoes 的长度。
    - 空间复杂度：O(n)。

6. [买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/)：

    **关键思路：从左到右枚举卖出价格 prices[i]，用 min_price 维护prices[0] 到 prices[i−1] 的最小值作为买入价格。**

    ```python
    class Solution:
        def maxProfit(self, prices: List[int]) -> int:
            ans = 0
            min_price = prices[0]
            for p in prices:
                ans = max(ans, p - min_price)
                min_price = min(min_price, p)
            return ans
    ```

    复杂度分析：

    - 时间复杂度：O(n)，其中 n 为 prices 的长度。
    - 空间复杂度：O(1)。

7. [增量元素之间的最大差值](https://leetcode.cn/problems/maximum-difference-between-increasing-elements/description/)：

    **关键思路：注意 ans 和 min_n 初始值。**

    ```python
    class Solution:
        def maximumDifference(self, nums: List[int]) -> int:
            ans = 0 # 不能初始化 ans = −1，对于 nums = [1,1] 这种情况，应该返回 −1，但最大差值是 0。
            min_n = inf
            for n in nums:
                ans = max(ans, n - min_n)
                min_n = min(min_n, n)
            return ans or -1 # 如果最终 ans 仍然等于 0，说明不存在 nums[i] < nums[j] 的情况，返回 −1
    ```

    复杂度分析：

    - 时间复杂度：O(n)，其中 n 为 nums 的长度。
    - 空间复杂度：O(1)。

8. [存在重复元素 II](https://leetcode.cn/problems/contains-duplicate-ii/description/)：

    **关键思路：用一个哈希表 last 记录每个数 x 上一次出现的位置下标。**

    ```python
    class Solution:
        def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
            last = {}
            for i, x in enumerate(nums):
                if x in last and i - last[x] <= k:
                    return True
                last[x] = i
            return False
    ```

    复杂度分析：

    - 时间复杂度：O(n)，其中 n 为 nums 的长度。
    - 空间复杂度：O(n)。

9. [必须拿起的最小连续卡牌数](https://leetcode.cn/problems/minimum-consecutive-cards-to-pick-up/description/)：

    **关键思路：用一个哈希表 last 记录每个数 x 上一次出现的位置下标。**

    ```python
    class Solution:
        def minimumCardPickup(self, cards: List[int]) -> int:
            ans = inf
            last = {}
            for i, x in enumerate(cards):
                if x in last:
                    ans = min(ans, i - last[x] + 1)
                last[x] = i
            return ans if ans != inf else -1
    ```

    复杂度分析：

    - 时间复杂度：O(n)，其中 n 为 cards 的长度。
    - 空间复杂度：O(n)。

10. [数组中的最大数对和](https://leetcode.cn/problems/max-pair-sum-in-an-array/description/)：

    **关键思路：用一个长为 10 的数组 max_val[i] 维护数位上最大的数字为 i 的元素的最大值。**

    ```python
    class Solution:
        def maxSum(self, nums: List[int]) -> int:
            ans = -1
            max_val = [-inf] * 10             # 数位上最大的数字只在 0 ~ 9 之间
            for n in nums:
                max_d = max(map(int, str(n))) # 数字n里的数位上最大的数字，复杂度 O(logU)
                ans = max(ans, n + max_val[max_d])
                max_val[max_d] = max(max_val[max_d], n)
            return ans
    ```

    复杂度分析：

    - 时间复杂度：O(nlogU)，其中 n 为 nums 的长度，U = max(nums)。
    - 空间复杂度：O(1)。

    O(logU) 的解释：数字的位数与数值大小的关系

    - 一个数字 n 的位数 d = ⌊log₁₀n⌋ + 1
    - 例如：
        - n = 538，位数 d = 3，因为 log₁₀538 ≈ 2.73，⌊2.73⌋ + 1 = 3
        - n = 1000，位数 d = 4，因为 log₁₀1000 = 3，⌊3⌋ + 1 = 4
        - n = 9999，位数 d = 4，因为 log₁₀9999 ≈ 3.999，⌊3.999⌋ + 1 = 4

    > `n = 538, max_d = max(map(int, str(n)))`的结果是 8：`str(n)` 得到 `'538'`，`map(int, ...)` 得到 `[5, 3, 8]`，`max(...)` 得到 8。

11. [数位和相等数对的最大和](https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/description/)：

    **关键思路：1 <= nums[i] <= 10^9，因此至多 9 个 9 相加，所以数位和范围是 0 ~ 81。**

    ```python
    class Solution:
        def maximumSum(self, nums: List[int]) -> int:
            ans = -1
            mx = [0] * 82
            for n in nums:
                sum_d = sum(map(int, str(n)))
                if mx[sum_d]:
                    ans = max(ans, n + mx[sum_d])
                mx[sum_d] = max(n, mx[sum_d])
            return ans
    ```

    解法二：

    ```python
    class Solution:
        def maximumSum(self, nums: List[int]) -> int:
            ans = -1
            mx = [0] * 82
            for n in nums:
                sum_d = 0
                x = n
                while x:
                    sum_d += x % 10
                    x = x // 10
                if mx[sum_d]:
                    ans = max(ans, n + mx[sum_d])
                mx[sum_d] = max(n, mx[sum_d])
            return ans
    ```

    复杂度分析：

    - 时间复杂度：O(nlogU)，其中 n 为 nums 的长度，U = max(nums)。
    - 空间复杂度：O(1)。

11. [K 和数对的最大数目](https://leetcode.cn/problems/max-number-of-k-sum-pairs/description/)：

    **关键思路：从左到右遍历数组，同时用一个哈希表统计元素及其出现次数。**

    ```python
    class Solution:
        def maxOperations(self, nums: List[int], k: int) -> int:
            ans = 0
            cnt = defaultdict(int)
            for n in nums:
                if cnt[k - n]:
                    ans += 1        # 注意此时 n 并未加入 cnt
                    cnt[k - n] -= 1 # 剔除 k - n
                else:
                    cnt[n] += 1
            return ans
    ```

    复杂度分析：

    - 时间复杂度：O(n)，其中 n 为 nums 的长度。
    - 空间复杂度：O(n)。

12. [统计梯形的数目 I](https://leetcode.cn/problems/count-number-of-trapezoids-i/description/)：

    **关键思路：枚举右，维护左。**

    ```python
    class Solution:
        def countTrapezoids(self, points: List[List[int]]) -> int:
            ans = s = 0                         # s: 之前遍历过的行的边数
            MOD = 1_000_000_007
            cnt = Counter(p[1] for p in points) # 统计每一行的点的个数
            for c in cnt.values():              # 这一行有 c 个点，那么从 c 个点中选 2 个点  
                k = c * (c - 1) // 2            # 有 k 种选法可以组成一条水平边
                ans += s * k                    # 之前遍历过的行数 s 与这一行，一共可以组成 s * k 个水平梯形
                s += k                          # 更新 s
            return ans % MOD
    ```

    复杂度分析：

    - 时间复杂度：O(n)，其中 n 为 points 的长度。
    - 空间复杂度：O(n)。

13. [识别数组中的最大异常值](https://leetcode.cn/problems/identify-the-largest-outlier-in-an-array/description/)：

    **关键思路：设异常值为 x，元素和为 y，那么其余 n−2 个数的和也是 y，所以 x+2y 就是整个 nums 数组的元素和 total，即 x + 2y = total。枚举异常值 x，如果 total−x 是偶数，且 y= (total−x)/2在除去 x 的其余 n−1 个数中，那么 x 就是一个异常值。**

    ```python
    class Solution:
        def getLargestOutlier(self, nums: List[int]) -> int:
            cnt = Counter(nums)
            total = sum(nums)
            ans = -inf
            for n in nums:
                cnt[n] -= 1 # 先除去 n 本身
                if (total - n) % 2 == 0 and cnt[(total - n) // 2] > 0:
                    ans = max(ans, n)
                # 如果 total − n 是偶数，且 y= (total − n) // 2在除去 n 的
                # 其余数中，那么 n 就是一个异常值
                cnt[n] += 1 # 再加回 n
            return ans
    ```

    复杂度分析：

    - 时间复杂度：O(n)，其中 n 为 nums 的长度。
    - 空间复杂度：O(n)。

### §1.1 枚举中间

## 二、前缀和

### §2.1 基础

### §2.2 前缀和与哈希表

### §2.3 距离和

### §2.4 前缀异或和

### §2.5 其他一维前缀和

### §2.6 二维前缀和

## 三、差分

### §3.1 一维差分（扫描线）

### §3.2 二维差分

## 四、栈

### §4.1 基础

### §4.2 进阶

### §4.3 邻项消除

### §4.4 合法括号字符串（RBS）

### §4.5 表达式解析

### §4.6 对顶栈

### §4.7 单调栈