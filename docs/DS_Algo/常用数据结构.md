# 常用数据结构

## 资料
* [常用数据结构](https://leetcode.cn/discuss/post/3583665/fen-xiang-gun-ti-dan-cha)

## 一、常用枚举技巧

### §1.1 枚举右，维护左
1. [两数之和](https://leetcode.cn/problems/two-sum/description/)：

    **关键思路：nums[j] = target - nums[i]。问题变成在一些数中找一个数，哈希表非常适合做这件事**

    ```python
    class Solution:
        def twoSum(self, nums: List[int], target: int) -> List[int]:
            idx = {} # 创建一个空哈希表（字典）, key: num; value: 下标
            for j, x in enumerate(nums):
                if target - x in idx: # python 的 in 比较的是key
                    return [j, idx[target - x]]
                idx[x] = j
    ```

    复杂度分析:

    - 时间复杂度：O(n)，其中 n 为 nums 的长度。
    - 空间复杂度：O(n)，哈希表需要 O(n) 的空间。

    ```python
    d = {'a': 1, 'b': 2}
    print('a' in d)         # True，判断key
    print(1 in d)           # False，1不是key
    print(2 in d.values())  # True，判断值要用d.values()
    ```

2. [与对应负数同时存在的最大正整数](https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/description/)：

    **关键思路：用一个哈希表 set 记录出现过的数字。一边遍历，一边看 −nums[i] 是否在哈希表中，如果在，就更新答案的最大值为 ∣nums[i]∣**

    ```python
    class Solution:
        def findMaxK(self, nums: List[int]) -> int:
            ans = -1
            s = set()
            for x in nums:
                if -x in s:
                    ans = max(ans, abs(x))
                s.add(x)
            return ans
    ```

    复杂度分析：

    - 时间复杂度：O(n)，其中 n 为 nums 的长度。
    - 空间复杂度：O(n)。

    > Python 里的 set（集合）底层实现就是哈希表。它用于存储唯一的、无序的元素，查找、插入和删除操作的平均时间复杂度都是 O(1)。和字典（dict）类似，只不过 set 只存 key，不存 value。

### §1.1 枚举中间

## 二、前缀和

### §2.1 基础

### §2.2 前缀和与哈希表

### §2.3 距离和

### §2.4 前缀异或和

### §2.5 其他一维前缀和

### §2.6 二维前缀和

## 三、差分

### §3.1 一维差分（扫描线）

### §3.2 二维差分

## 四、栈

### §4.1 基础

### §4.2 进阶

### §4.3 邻项消除

### §4.4 合法括号字符串（RBS）

### §4.5 表达式解析

### §4.6 对顶栈

### §4.7 单调栈