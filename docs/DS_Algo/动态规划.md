# 动态规划

## 资料
* [动态规划](https://leetcode.cn/circle/discuss/tXLS3i/)

## 一、入门 DP

初始这的设定：求方案数一般是 1，求最小最大一般是 0 或者 inf 等其他值

### §1.1 爬楼梯

1. [爬楼梯](https://leetcode.cn/problems/climbing-stairs/description/)：

    **关键思路：**

    **1. 当前状态是「上一个状态」和「上上个状态」之和，每次循环更新的时候，「上上个状态」就是 f1 了，「上一个状态」就是 new_f 了**

    **2. `f0, f1 = f1, f0 + f1`是 python 的并行赋值语句，先计算等号右边的元组，拿到的都是 f0 和 f1 的原始值，然后并行赋值给左边**

    ```python
    class Solution:
        def climbStairs(self, n: int) -> int:
            f0 = f1 = 1
            # f0: 从 0 爬到 0 有一种方法，即原地不动。-> 纯粹是强行凑的
            # f1: 从 0 爬到 1 有一种方法，即爬 1 个台阶。
            for _ in range(2, n + 1):
                f0, f1 = f1, f0 + f1
            return f1
    ```

    更繁琐的写法：

    ```python
    class Solution:
        def climbStairs(self, n: int) -> int:
            f0 = f1 = 1
            for _ in range(2, n + 1):
                new_f = f0 + f1
                f0 = f1
                f1 = new_f
            return f1
    ```

2. [使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/description/)：

    递归写法：自顶向下

    ```python
    class Solution:
        def minCostClimbingStairs(self, cost: List[int]) -> int:
            @cache            # 缓存装饰器，避免重复计算 dfs 的结果
            def dfs(i: int) -> int:
                if i <= 1:    # 递归边界
                    return 0  # 爬到 0 或 1 无需花费，因为我们一开始就在 0 或 1
                return min(dfs(i - 1) + cost[i - 1], dfs(i - 2) + cost[i - 2])
            return dfs(len(cost))
    ```

    递推写法：自底向上

    ```python
    class Solution:
        def minCostClimbingStairs(self, cost: List[int]) -> int:
            f0 = f1 = 0
            # 爬到 0 或 1 无需花费，因为我们一开始就在 0 或 1
            for c0, c1 in pairwise(cost):
                f0, f1 = f1, min(f0 + c0, f1 + c1)
            return f1
    ```

3. [组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/description/)：

    **关键思路：转换为爬楼梯，总共有多少种方案能够爬上 target 阶楼梯？以 nums = [1,2,3], target = 4 为例，爬上台阶为 4 的楼梯，可以是一次性再跨 1 级就到了，也可以是一次性再跨 2 或 3 级就到了，也就是说 dfs(i) = dfs(i−1) + dfs(i−2) + dfs(i-3)**

    递归写法：自顶向下

    ```python
    class Solution:
        def combinationSum4(self, nums: List[int], target: int) -> int:
            @cache            # 缓存装饰器，避免重复计算 dfs 的结果
            def dfs(i: int) -> int:
                if i == 0:    # 爬 0 个台阶的方案数是 1
                    return 1
                return sum(dfs(i - x) for x in nums if x <= i)
            return dfs(target)
    ```

    递推写法：自底向上

    ```python
    class Solution:
        def combinationSum4(self, nums: List[int], target: int) -> int:
            f = [1] + [0] * target
            for i in range(1, target + 1):
                f[i] = sum(f[i - x] for x in nums if x <= i)
            return f[target]
    ```

### §1.2 打家劫舍

### §1.3 最大子数组和（最大子段和）

## 二、网格图 DP

### §2.1 基础

### §2.2 进阶

## 三、背包

### §3.1 0-1 背包

### §3.2 完全背包

### §3.3 多重背包

### §3.4 分组背包

## 四、经典线性 DP

### §4.1 最长公共子序列（LCS）

### §4.2 最长递增子序列（LIS）

## 五、状态机 DP

## 六、划分型 DP

### §6.1 判定能否划分

### §6.2 最优划分

### §6.3 约束划分个数

### §6.4 不相交区间

## 七、其他线性 DP

### §7.1 一维 DP

### §7.2 合法子序列 DP（特殊子序列 DP）

### §7.3 矩阵快速幂优化 DP

### §7.4 子矩形 DP

### §7.5 多维 DP

...
