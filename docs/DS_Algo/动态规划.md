# 动态规划

## 资料
* [动态规划](https://leetcode.cn/circle/discuss/tXLS3i/)

## 一、入门 DP

初始值的设定：求方案数一般是 1，求最小最大一般是 0 或者 inf 等其他值

### §1.1 爬楼梯

1. [爬楼梯](https://leetcode.cn/problems/climbing-stairs/description/)：

    **关键思路：**

    **1. 当前状态是「上一个状态」和「上上个状态」之和，每次循环更新的时候，「上上个状态」就是 f1 了，「上一个状态」就是 new_f 了**

    **2. `f0, f1 = f1, f0 + f1`是 python 的并行赋值语句，先计算等号右边的元组，拿到的都是 f0 和 f1 的原始值，然后并行赋值给左边**

    ```python
    class Solution:
        def climbStairs(self, n: int) -> int:
            f0 = f1 = 1
            # f0: 从 0 爬到 0 有一种方法，即原地不动。-> 纯粹是强行凑的
            # f1: 从 0 爬到 1 有一种方法，即爬 1 个台阶。
            for _ in range(2, n + 1):
                f0, f1 = f1, f0 + f1
            return f1
    ```

    更繁琐的写法：

    ```python
    class Solution:
        def climbStairs(self, n: int) -> int:
            f0 = f1 = 1
            for _ in range(2, n + 1):
                new_f = f0 + f1
                f0 = f1
                f1 = new_f
            return f1
    ```

2. [使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/description/)：

    递归写法：自顶向下

    ```python
    class Solution:
        def minCostClimbingStairs(self, cost: List[int]) -> int:
            @cache            # 缓存装饰器，避免重复计算 dfs 的结果
            def dfs(i: int) -> int:
                if i <= 1:    # 递归边界
                    return 0  # 爬到 0 或 1 无需花费，因为我们一开始就在 0 或 1
                return min(dfs(i - 1) + cost[i - 1], dfs(i - 2) + cost[i - 2])
            return dfs(len(cost))
    ```

    递推写法：自底向上

    ```python
    class Solution:
        def minCostClimbingStairs(self, cost: List[int]) -> int:
            f0 = f1 = 0
            # 爬到 0 或 1 无需花费，因为我们一开始就在 0 或 1
            for c0, c1 in pairwise(cost):
                f0, f1 = f1, min(f0 + c0, f1 + c1)
            return f1
    ```

3. [组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/description/)：

    **关键思路：转换为爬楼梯，总共有多少种方案能够爬上 target 阶楼梯？以 nums = [1,2,3], target = 4 为例，爬上台阶为 4 的楼梯，可以是一次性再跨 1 级就到了，也可以是一次性再跨 2 或 3 级就到了，也就是说 dfs(i) = dfs(i−1) + dfs(i−2) + dfs(i-3)**

    递归写法：自顶向下

    ```python
    class Solution:
        def combinationSum4(self, nums: List[int], target: int) -> int:
            @cache            # 缓存装饰器，避免重复计算 dfs 的结果
            def dfs(i: int) -> int:
                if i == 0:    # 爬 0 个台阶的方案数是 1
                    return 1
                return sum(dfs(i - x) for x in nums if x <= i)
            return dfs(target)
    ```

    递推写法：自底向上

    ```python
    class Solution:
        def combinationSum4(self, nums: List[int], target: int) -> int:
            f = [1] + [0] * target
            for i in range(1, target + 1):
                f[i] = sum(f[i - x] for x in nums if x <= i)
            return f[target]
    ```

4. [统计构造好字符串的方案数](https://leetcode.cn/problems/count-ways-to-build-good-strings/description/)：

    **关键思路：转换为爬楼梯，每次可以爬 zero 或 one 个台阶，返回爬 low 到 high 个台阶的方案数。在长为 i−zero 的字符串末尾添加 zero 个 0，方案数为 f[i−zero]；或在长为 i−one 的字符串末尾添加 one 个 1，方案数为 f[i−one]。**


    ```python
    class Solution:
        def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
            MOD = 1_000_000_007
            @cache
            def dfs(i: int) -> int:
                if i < 0:
                    return 0 # 保证 i >= zero and i >= one 不满足时，直接 return 0
                if i == 0:
                    return 1
                return (dfs(i - zero) + dfs(i - one) % MOD)
            return sum(dfs(i) for i in range(low, high + 1)) % MOD
    ```

5. [统计打字方案数](https://leetcode.cn/problems/count-number-of-texts/description/)：

    **关键思路：**

    **1. 转换为爬楼梯，每次可以跳 1~3 或者 1~4 个台阶，计算跳 cnt (连续相同子串的长度) 个台阶的方案数。f[i] 表示长为 i 的只有一种字符的字符串所对应的文字信息种类数，我们可以将末尾的 1 个、2 个或 3 个字符变成一个字母，那么有转移方程 f[i] = f[i−1] + f[i−2] + f[i−3]，对于 7/9 数字按键，则是 g[i] = g[i−1] + g[i−2] + g[i−3] + g[i−4]**

    **2. 由于各个组（连续相同子串）的打字方案互相独立，根据乘法原理，把各个组的方案数相乘，即为答案。**
    
    **3. 初始值的设定：f[0] = f[1] = 1，f[2] = 2，f[3] = 4, 例如 222 可以是 aaa/ab/ba/c 这 4 种**

    ```python
    # 写在 class 外的代码是不计算时间的
    MOD = 1_000_000_007
    f = [1, 1, 2, 4]
    g = [1, 1, 2, 4]
    for _ in range(4, 10 ** 5 + 1):
        f.append((f[-1] + f[-2] + f[-3]) % MOD)
        g.append((g[-1] + g[-2] + g[-3] + g[-4]) % MOD)

    class Solution:
        def countTexts(self, pressedKeys: str) -> int:
            ans = 1
            for ch, s in groupby(pressedKeys):
                m = len(list(s))
                ans = ans * (g[m] if ch in "79" else f[m]) % MOD
            return ans
    ```

### §1.2 打家劫舍

1. [打家劫舍](https://leetcode.cn/problems/house-robber/description/)：

    **关键思路：**

    **1. dfs(i) 表示从 nums[0] 到 nums[i] 最多能偷多少**

    **2. 迭代停止条件：总是看前两个和前一个，一直往前推，可以发现到 nums[0] 时，会有下标小于 0**

    ```python
    class Solution:
        def rob(self, nums: List[int]) -> int:
            @cache
            def dfs(i: int) -> int:
                if i < 0:
                    return 0
                return max(dfs(i - 2) + nums[i], dfs(i - 1))
            return dfs(len(nums) - 1)
    ```

2. [删除并获得点数](https://leetcode.cn/problems/delete-and-earn/description/)：

3. [统计放置房子的方式数](https://leetcode.cn/problems/count-number-of-ways-to-place-houses/)：

    **关键思路：**

    **1. f[i] 表示前 i 个地块的放置方案数，f[i]=f[i − 1] (第i个地块不放房子) + f[i − 2] (第i个地块放房子)**

    **2. 两侧的房屋互相独立，根据乘法原理，答案为 f[n] ** 2**

    ```python
    MOD = 10 ** 9 + 7
    f = [1, 2]
    for _ in range(2, 10 ** 4 + 1):
        f.append((f[-1] + f[-2]) % MOD)

    class Solution:
        def countHousePlacements(self, n: int) -> int:
            return f[n] ** 2 % MOD
    ```

4. [打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/description/)：

    **关键思路：转换为打家劫舍 I，对于nums[0]而言：**

    **1. 如果偷 nums[0]，那么 nums[1] 和 nums[n − 1] 不能偷，问题变成从 nums[2] 到 nums[n − 2] 的非环形版本**

    **2. 如果不偷 nums[0]，那么问题变成从 nums[1] 到 nums[n − 1] 的非环形版本**

    ```python
    class Solution:
        def rob1(self, nums: List[int]) -> int:
            f0 = f1 = 0
            for n in nums:
                f0, f1 = f1, max(f0 + n, f1)
            return f1
        def rob(self, nums: List[int]) -> int:
            return max(nums[0] + self.rob1(nums[2:-1]), self.rob1(nums[1:]))
    ```

### §1.3 最大子数组和（最大子段和）

## 二、网格图 DP

### §2.1 基础

### §2.2 进阶

## 三、背包

### §3.1 0-1 背包

### §3.2 完全背包

### §3.3 多重背包

### §3.4 分组背包

## 四、经典线性 DP

### §4.1 最长公共子序列（LCS）

### §4.2 最长递增子序列（LIS）

## 五、状态机 DP

## 六、划分型 DP

### §6.1 判定能否划分

### §6.2 最优划分

### §6.3 约束划分个数

### §6.4 不相交区间

## 七、其他线性 DP

### §7.1 一维 DP

### §7.2 合法子序列 DP（特殊子序列 DP）

### §7.3 矩阵快速幂优化 DP

### §7.4 子矩形 DP

### §7.5 多维 DP

...
