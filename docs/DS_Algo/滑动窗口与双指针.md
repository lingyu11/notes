# 滑动窗口与双指针

## 资料
* [滑动窗口与双指针](https://leetcode.cn/circle/discuss/0viNMK/)

## 一、定长滑动窗口

### §1.1 基础
1. [定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)：给你字符串 s 和整数 k 。请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。英文中的 元音字母 为（a, e, i, o, u）。示例：

    输入：s = "abciiidef", k = 3

    输出：3

    解释：子字符串 "iii" 包含 3 个元音字母。

    ```python
    class Solution:
        def maxVowels(self, s: str, k: int) -> int:
            ans = vowel = 0
            for i, c in enumerate(s):
                if c in "aeiou":            # 1. 进入窗口
                    vowel += 1
                if i < k - 1:               # 窗口大小不足 k
                    continue
                ans = max(ans, vowel)       # 2. 更新答案
                if s[i - k + 1] in "aeiou": # 3. 离开窗口
                    vowel -= 1
            return ans
    ```

2. [爱生气的书店老板](https://leetcode.cn/problems/grumpy-bookstore-owner/description/)：

    **关键思路：将问题拆分成两个子问题**

    ```python
    class Solution:
        def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:
            # s[0]: 老板不生气时的顾客数量之和
            # s[1]: 长度为 minutes 的连续子数组中，老板生气时的顾客数量之和，通过定长滑动窗口解决
            # 最终答案为 s0 + max_s1
            s = [0, 0]
            max_s1 = 0
            for i, (c, g) in enumerate(zip(customers, grumpy)):
                s[g] += c
                if i < minutes - 1:                     # 窗口长度不足 minutes
                    continue
                max_s1 = max(max_s1, s[1])              # 更新 max_s1
                if grumpy[i - minutes + 1]:             # 因为 s0 和 s1 是分开统计的，所以离开窗口时要判断
                    s[1] -= customers[i - minutes + 1]  # 窗口最左边元素离开窗口
            return s[0] + max_s1
    ```

3. [检查一个字符串是否包含所有长度为 K 的二进制子串](https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/description/)：给你一个二进制字符串 s 和一个整数 k 。如果所有长度为 k 的二进制字符串都是 s 的子串，请返回 true ，否则请返回 false 。示例：
   
    输入：s = "00110110", k = 2

    输出：true

    解释：长度为 2 的二进制串包括 "00"，"01"，"10" 和 "11"。它们分别是 s 中下标为 0，1，3，2 开始的长度为 2 的子串。

    **关键思路：统计所有出现过的长度为 k 的 unique 子串，判断结果是否和 2 ** k 相等**

    ```python
    class Solution:
        def hasAllCodes(self, s: str, k: int) -> bool:
            ans = set()
            left = 0
            for right, c in enumerate(s):        # 1. 进入窗口
                if right < k - 1:                # 窗口大小不足
                    continue
                ans.add(s[left : right + 1])     # 2. 更新答案
                left += 1                        # 3. 离开窗口
            return len(ans) == 2 ** k
    ```

4. [几乎唯一子数组的最大和](https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/description/)：

    **关键思路：利用 Counter 来统计每个数出现的次数**

    ```python
    class Solution:
        def maxSum(self, nums: List[int], m: int, k: int) -> int:
            ans = 0
            s = sum(nums[:k - 1])         # 先统计前 k-1 个数
            cnt = Counter(nums[:k - 1])
            for out, in_ in zip(nums, nums[k - 1:]):
                s += in_                  # 再添加一个数就是 k 个数了
                cnt[in_] += 1
                if len(cnt) >= m:
                    ans = max(ans, s)     # 是几乎唯一子数组，更新答案
                s -= out                  # 离开窗口
                cnt[out] -= 1
                if cnt[out] == 0:
                    del cnt[out]
            return ans
    ```

5. [可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/description/)：

    **关键思路：逆向思维 - 转换为求最小和 ➡️ 最小化剩下的点数和**

    ```python
    class Solution:
        def maxScore(self, cardPoints: List[int], k: int) -> int:
            n = len(cardPoints)
            m = n - k
            s = 0
            min_s = math.inf
            # 注意 python 的enumerate无法提前取到后面的元素，特殊情况的判断
            if (m == 0):
                return sum(cardPoints)
            for i, num in enumerate(cardPoints):
                s += num
                if i < m - 1:
                    continue
                min_s = min(min_s, s)
                s -= cardPoints[i - m + 1]
            return sum(cardPoints) - min_s
    ```

    更精简的写法：

    ```python
    class Solution:
        def maxScore(self, cardPoints: List[int], k: int) -> int:
            n = len(cardPoints)
            m = n - k
            min_s = s = sum(cardPoints[:m])
            for i in range(m, n):
                s += cardPoints[i] - cardPoints[i - m]
                min_s = min(min_s, s)
            return sum(cardPoints) - min_s
    ```

6. [拆炸弹](https://leetcode.cn/problems/defuse-the-bomb/description/)：

    **关键思路：举例详细推演，找到规律，发现 k > 0 和 k < 0 的情况相同，定义右边界 r 很关键**

    ```python
    class Solution:
        def decrypt(self, code: List[int], k: int) -> List[int]:
            # k > 0，第一个窗口的的下标范围为 [1, k + 1)
            # k < 0，第一个窗口的的下标范围为 [n - |k|, n)
            # 窗口总是向右移动，移入窗口的下标是 r % n, 移出的是 (r - |k|) % n
            n = len(code)
            ans = [0] * n
            r = k + 1 if k > 0 else n  # 关键点：定义右边界 r
            k = abs(k)
            s = sum(code[r - k: r])    # ans[0]
            for i in range(n):
                ans[i] = s
                s += code[r % n] - code[(r - k) % n]
                r += 1
            return ans
    ```

7. [子串的最大出现次数](https://leetcode.cn/problems/maximum-number-of-occurrences-of-a-substring/description/)：

    **关键思路：maxSize 是干扰项，因为长的串重复它的子串一定也重复，因此只需要满足 minSize 要求**

    ```python
    class Solution:
        def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:
            n = len(s)
            d = collections.defaultdict(int)
            for i in range(n - minSize + 1):
                tmp = s[i: i + minSize]
                c = set(tmp)
                if len(c) <= maxLetters:
                    d[tmp] += 1
            return max(d.values()) if d else 0
    ```

### §1.2 进阶

1. [最少交换次数来组合所有的 1 II](https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/)：

    **关键思路：**

    **1. 我们已经知道 1 的全部个数，那么我们就拿 1 的个数这么长的窗口来滑动**

    **2. 求出窗口和的最大值，用 1 的个数减去窗口和最大值，就是最少的交换次数**

    **3. 对于环状，我们直接把原来数组再追加到尾部，自然就首尾相接了**

    ```python
    class Solution:
        def minSwaps(self, nums: List[int]) -> int:
            k = sum(nums)
            max_s = s = sum(nums[:k])
            nums.extend(nums)
            for out, in_ in zip(nums, nums[k:]):
                s += in_ - out
                max_s = max(max_s, s)
            return k - max_s
    ```

2. [滑动子数组的美丽值](https://leetcode.cn/problems/sliding-subarray-beauty/description/)：

    **关键思路：**

    **1. -50 <= nums[i] <= 50, 最多 101 个元素。值域很小，可以借鉴计数排序，用一个 cnt 数组维护窗口内每个数的出现次数。**

    **2. 美丽值是负数或 0，不用考虑正数的那一半**

    **3. 求第 x 小的数：通过遍历 cnt 数组**

    ```python
    class Solution:
        def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:
            n = len(nums)
            ans = [0] * (n - k + 1)
            cnt = [0] * 101            # -50 <= nums[i] <= 50, 最多 101 个元素
            # [0, 1, ..., 50, 51, ..., 100]: cnt 数组下标
            #  0     1 ~ 50     -50 ~ -1   : cnt 数组下标代表的数字 num[i]
            for num in nums[:k - 1]:   # 先往窗口内添加 k-1 个数
                cnt[num] += 1
            for i, (out, in_) in enumerate(zip(nums, nums[k-1:])):
                cnt[in_] += 1           # 进入窗口（保证窗口有恰好 k 个数）
                left = x
                for j in range(-50, 0): # 暴力枚举负数范围 [-50,-1]
                    left -= cnt[j]
                    if left <= 0:       # 找到美丽值
                        ans[i] = j
                        break
                cnt[out] -= 1           # 离开窗口
            return ans
    ```

3. 📌 [使二进制字符串字符交替的最少反转次数](https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/description/)：

4. [字符串的排列](https://leetcode.cn/problems/permutation-in-string/)：

    **关键思路：滑动窗口 + 字典 Counter（排列的判断：两个字符串的每个字符的个数都相等）**

    ```python
    class Solution:
        def checkInclusion(self, s1: str, s2: str) -> bool:
            k = len(s1)
            cnt1 = Counter(s1)
            cnt2 = Counter(s2[:k-1])
            for out, in_ in zip(s2, s2[k-1:]):
                cnt2[in_] += 1
                if cnt2 == cnt1:
                    return True
                cnt2[out] -= 1
            return False
    ```

5. 📌 [串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/)：

6. 📌 [查找给定哈希值的子串](https://leetcode.cn/problems/find-substring-with-given-hash-value/description/)：

7. 📌 [统计完全子字符串](https://leetcode.cn/problems/count-complete-substrings/description/)：

8. 📌 [子串能表示从 1 到 N 数字的二进制串](https://leetcode.cn/problems/binary-string-with-substrings-representing-1-to-n/)：

    ```python
    class Solution:
        def queryString(self, s: str, n: int) -> bool:
            return all(bin(i)[2:] in s for i in range(1, n + 1))
    # 1. 暴力枚举 [1,n] 内的数，转成二进制字符串: 
    # bin函数可以将整数转化为二进制字符串，去除掉前面的 '0b'
    # 2. all接受一个可迭代对象，如果可迭代对象中的所有元素都为 True 才返回True
    ```

### §1.3 其他

## 二、不定长滑动窗口

### §2.1 求最长/最大

### §2.2 求最短/最小

### §2.3 求子数组个数

#### §2.3.1 越长越合法

#### §2.3.2 越短越合法

#### §2.3.3 恰好型滑动窗口

### §2.4 其他

## 三、单序列双指针

### §3.1 相向双指针

### §3.2 同向双指针

### §3.3 背向双指针

### §3.4 原地修改

## 四、双序列双指针

### §4.1 双指针

### §4.2 判断子序列

### §4.3 其他

## 五、三指针

## 六、分组循环