# 滑动窗口与双指针

## 资料
* [滑动窗口与双指针](https://leetcode.cn/circle/discuss/0viNMK/)

## 一、定长滑动窗口

### §1.1 基础
1. [定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)：给你字符串 s 和整数 k 。请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。英文中的 元音字母 为（a, e, i, o, u）。示例：

    输入：s = "abciiidef", k = 3

    输出：3

    解释：子字符串 "iii" 包含 3 个元音字母。

    ```python
    class Solution:
        def maxVowels(self, s: str, k: int) -> int:
            ans = vowel = 0
            for i, c in enumerate(s):
                if c in "aeiou":            # 1. 进入窗口
                    vowel += 1
                if i < k - 1:               # 窗口大小不足 k
                    continue
                ans = max(ans, vowel)       # 2. 更新答案
                if s[i - k + 1] in "aeiou": # 3. 离开窗口
                    vowel -= 1
            return ans
    ```

2. [爱生气的书店老板](https://leetcode.cn/problems/grumpy-bookstore-owner/description/)：

    **关键思路：将问题拆分成两个子问题**

    ```python
    class Solution:
        def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:
            # s[0]: 老板不生气时的顾客数量之和
            # s[1]: 长度为 minutes 的连续子数组中，老板生气时的顾客数量之和，通过定长滑动窗口解决
            # 最终答案为 s0 + max_s1
            s = [0, 0]
            max_s1 = 0
            for i, (c, g) in enumerate(zip(customers, grumpy)):
                s[g] += c
                if i < minutes - 1:                     # 窗口长度不足 minutes
                    continue
                max_s1 = max(max_s1, s[1])              # 更新 max_s1
                if grumpy[i - minutes + 1]:             # 因为 s0 和 s1 是分开统计的，所以离开窗口时要判断
                    s[1] -= customers[i - minutes + 1]  # 窗口最左边元素离开窗口
            return s[0] + max_s1
    ```

3. [检查一个字符串是否包含所有长度为 K 的二进制子串](https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/description/)：

    **关键思路：统计所有出现过的长度为 k 的 unique 子串，判断结果是否和 2 ** k 相等**

    ```python
    class Solution:
        def hasAllCodes(self, s: str, k: int) -> bool:
            ans = set()
            left = 0
            for right, c in enumerate(s):        # 1. 进入窗口
                if right < k - 1:                # 窗口大小不足
                    continue
                ans.add(s[left : right + 1])     # 2. 更新答案
                left += 1                        # 3. 离开窗口
            return len(ans) == 2 ** k
    ```

4. [几乎唯一子数组的最大和](https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/description/)：

    **关键思路：利用 Counter 来统计每个数出现的次数**

    ```python
    class Solution:
        def maxSum(self, nums: List[int], m: int, k: int) -> int:
            ans = 0
            s = sum(nums[:k - 1])         # 先统计前 k-1 个数
            cnt = Counter(nums[:k - 1])
            for out, in_ in zip(nums, nums[k - 1:]):
                s += in_                  # 再添加一个数就是 k 个数了
                cnt[in_] += 1
                if len(cnt) >= m:
                    ans = max(ans, s)     # 是几乎唯一子数组，更新答案
                s -= out                  # 离开窗口
                cnt[out] -= 1
                if cnt[out] == 0:
                    del cnt[out]
            return ans
    ```

5. [可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/description/)：

    **关键思路：逆向思维 - 转换为求最小和 ➡️ 最小化剩下的点数和**

    ```python
    class Solution:
        def maxScore(self, cardPoints: List[int], k: int) -> int:
            n = len(cardPoints)
            m = n - k
            s = 0
            min_s = math.inf
            # 注意 python 的enumerate无法提前取到后面的元素，特殊情况的判断
            if (m == 0):
                return sum(cardPoints)
            for i, num in enumerate(cardPoints):
                s += num
                if i < m - 1:
                    continue
                min_s = min(min_s, s)
                s -= cardPoints[i - m + 1]
            return sum(cardPoints) - min_s
    ```

    更精简的写法：

    ```python
    class Solution:
        def maxScore(self, cardPoints: List[int], k: int) -> int:
            n = len(cardPoints)
            m = n - k
            min_s = s = sum(cardPoints[:m])
            for i in range(m, n):
                s += cardPoints[i] - cardPoints[i - m]
                min_s = min(min_s, s)
            return sum(cardPoints) - min_s
    ```

6. [拆炸弹](https://leetcode.cn/problems/defuse-the-bomb/description/)：

    **关键思路：举例详细推演，找到规律，发现 k > 0 和 k < 0 的情况相同，定义右边界 r 很关键**

    ```python
    class Solution:
        def decrypt(self, code: List[int], k: int) -> List[int]:
            # k > 0，第一个窗口的的下标范围为 [1, k + 1)
            # k < 0，第一个窗口的的下标范围为 [n - |k|, n)
            # 窗口总是向右移动，移入窗口的下标是 r % n, 移出的是 (r - |k|) % n
            n = len(code)
            ans = [0] * n
            r = k + 1 if k > 0 else n  # 关键点：定义右边界 r
            k = abs(k)
            s = sum(code[r - k: r])    # ans[0]
            for i in range(n):
                ans[i] = s
                s += code[r % n] - code[(r - k) % n]
                r += 1
            return ans
    ```

7. [子串的最大出现次数](https://leetcode.cn/problems/maximum-number-of-occurrences-of-a-substring/description/)：

    **关键思路：maxSize 是干扰项，因为长的串重复它的子串一定也重复，因此只需要满足 minSize 要求**

    ```python
    class Solution:
        def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:
            n = len(s)
            d = collections.defaultdict(int)
            for i in range(n - minSize + 1):
                tmp = s[i: i + minSize]
                c = set(tmp)
                if len(c) <= maxLetters:
                    d[tmp] += 1
            return max(d.values()) if d else 0
    ```

### §1.2 进阶

1. [最少交换次数来组合所有的 1 II](https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/)：

    **关键思路：**

    **1. 我们已经知道 1 的全部个数，那么我们就拿 1 的个数这么长的窗口来滑动**

    **2. 求出窗口和的最大值，用 1 的个数减去窗口和最大值，就是最少的交换次数**

    **3. 对于环状，我们直接把原来数组再追加到尾部，自然就首尾相接了**

    ```python
    class Solution:
        def minSwaps(self, nums: List[int]) -> int:
            k = sum(nums)
            max_s = s = sum(nums[:k])
            nums.extend(nums)
            for out, in_ in zip(nums, nums[k:]):
                s += in_ - out
                max_s = max(max_s, s)
            return k - max_s
    ```

2. [滑动子数组的美丽值](https://leetcode.cn/problems/sliding-subarray-beauty/description/)：

    **关键思路：**

    **1. -50 <= nums[i] <= 50, 最多 101 个元素。值域很小，可以借鉴计数排序，用一个 cnt 数组维护窗口内每个数的出现次数。**

    **2. 美丽值是负数或 0，不用考虑正数的那一半**

    **3. 求第 x 小的数：通过遍历 cnt 数组**

    ```python
    class Solution:
        def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:
            n = len(nums)
            ans = [0] * (n - k + 1)
            cnt = [0] * 101            # -50 <= nums[i] <= 50, 最多 101 个元素
            # [0, 1, ..., 50, 51, ..., 100]: cnt 数组下标
            #  0     1 ~ 50     -50 ~ -1   : cnt 数组下标代表的数字 num[i]
            for num in nums[:k - 1]:   # 先往窗口内添加 k-1 个数
                cnt[num] += 1
            for i, (out, in_) in enumerate(zip(nums, nums[k-1:])):
                cnt[in_] += 1           # 进入窗口（保证窗口有恰好 k 个数）
                left = x
                for j in range(-50, 0): # 暴力枚举负数范围 [-50,-1]
                    left -= cnt[j]
                    if left <= 0:       # 找到美丽值
                        ans[i] = j
                        break
                cnt[out] -= 1           # 离开窗口
            return ans
    ```

3. 📌 [使二进制字符串字符交替的最少反转次数](https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/description/)：

4. [字符串的排列](https://leetcode.cn/problems/permutation-in-string/)：

    **关键思路：滑动窗口 + 字典 Counter（排列的判断：两个字符串的每个字符的个数都相等）**

    ```python
    class Solution:
        def checkInclusion(self, s1: str, s2: str) -> bool:
            k = len(s1)
            cnt1 = Counter(s1)
            cnt2 = Counter(s2[:k-1])
            for out, in_ in zip(s2, s2[k-1:]):
                cnt2[in_] += 1
                if cnt2 == cnt1:
                    return True
                cnt2[out] -= 1
            return False
    ```

5. 📌 [串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/)：

6. 📌 [查找给定哈希值的子串](https://leetcode.cn/problems/find-substring-with-given-hash-value/description/)：

7. 📌 [统计完全子字符串](https://leetcode.cn/problems/count-complete-substrings/description/)：

8. 📌 [子串能表示从 1 到 N 数字的二进制串](https://leetcode.cn/problems/binary-string-with-substrings-representing-1-to-n/)：

    ```python
    class Solution:
        def queryString(self, s: str, n: int) -> bool:
            return all(bin(i)[2:] in s for i in range(1, n + 1))
    # 1. 暴力枚举 [1,n] 内的数，转成二进制字符串: 
    #    bin函数可以将整数转化为二进制字符串，去除掉前面的 '0b'
    # 2. all接受一个可迭代对象，如果可迭代对象中的所有元素都为 True 才返回True
    ```

### §1.3 其他

1. [学生分数的最小差值](https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/description/)：

    **关键思路：先将数组从小到大排序，然后只需取滑动窗口两端的最小差值即可**

    ```python
    class Solution:
        def minimumDifference(self, nums: List[int], k: int) -> int:
            nums.sort()
            return min(in_ - out for out, in_ in zip(nums, nums[k-1:]))
    ```

2. 📌 [存在重复元素 III](https://leetcode.cn/problems/contains-duplicate-iii/description/)：

## 二、不定长滑动窗口

### §2.1 求最长/最大
1. [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)：

    **关键思路：维护一个队列，把队列左边的元素移出直到满足题目要求**

    ```python
    class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        ans = left = 0
        cnt = defaultdict(int)
        for i, c in enumerate(s):
            cnt[c] += 1
            while cnt[c] > 1:
                cnt[s[left]] -= 1
                left += 1
            ans = max(ans, i - left + 1)
        return ans
    ```

    写法二：

    ```python
    class Solution:
        def lengthOfLongestSubstring(self, s: str) -> int:
            ans = 0
            seen = []
            for c in s:
                while c in seen:
                    del seen[0]   # 删除队列左边第一个，直到没有重复的字符串
                seen.append(c)
                ans = max(ans, len(seen))
            return ans
    ```

2. [每个字符最多出现两次的最长子字符串](https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/description/)：

    **关键思路：相当于上题的「出现次数不超过 1」改成「出现次数不超过 2」**

    ```python
    class Solution:
    def maximumLengthSubstring(self, s: str) -> int:
        ans = left = 0
        cnt = defaultdict(int)
        for i, c in enumerate(s):
            cnt[c] += 1
            while cnt[c] > 2:
                cnt[s[left]] -= 1
                left += 1
            ans = max(ans, i - left + 1)
        return ans
    ```

    写法二：

    ```python
    class Solution:
        def maximumLengthSubstring(self, s: str) -> int:
            ans = 0
            seen = []
            cnt = defaultdict(int)
            for c in s:
                cnt[c] += 1
                while c in seen and cnt[c] > 2:
                    cnt[seen[0]] -= 1
                    del seen[0]
                seen.append(c)
                ans = max(ans, len(seen))
            return ans
    ```

3. [删掉一个元素以后全为 1 的最长子数组](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/description/)：

    **关键思路：注意题目要求一定要删除一个0**

    ```python
    class Solution:
        def longestSubarray(self, nums: List[int]) -> int:
            ans = left = cnt0 = 0
            for right in range(len(nums)):
                cnt0 += 1 - nums[right]      # 计算 0 的数量
                while cnt0 > 1:              # 当 0 的数量大于1，左指针就往右滑
                    cnt0 -= 1 - nums[left]   # 如果 nums[left] 是 0， 要减掉 
                    left += 1
                ans = max(ans, right - left) # right - left + 1, 但是还要去除中间的 0
            return ans
    ```

4. [尽可能使字符串相等](https://leetcode.cn/problems/get-equal-substrings-within-budget/description/)：

    **关键思路：每一次字符转化的 cost 已知， 将问题转化为：在连续子数组的和小于等于 maxCost 的情况下，找到最长的连续子数组长度。**

    ```python
    class Solution:
        def equalSubstring(self, s: str, t: str, maxCost: int) -> int:
            ans = sum = left = 0
            for right in range(len(s)):
                sum += abs(ord(s[right]) - ord(t[right]))
                while sum > maxCost:
                    sum -= abs(ord(s[left]) - ord(t[left]))
                    left += 1
                ans = max(ans, right - left + 1)
            return ans
    ```

5. [找到最长的半重复子字符串](https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/description/)：

    **关键思路：定义 same 来统计相邻相同的情况出现了多少次，如果 same > 1，则不断移动左指针 left 直到 s[left] == s[left − 1]，此时将一对相同的字符移到窗口之外，然后将 same 置为 1**

    ```python
    class Solution:
        def longestSemiRepetitiveSubstring(self, s: str) -> int:
            ans, left, same = 1, 0, 0
            for right in range(1, len(s)):
                if s[right] == s[right - 1]:
                    same += 1
                if same > 1:
                    left += 1
                    while s[left] != s[left - 1]:
                        left += 1
                    same = 1
                ans = max(ans, right - left + 1)
            return ans
    ```

6. [最多 K 个重复元素的最长子数组](https://leetcode.cn/problems/length-of-longest-subarray-with-at-most-k-frequency/description/)：

    **关键思路：注意别超时，自己用窗口长度计算，用 defaultdict 的 sum(cnt.values()) 会超时**

    ```python
    class Solution:
        def maxSubarrayLength(self, nums: List[int], k: int) -> int:
            ans = left = 0
            cnt = Counter()
            for right, n in enumerate(nums):
                cnt[n] += 1
                while cnt[n] > k:
                    cnt[nums[left]] -= 1
                    left += 1
                ans = max(ans, right - left + 1)
            return ans
    ```

7. [数组的最大美丽值](https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/)：

    **关键思路：**

    **1. 选的是子序列，且操作后子序列的元素都相等，所以元素顺序对答案没有影响，可以先对数组排序**

    **2. 排序后要求 x + k ≥ y − k，x 为左边最小值，y 为右边最大值，即两者有交集，也就是 y - x ≤ 2k**

    **3. 将问题转化为：排序后，找最长的连续子数组，其最大值减最小值 ≤ 2k**

    ```python
    class Solution:
        def maximumBeauty(self, nums: List[int], k: int) -> int:
            nums.sort()
            ans = left = 0
            for right, n in enumerate(nums):
                while n - nums[left] > 2 * k:
                    left += 1
                ans = max(ans, right - left + 1)
            return ans
    ```

8. [考试的最大困扰度](https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/description/)：

    **关键思路：将题目转化为求 answerKey 的一个最长子串，至多包含 k 个 T 或者至多包含 k 个 F，滑动窗口直到 T 和 F 的出现次数至少有一个 ≤ k 即可**

    ```python
    class Solution:
        def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:
            ans = left = 0
            cnt = defaultdict(int)
            for right, c in enumerate(answerKey):
                cnt[c] += 1
                while cnt['T'] > k and cnt['F'] > k:
                    cnt[answerKey[left]] -= 1
                    left += 1
                ans = max(ans, right - left + 1)
            return ans
    ```

### §2.2 求最短/最小

### §2.3 求子数组个数

#### §2.3.1 越长越合法

#### §2.3.2 越短越合法

#### §2.3.3 恰好型滑动窗口

### §2.4 其他

## 三、单序列双指针

### §3.1 相向双指针

### §3.2 同向双指针

### §3.3 背向双指针

### §3.4 原地修改

## 四、双序列双指针

### §4.1 双指针

### §4.2 判断子序列

### §4.3 其他

## 五、三指针

## 六、分组循环