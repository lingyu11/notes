# 程序的表示、转换与链接

## 资料
* [课程视频](https://www.icourse163.org/learn/NJU-1001625001?tid=1474139493#/learn/content?type=detail&id=1262957763&cid=1301347968)

## Lecture 1 计算机系统概述
1. 用系统思维分析问题
    - 案例一：ISO C90标准下，在32位系统上以下C表达式的结果是什么？

    ```c
    -2147483648 < 2147483647     ➡️ false
    ```
    ```c
    int i = -2147483648;
    i < 2147483647               ➡️ true
    ```
    ```c
    -2147483647 - 1 < 2147483647 ➡️ true
    ```

    - 案例二：当len为0时，返回值应该是0，但是在机器上执行时，却发生了访存异常。➡️ 将len改为int型即可。

    ```c
    sum(int a[], unsigned len)
    {
        int i, sum = 0;
        for (i = 0; i <= len - 1; i++)
            sum += a[i];
        return sum;
    }
    ```

    - 案例三：若x和y为int型，当x = 65535时，y = x*x, y的值为多少？➡️ y = -131071。

    - 案例四：对于任何int型变量x和y，(x > y) == (-x < -y) 总成立吗？➡️ 当x = -2147483648时，y任意(除-2147483648外) 时不成立。

    - 案例五：打印结果是什么？➡️ d = 0, x = 1072693248

    ```c
    // main.c
    int d = 100;
    int x = 200;
    int main()
    {
        p1();
        printf("d= %d, x= %d\n", d, x);
        return 0;
    }

    // p1.c
    double d;
    void p1()
    {
        d = 1.0;
    }
    ```

    - 案例六：当count = 2^30+1时，程序会发生什么情况？➡️ count * sizeof(int)会溢出，最终结果为4，导致堆heap中大量数据被破坏。

    ```c
    int copy_array(int *array, int count)
    {
        int i;
        // 在堆区申请一块内存
        int *myarray = (int *) malloc(count * sizeof(int));
        if (myarray == NULL)
            return -1;
        for (i = 0; i < count; i++)
            myarray[i] = array[i];
        return count;
    }
    ```

    - 案例七：objdump反汇编代码，得知除以-1被优化成取负指令neg，故未发生除法溢出；而a/b则是用除法指令IDIV实现的，虽然不生成OF标志，但是“除法错”异常#DE会触发SIGFPE信号。

    ```c
    int a = 0x80000000;
    int b = a / -1;
    printf("%d\n", b); // 输出结果为 -2147483648
    ```

    ```c
    int a = 0x80000000;
    int b = -1;
    int c = a / b;
    printf("%d\n", c); // 输出结果为 "Floating point exception"
    ```

    - 案例八：在IA-32上运行时，结果为a=0; 在x86-64上运行时，打印结果a是一个不确定值。

    ```c
    #include <stdio.h>
    int main()
    {
        double a = 10;
        printf("a= %d\n", a);
        return 0;
    }
    ```

    - 案例九：关键差别在于一条指令：fldl和fildl
        - fldl: 直接把a这个01序列当成浮点数打印出来。
        - fildl: 先把a看成int型，再转换成double型去打印。

    ```c
    #include <stdio.h>
    int main(int argc, char *argv[])
    {
        int a = 10;
        double *p = (double*)&a;
        printf("%f\n", *p);           // 结果为 0.000000  (fldl)
        printf("%f\n", (double(a)));  // 结果为 10.000000 (fildl)
        return 0;
    }
    ```

2. 为什么要学习计算机系统基础
    ![C语言程序举例](../files/C语言程序举例.pdf){ type=application/pdf style="width:100%; min-height:70vh;" }

3. 计算机系统基本组成与基本功能
   ![计算机系统基本组成与基本功能](../files/计算机系统基本组成与基本功能.pdf){ type=application/pdf style="width:100%; min-height:70vh;" }


